/* 
 * ================================================================================
 * basicrobot.qak
 * ================================================================================
 https://peppe8o.com/fix-slow-ssh-remote-terminal-issue-in-raspberry-pi-os/
 */  
   
System  /* -trace  */   basicrobot22  
//mqttBroker "broker.hivemq.com" : 1883 eventTopic "unibo/basicrobot"   //broker.hivemq.com

Dispatch cmd       	: cmd(MOVE)     
Dispatch end       	: end(ARG)  
  
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
   
Dispatch obstacle  : obstacle( ARG ) 	//generated by distancefilter
Event   info       : info( ARG ) 	    //for external components, not coap-observed

Event  sonar       : sonar( DISTANCE )			//emitted by distancefilter
Event alarm        : alarm(X) 

Request  dopath    : dopath( PATH  )
Reply dopathdone   : dopathdone( ARG )
Reply dopathfail   : dopathfail( ARG )


Dispatch coapUpdate: coapUpdate(RESOURCE, VALUE)

Context ctxbasicrobot ip [host="localhost" port=8020]  

CodedQActor datacleaner    context ctxbasicrobot className "rx.dataCleaner"
CodedQActor distancefilter context ctxbasicrobot className "rx.distanceFilter"
 
QActor basicrobot context ctxbasicrobot{
[#
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L  
  var RobotType     = "" 
  var CurrentMove   = "unkknown"
#]  
 	State s0 initial { 	      
 		discardMsg Off  //WE want receive any msg
 		//[# unibo.comm22.utils.CommSystemConfig.tracing = false #]  //tracing at unibo.comm22 level
		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
 		delay 1000  //give to the realsonar the time to start
        if[# RobotType != "virtual" #]{
        	[# var robotsonar = context!!.hasActor("realsonar")  
        	   if(robotsonar != null) unibo.robot.robotSupport.createSonarPipe(robotsonar) 
        	#] 
  		}//The Virtual robot sonar is created in virtualrobotSupport2021
 
  		run unibo.robot.robotSupport.move( "a" )    //synch
 		run unibo.robot.robotSupport.move( "d" )	//synch
    		//run unibo.robot.robotSupport.move( "w" )    //asynch
 		updateResource [# "basicrobot(start)" #]
 	} 
	Goto work
	
	State work{ 
		println("basicrobot  | waiting .................. ")  
	} 
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep			 
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
					//whenEvent sonar       -> handleSonar
				  	whenMsg     end       -> endwork			  
	
	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors  
  			[# CurrentMove = payloadArg(0) #]
			run unibo.robot.robotSupport.move( payloadArg(0 ) )
			updateResource [# "moveactivated(${payloadArg(0)})" #]
		}
	 }
	 Goto work   
	 
	State handleObstacle{
		//println("basicrobotttttttttt | handleObstacle ${CurrentMove}")	
		//run unibo.robot.robotSupport.move( "h" ) //non importa 
		//printCurrentMessage
		updateResource [# "obstacle(${CurrentMove})" #]
		//JUNE22: behavior embedded in VirtualrobotSupport2021
		/* 
		if[# CurrentMove == "w" #]{
		//back to avoid emission of obstacle again if real robot moving forward !!!
		//if[# RobotType != "virtual" #]{	
			run unibo.robot.robotSupport.move( "s" )
			delay 100 
			run unibo.robot.robotSupport.move( "h" ) 
 		}*/
 		//emit info : info( obstacledoing(w) )
	}
	Goto work  
 
	State handleSonar{
		printCurrentMessage
	}
	Goto work
		
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime  ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever !!!
	}  
	Transition t0 
		whenTimeVar StepTime  -> stepDone  	 
 		whenMsg  obstacle     -> stepFail		
    	 
	
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done ???
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepFail{  	 	
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		//[# var TunedDuration =  Duration * 5 / 6 #]
		//[# var TunedDuration   = kotlin.math.round( (StepTime - Duration) * 15 / 100 ) #]
		[# var TunedDuration   =  ((StepTime - Duration) * 15 / 100).toLong()   #]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		updateResource [# "basicrobot(end)" #]	 		
 		terminate 1
	}   
 
}

QActor envsonarhandler context ctxbasicrobot{
 	State s0 initial { 	 
 		println("envsonarhandler | (RE)START")	 		
	}	
	Transition t1 
	  whenMsg cmd     -> dontcare
	  whenEvent sonar -> handleEnvSonar

	State dontcare{
		printCurrentMessage
	}
	Goto s0
		
	State handleEnvSonar{
		printCurrentMessage
		/* 
		onMsg( sonar : sonar(D,T)){ 
			println("envsonarhandler | sonar(${payloadArg(0)}) ")
		}*/
	}
	Transition t1 whenEvent sonar -> handleEnvSonar  
}

/* 
 * 

 */
 
QActor pathexec context ctxbasicrobot{ 
[# var CurMoveTodo = ""    //Upcase, since var to be used in guards
   var StepTime    = "300"
   var PathTodo    = ""
#]
	State s0 initial{  	
		//printCurrentMessage
		[#  CurMoveTodo = "" 
			StepTime = unibo.robot.robotSupport.readStepTime() //stepTimeConfig.json
		#]
		updateResource [# "pathexecsteptime($StepTime)" #]
		println("pathexec ready. StepTime=$StepTime") 
	}	
	Transition t0 whenRequest dopath -> doThePath
  	
	State doThePath{
		printCurrentMessage 
		//[# prinln( currentMsg ) #]
		onMsg ( dopath : dopath( PATH )){
			[# PathTodo = payloadArg(0) #]
		    updateResource [# "pathexecdopath($PathTodo)" #]
			run pathut.setPath( PathTodo )  //se payloadArg fallisce non da eccezione! (ma non fa nulla)
		}		 
		println("pathexec pathTodo = ${pathut.getPathTodo()}") 
 	}
	Goto nextMove    
	
	
	State nextMove{ 
		[# CurMoveTodo = pathut.nextMove() #]	
		//println("pathexec curMoveTodo=$CurMoveTodo" )
	} 
	Goto endWorkOk if [# CurMoveTodo.length == 0 #] else doMove
	
	State doMove{
		//printCurrentMessage
 		delay 300  //avoid too fast ...
 	}
	Goto doMoveW if [# CurMoveTodo == "w" #] else doMoveTurn
	
	State doMoveTurn{
		//printCurrentMessage
		updateResource [# "pathexecdoturn($CurMoveTodo)" #]
		forward basicrobot -m cmd : cmd($CurMoveTodo) //asynch !!!		
	}
	Transition t0 whenTime 300 ->  nextMove  //wait for move done ...
  
 	State doMoveW{
		//printCurrentMessage
		updateResource [# "pathexecdostep($CurMoveTodo)" #]
		request basicrobot -m step : step( $StepTime )
	}	
	Transition t0 whenEvent alarm     -> endWorkKo
 				  whenReply stepdone  -> nextMove  
	              whenReply stepfail  -> endWorkKo                       
	              
	State endWorkOk{
		//printCurrentMessage
		println("endWorkOk: PATH DONE - BYE")
		updateResource [# "path $PathTodo done" #]	
		replyTo dopath with dopathdone : dopathdone( ok )
	}
	Goto s0 
 
	State endWorkKo{
		printCurrentMessage
		[# var PathStillTodo = pathut.getPathTodo() #]
		updateResource [# "pathstilltodo($PathStillTodo)" #]	
		println("PATH FAILURE - SORRY. PathStillTodo=$PathStillTodo")
		replyTo dopath with dopathfail : dopathfail( $PathStillTodo )
	}	
	Goto s0


} 

QActor pathobs context ctxbasicrobot{
	State s0 initial{  	
		observeResource pathexec
	}	
	Transition t0 whenMsg coapUpdate -> handleUpdate
 	
	State handleUpdate{
		onMsg (coapUpdate : coapUpdate(RESOURCE, VALUE)) {
  		    [# MsgUtil.outgreen("applobserver OBSERVES: ${payloadArg(1)} FROM ${payloadArg(0)} ") #]
		}
	}
	Transition t0 whenMsg coapUpdate -> handleUpdate
}