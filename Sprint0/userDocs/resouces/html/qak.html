<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    body
    {
        margin-left:  30px;
        margin-right: 30px;
    };
    
    P
    {
        font-family: Tahoma;
        font-size: 10pt;
    };
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }
    
    a:hover {
        background-color: #cccccc;
    }
    
    
    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }
    
    h1, h2, h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }
    
    top {
        width: 100%;
    }
    
    
    #i {
        color: #ff1010;
    }
    tt{
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }
    em{
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style:solid;
        border-color: #abe876;
        color: #1632cc;
    }
    bc{
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }
    ks{
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD	;
        font-size: 90%;
    }
    kc{
        font-family: "Arial";
        font-weight: bold;
        color: #008000	;
        font-size: 90%;
    }
    pre{
        font-family:monospace;
        font-weight: 500;
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }
    key{
        font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-weight: 500;
        font-size: 100%;
        color: #304ceb;
    }
    key2{
        font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-weight: 500;
        font-size: 100%;
        color: #ad0d0f;
    }
    
    key3{
        font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-weight: 500;
        font-size: 100%;
        color: #01b948;
    }
    
    m{
        font-family: "Helvetica";
        line-height: 100%;
         font-size: 75%;
    }
    div.body{
         
        font-size: 18px;
    }
    k{
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }
    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }
    
    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }
    
    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }
    h4 {
        background-color: #6dd4f4b5;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    h5 {
        background-color: #d5ffb0;
        font-size: 100%;
    
    }
    div.req{
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }
    div.remark{
        background-color: #E3F2FD;
        border: 1.5px solid #d5f2ed;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    
    ol, ul, li {
      margin: 0;
      margin-left: 10px;
      padding: 0;
      padding-bottom: 5px;
    }
    
    table, th, td {
        border: 1px solid black;
    }
    
    img {
        border: 1.5px solid #d5f2ed
    
    }
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }
    
    div.wrapdesc{
        width: 90%;
        margin: auto;
    }
    
    div.imagedesc{
        width: 85%;
        margin: auto;
    }
    </style>
    
<head>
    <meta charset="UTF-8">
    <title>Qak</title>
</head>
    
<body>
<div id="top">
<h1><b> QActor (meta)model </b><font size="5"></font> </h1>
</div>  

<div class="body">
    <h2>Advantages of the model Qak</h2>

    The advantages of this model can be summarized in four points: <br></br>
            <ul>
                <li>
                    The software at our disposal is already developed in this language.
                </li>
                <li>
                    Minimize the "abstraction gap".
                </li>
                <li>
                    Define executable templates that are understood by the machine.
                </li>
                <li>
                    Though actors Kotlin allow to work on exchange of messages, in Kotlin there is no native construct allowing
                    to discriminate the different types of messages (Dispatch, Request, Reply, etc...), the Qak language helps us in this regard by 
                    Built-in construct layouts to differentiate between different message types.
                </li>
                <li>
                    Kotlin actors follow a <kc>message-driven</kc> architecture, which means that the behavior of a Kotlin actor is guided
                    from the messages it receives and the order in which it receives them. The metalanguage Qak expands the functionality of the actors Kotlin allowing 
                    to momentarily "swallow" some messages.
                </li>
            </ul>
</div>

<h2>Introduction</h2>
<div class="body"> 
    <div>
        <b> QActor</b> is the name given to the language to handle parallel processing in a high-performance network.
        The language is not intended as a generic language but as a modeling language for the analysis and design of distributed applications. The abbreviation qak refers to the version implemented in <b> Kotlin().</b> <br>
        The <b> qak </b>language is based on a core of concepts that make up the Qactor metamodel. <br>
            <li>
                 A <b> QA-System </b> is a set of active entities (QActors) each operating in a computational node (Context).
            </li>
            <li>
                <b> QActors </b> interact by using Messages of different types (Dispatch, Request,…) and Events.    
            </li>
            <li>
                Each context owns a set <b> QActors</b> that can interact with components (actors) working on a different node, by means of the following protocols: TCP, CoAP, MQTT.
            </li>
            <li>
                A <b> QActor </b> can deliver information to another QActor (both local or remote) by using a proper operations or by emitting events.
            </li>
        
</div>

<h2>Interaction</h2>

    Interaction in QActor models can be done through:
    <li>
       <b> Message:</b> intended as information sent in asynchronous way by some source to some specific destination.
       <dd>- For <b> asynchronous</b> transmission, we intend that the messages can be ‘buffered’ by the infrastructure, while the ‘unbuffered’ transmission is said to be <b> synchronous.</b></dd>
    </li>
    <li>
        <b> Event: </b>intended as information emitted by some source without any explicit destination.
        <dd>- Events whose identifier start with the prefix local_ are not propagated outside the context in which they are generated.</dd>
    </li>
    The methods that an application designer can use to deliver messages are:
    <li>
        <b> forward </b> for a Dispatch.
    </li>
    <li>
       <b> request</b>,<b> replyTo</b>, <b>askFor </b> for a Request.
    </li>
    <li>
        <b> emit</b> for an Event.
    </li>
    The QActor metamodel does not define any explicit receive operation.
In fact, the behavior of a QActor is modeled as a Moore machine in which state-transitions are triggered by messaged and events.

<h3>Qak specification template</h3>

    A Qak model is defined by organizing its description according to the following template: <br>
    <pre>
    System < NAME OF THE SYSTEM >
    //mqttBroker "broker.hivemq.com" : 1883 //OPTIONAL

    //DECLARATION OF MESSAGES AND EVENTS

    //DECLARATION OF CONTEXTS
    Context CTXNAME ip [host="HOSTIP" port=PORTNUM]

    //DECLARATION OF ACTORS
    </pre>

<h3>The Qak syntax</h3>

    <h4>Message declaration</h4>
    <pre>
    Event:    "Event"     name=ID  ":" msg = PHead  ;
    Dispatch: "Dispatch"  name=ID  ":" msg = PHead  ;
    Request:  "Request"   name=ID  ":" msg = PHead  ;
    Reply:    "Reply"     name=ID  ":" msg = PHead  ;

    PHead :       PAtom | PStruct | PStructRef ;
    ...
    </pre>
    <h4>Message-sending operations</h4>
    <pre>
        Forward   : "forward" dest=[QActorDeclaration]
                              "-m" msgref=[Dispatch] ":" val = PHead ;
        Emit      : "emit" msgref=[Event] ":" val = PHead     ;
        Demand    : "request" dest=[QActorDeclaration]
                              "-m" msgref=[Request]  ":" val = PHead ;
        Answer    : "replyTo" reqref=[Request]
                              "with"    msgref=[Reply]   ":" val = PHead ;
        ReplyReq  : "askFor"  reqref=[Request]
                              "request" msgref=[Request] ":" val = PHead ;
    </pre>

    <h3>Documentation</h3>

    <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html">Full Documentation</a>
<!--<h3>The QActor software factory</h3>
<div class="remark">
The mapping between the high-level communication actions and a specific protocol is done by the QActor-infrastructure with the help of the Eclipse QActor software factory. <br>

<center> <img src="../images/primaImg.drawio.png" alt="Requirements overview" style="width:38%" hspace="20" vspace="20"/> </center> <br>
The metamodel is supported by the qak-infrastructure defined in the project it.unibo.qakactor and deployed in it.unibo.qakactor-2.7.jar.
</div>
<h4>System description</h4>

    Given a system named xxx, the Qak Software Factory generates a file xxx.pl that includes a description (written in Prolog) of the system. Moreover, it generates a utility file sysRules.pl that is used by the QActor-infrastructure when it needs knowledge about the system.

<h4>CodedQActors</h4>
The Qak factory introduces a syntax-driven editor that makes it easy to write templates in the QAk language. This facilitation is especially useful when the models are a result of problem analysis (or even, in some cases, requirements). <br>
In other situations, however, it is not excluded that it is preferable to introduce actors written directly in Kotlin (or in Java) and use them as a kind of predefined components in models described in QAk language.


</div> 
-->
</body>
</html>