<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family:monospace;
    font-weight: 500;
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
key{
    font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    font-weight: 500;
	font-size: 90%;
    color: #304ceb;
}
key2{
    font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    font-weight: 500;
	font-size: 90%;
    color: #ad0d0f;
}

key3{
    font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    font-weight: 500;
	font-size: 100%;
    color: #01b948;
}

key4{
    font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    font-weight: 500;
	font-size: 90%;
    color: #008232;
}

pro{
    font-weight: bold;
    color:blue;
}
cons{
    font-weight: bold;
    color: red;
}

m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #6dd4f4b5;
    font-size: 100%;
	width: 100%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #91df4d;
    font-size: 100%;
    width: 100%;
	border-radius: 5px;
	padding: 2px;
}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    
<head>
    <meta charset="UTF-8">
    <title>Sprint1</title>
</head>
    
<body>
<div id="top">
<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
    
 
<h2>Requirements</h2>
<div class="remark">
    <a href="../../Sprint0/userDocs/resouces/html/TemaFinale22.html">TemaFinale22</a>
</div>

<h2>Work Plan</h2>
<div class="remark">
    In this Sprint we will focus on the <kc>Core Business</kc> of the system, we will analyze the main problems 
        relating to the core business, proposing solutions and identifying the best among them. 
        We will also develop a working prototype of the analyzed subproblem and automated tests to verify its correct functioning. <br>
        In particular, we will analyze the problems related to:
        <ul>
            <li>
                <a href="#depAct"><b>Deposit Action</b></a>
                <ul>
                    <li>How to move the <kc>transport trolley</kc> to its destination.</li>
                    <li>How the components of the system interacts.</li>
                    <li>How to manage the <kc>Service Area</kc> status.</li>
                </ul>
            </li>
            <li>
                <a href="#BackHome"><b>Back to Home</b></a>
                <ul>
                    <li>Who manages the "<i>back to home</i>" action </li>
                    <li>How the components interact</li>
                </ul>
            </li>
            <li> 
                <a href="#ASAP"><b>Send the <kc>truck</kc> away as soon as possible</b> </a>
                <ul>
                    <li>Identify the moment when the truck must leave the <kc>INDOOR</kc></li>
                    <li>How to tell the truck to leave <kc>INDOOR</kc></li>
                </ul>
            </li>
        </ul>
        
</div>

<h2>Problem analysis</h2>
<div class="remark">
    <h3>Sprint0 result</h3>
    At the end of the requirement analysis, reported in <a href="../../Sprint0/userDocs/sprint0.html">Sprint0</a>, the logical architecture is as follows: <br></br>
    <img src="../../Sprint0/userDocs/resouces/images/newLogicalArch.png" alt="" style="width: 40%; height: 40%;">
    <br>
</div>
<div class="remark">
    <div id="depAct"><h3>Requirement: Deposit Action</h3></div>
    <h4>Muovere il robot verso una destinazione</h4>
    <h5>Orientate in the environment</h5>
    Dai requisiti risulta chiaro che le dimensioni della stanza siano note apriori, così come sono note le posizioni dei punti d'interesse
    (<kc>HOME</kc>, <kc>INDOOR</kc>, <kc>PLASTICBOX</kc>, <kc>GLASSBOX</kc>) e altri valori costanti.
    Affinchè il sistema sia a conoscenza di tali informazioni, sarebbe utile configurarlo in maniera opportuna. <br><br>
    A tal proposito si potrebbero seguire due differenti approcci: <br>
    <ol>
        <li>Cablare i valori nel codice dell'applicazione</li>
        <li>Utilizzare un file di configurazione</li>
    </ol>
    Dal momento che il software debba essere capace di funzionare correttamente in <kc>Service areas</kc> di qualsiasi dimensioni, 
    la soluzione <b>n.1</b> risulta poco riutilizzabile e quindi inadatta, inquanto un cambiamento di <i>Service Area</i> richiederebbe un 
    cambiamento nel codice dell'applicazione con conseguente <i>rebuild</i> dell'applicazione stessa. <br>
    Per tale motivo consigliamo di utilizzare un <ks>file di configurazione</ks> che può essere facilmente modificato senza richiedere 
    cambiamenti di codice. Poiche, al momento, l'unico componente interessato a conoscere i dati di configurazione è il <kc>wasteService</kc>
    il file di configurazione può essere posizionato sul suo nodo computazionale, ed è consultabile in <a href="./resources/json/wasteServiceSystemConfig.json">wasteServiceSystemConfig.json</a>
    <div id="CONF">
        <pre>
{
    <key4>"LOCATION"</key4>: {
        <key4>"HOME"</key4>: ... ,
        <key4>"INDOOR"</key4>: ... ,
        <key4>"PLASTICBOX"</key4>: ... ,
        <key4>"GLASSBOX"</key4>: ...
    },
    <key4>"MAXPB"</key4>: 500,
    <key4>"MAXGB"</key4>: 500,
    <key4>"DLIMIT"</key4>: 40
}</pre>
            
    </div>
    
    Nasce quindi la problematica di come rappresentare la posizione dei punti d'interesse (<kc>HOME</kc>, <kc>INDOOR</kc>, <kc>PLASTICBOX</kc>, <kc>GLASSBOX</kc>), e del robot.
    <br><br>
    E' possibile, anche in questo caso seguire approcci differenti:
    <ol>
        <li>Utilizzare un sistema di coordinate GPS (DMS: gradi-minuti-secondi)</li>
        <li>Utilizzare un sistema di coordinate cartesiane X e Y</li>
        <li>Utilizzare gli elementi strutturali della <kc>Service Area</kc> (pareti, ostacoli ecc) come punti di riferimento</li>
    </ol>    
    <br>
    <ks><b>Coordinate GPS</b></ks> <br><br>
    L'utilizzo di coordinate GPS richiede la conoscenza delle coordinate GPS dei luoghi d'interesse e la presenza di un GPS a bordo del 
    <kc>DDR robot</kc>. <br><br> 
    I vantaggi e svantaggi di tale approccio sono:
    <br>
    <pro>+</pro>   Maggiore precisione <br>
    <cons>-</cons> Dotare il <i>DDR robot</i> di un sensore GPS. <br>
    <cons>-</cons> Processamento delle coordinate GPS per comprendere quali "mosse" il robot debba eseguire. <br>
    <cons>-</cons> Maggiore complessità. <br>
    <cons>-</cons> Introduzione di un ulteriore <i>overhead</i> di rete. <br> <br>

    <ks><b>Coordinate cartesiane</b></ks> <br><br>
    L'utilizzo delle coordinate cartesiane impone la necessità di scegliere un'unità di misura in modo da mappare opportunamente la 
    <i>Service Area</i>, a tal proposito si potrebbe utilizzare il <i>DDR robot</i> come unità di misura e mappare la <i>Servive Area</i>
    su di una griglia con celle di lato <kc>RD</kc> (dimensione DDR robot) come mostrato nella figura seguente:
    <img src="./resources/img/ServiceAreaMap.png" alt="">
    <br> <br>
    I luoghi d'interesse sono quindi rappresentati da una coppia di valori <b>X</b> e <b>Y</b>:
    <pre>
(0,0) indica la cella HOME
(X, Y) indica la cella che si trova X celle sotto HOME e Y celle a destra</pre>
    I vantaggi e gli svantaggi di questo approccio sono i seguenti: <br>
    <pro>+</pro> Minor complessità rispetto al caso precedente <br>
    <pro>+</pro> Possibilità di riutilizzare software gia sviluppato per mappare (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.mapperQak22">unibo.mapperQak22</a>), 
    indentificare il percorso (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.planner22">unibo.planner22</a>) 
    ed eseguire il path trovato (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.pathexecutor">unibo.pathexecutor</a>) <br>
    <cons>-</cons> Necessità di mappare la stanza  <br>
    <cons>-</cons> Potrebbero essere necessari degli aggiustamenti in quanto le dimensioni della stanza potrebbero non essere multiple di RD <br><br>
    <ks><b>Punti di riferimento</b></ks> <br><br>
    Questa soluzione prende ispirazione dal <kc>BoundaryWalker</kc>, un robot capace di muoversi lungo il perimetro di una qualsiasi 
    stanza delimitata da pareti, sfruttando la collissione con le pareti per capire quando effettuare una rotazione. <br>
    Sfruttando il fatto che i punti d'interesse si trovino agli angoli della stanza la soluzione 
    propone di utilizzare il sonar a bordo del <i>DDR robot</i> per rilevare la collissione con le pareti in modo da capire quando si è
    raggiunto un determinato punto d'interesse. <br> <br>
    I vantaggi e gli svantaggi di questo approccio senza coordinate, sono i seguenti: <br>
    <pro>+</pro> Minor complessità rispetto ai casi precedenti <br>
    <pro>+</pro> Non necessità l'utilizzo di software esterno (<i>unibo.planner22</i>, <i>unibo.pathexecutor</i>, <i>unibo.mapperQak22</i>) <br>
    <cons>-</cons> Il codice necessario a muovere il robot dipende dal punto di partenza e dal punto di arrivo, pertanto 
    sarà necessario prevedere tutti i possibili percorsi che il robot può effettuare <br>
    <cons>-</cons> Bassa riutilizzabilità del software, se i punti d'interesse non si trovassero agli angoli della stanza la soluzione 
    smetterebbe di funzionare<br>
    <br>
    <b>In conclusione</b> si consiglia vivamente agli sviluppatori di utilizzare il sistema di coordinate cartesiane, in quanto è più semplice da implementare,
    permette la riutilizzabilità del software anche in <kc>Service Area</kc> differenti e permette l'utillizzo dei software gia sviluppati 
    per mappare, pianificare e eseguire il percorso. <br>
    Sulla base delle considerazione fatte finora il file di configurazione <a href="#CONF">sopracitato</a> conterrà le seguenti informazioni:
    <pre>
{
    <key4>"LOCATION"</key4>: {
        <key4>"HOME"</key4>: [0, 0],
        <key4>"INDOOR"</key4>: [16, 0],
        <key4>"PLASTICBOX"</key4>: [16, 19],
        <key4>"GLASSBOX"</key4>: [0, 19]
    },
    <key4>"MAXPB"</key4>: 500,
    <key4>"MAXGB"</key4>: 500,
    <key4>"DLIMIT"</key4>: 40
}</pre>

    <h5>Path finding</h5>
    Una volta compreso come orientarsi nella stanza e come individuare i punti d'interesse nasce ora il problema di comprendere quale sia 
    il percorso da intraprendere per raggiungere un determinato punto d'interesse. <br> <br>
    Anche in questo caso gli approcci possibili sono due: <br>
    <ol>
        <li> Muoversi in linea retta</li>
        <li> Muoversi lungo il perimetro della stanza</li>
    </ol>
    <br>
    <ks><b>Linea retta</b></ks> <br><br>
    Questa soluzione prevede di far muovere il robot sull'unica retta che collega il punto di partenza con il punto di arrivo, come mostrato in figura: <br>
    <img src="./resources/img/path1.png" alt=""><br><br>
    Tuttavia, il problema di questa soluzione risiende nel fatto che il DDR robot è in grado di ruotare su se stesso di 90° alla volta come riportato in <a href="file:///Users/enricovalastro/Desktop/issLab/IssClone/issLab2022/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/VirtualRobot.html#virtualrobot">DDR robot</a>
    pertanto non è capace di camminare su di una linea a diversa angolazione, il percorso da intraprendere sarebbe il seguente:<br> 
    <img src="./resources/img/path2.jpg" alt=""><br><br>
    Quindi se si volesse seguire il percorso diretto si dovrebbe modificare opportunamente il codice del <kc>basicrobot22</kc> in modo da 
    riuscire a effettuare rotazioni ad angolature diverse. <br><br>
    I vantaggi e svantaggi di questo approccio sono i seguenti: <br>
    <pro>+</pro> Percorso più breve se si riuscisse a modificare opportunamente il <i>basicrobot22</i> <br>
    <cons>-</cons> Necessità di modificare il <i>basicrobot22</i> <br>
    <cons>-</cons> Non è possibile utilizzare il software già sviluppato per pianificare(<i>unibo.planner22</i>) e eseguire il percorso(<i>unibo.pathexecutor</i>)
    <br><br>
    <ks><b>Buondary Walk</b></ks> <br><br>
    Questa soluzione consiste nel far muovore il robot lungo il perimetro della stanza fino a destinazione, 
    come mostrato in figura: <br>
    <img src="./resources/img/path3.jpg" alt=""><br><br>
    I vantaggi e gli svantaggi di questo approccio sono i seguenti: <br>
    <pro>+</pro> Si dispone gia di componenti in grado di pianificare un percorso a partire dalle coordinate cartesiane della destinazione (<i>unibo.planner22</i>) e di eseguirlo(<i>unibo.pathexecutor</i>) <br>
    <cons>-</cons> Il percorso potrebbe essere più lungo rispetto al caso precedente. <br><br>
    <b>In conclusione</b>, considerando quando detto finora e considerando che al committente non interessa che il robot si muova su percorso più breve, 
    consigliamo agli svilippatori di utilizzare la soluzione <i>Boundary Walk</i> in quanto permette di utilizzare
    il software già sviluppato per pianificare e eseguire il percorso abbattendo cosi i tempi di sviluppo. <br><br>
    Per quanto riguarda il <kc>pathexecutor</kc> esso è modellato come un attore, utilizzando il linguaggio QAk, che riceve una richiesta
    di eseguire un percorso e risponde con un messaggio di conferma una volta completato il percorso o con una risposta di fallimento in caso contrario
    specificando la parte di percorso non eseguita. Il codice QAk del <i>pathexecutor</i> è consultabile <a href="./resources/qak/basicrobot.qak">qui</a> <br>
    <pre>
<key2>Request</key2> dopath     : dopath(PATH)
<key2>Reply</key2>   dopathdone : dopathdone(ARG)
<key2>Reply</key2>   dopathfail : dopathfail(PATHSTILLTODO)</pre>

    L'introduzione dell'attore <i>pathexecutor</i> comporta una modifica nell'architettura logica del sistema, esso si trova sullo stesso contesto del <i>basicrobot</i> pertanto l'architettura risultante sarà la seguente: <br>
    <img src="./resources/img/ArchLogic1.1.png" alt="" style="width: 40%; height: 40%;"><br><br>

    Per quanto riguarda il <kc>planner22</kc> esso è un utility Kotlin che permette di calcolare il percorso da intraprendere per raggiungere un determinato punto
    individuato dalle coordinate X e Y. Il codice Kotlin del <i>planner22</i> è consultabile <a href="./resources/kotlin/planner22Util.kt">qui</a> <br>
    Il suo utilizzo è molto semplice, per esempio per calcolare il path verso la destinazione "X=10" e "Y=12" basta eseguire il seguente codice:
    <pre>
planner22Util.initAI()
planner22Util.setGoal(10,12)
planner22Util.doPlan()</pre>

    <div id="actManager"><h5>Deposit e move actions managing</h5></div>
    Bisogna a questo punto comprendere quale componente del sistema debba essere il responsabile delle operazioni di deposito e movimento.
    Tali operazioni devono essere responsabilità del <kc>WasteService</kc>, del <kc>transportTrolley</kc> o sarebbe opportuno 
    dividire le responsabilità tra i due attori? <br><br>
    Risulta evidente assegnare al <i>WasteService</i> la responsabilità delle operazioni di deposito, in quanto esso è il destinatario 
    dell richieste di deposito provenienti dal truck. <br>
    Per quanto riguarda invece le operazioni di movimento, tale responsabilità può essere assegnato sia al <i>WasteService</i> che al <i>transportTrolley</i>.
    Tuttavia volendo rispetta il principio di <i><b>singola responsabilità</b></i> e volendo evitare di avere un attore troppo complesso,
    si consiglia agli sviluppatori di assegnare al <i>transportTrolley</i> la responsabilità delle operazioni di movimento, il tal modo il <i>transportTrolley</i>
    fungerà da attuatore, e nel caso in cui esso debba far uso di un <kc>planner</kc> potrebbe essere posto su di un nodo computazionale più potente 
    senza causare un eccessivo <i>overhead</i> sulla rete dovuto hai messaggi di movimento.

    <h4>Interazione tra i componenti</h4>
    Per quanto riguarda  l'interazione tra i componenti possiamo, in prima battuta, affermare che essi interagiscono a scambio di messaggi.
    L'utilizzo del linguaggui <kc>QAk</kc> ci permette di tipizzare i messaggi in modo tale da avere un controllo maggiore sulle interazioni tra i componenti.
    Nasce quindi il problema di individuare il tipo di messaggio per ogni interazione:

    <h5>Deposit request</h5>
    Come detto in precedenza, il <kc>WasteService</kc> è il destinatario delle richieste di deposito provenienti dal <kc>truck</kc>, 
    come risulta già evidente in fase di analisi questa interazione è di tipo <kc>request-reply</kc>:
    <pre>
<key3>// MATERIAL = PLASTIC | GLASS</key3>
<key2>Request</key2> storeWaste : storeWaste(MATERIAL, TRUCKLOAD)
<key2>Reply</key2> loadaccept : loadaccept(_)
<key2>Reply</key2> loadrejected : loadrejected(_)</pre>

    <h5>Deposit action</h5>
    L'azione di deposito è costituita da due fasi: la fase di <kc>pickup</kc> e la fase di <kc>dropout</kc>. <br>
    Come analizzato in <a href="#actManager">precedenza</a> l'azione di deposito è gestita dal <kc>WasteService</kc> ma viene eseguita dal 
    <kc>transportTrolley</kc>, è necessario quindi che i due si scambino opportuni messaggi. <br><br>

    <b><ks>Pickup</ks></b><br><br>
    Quando il <i>WasteService</i> accetta un carico, invia al <i>transportTrolley</i> un messaggio di <kc>pickup</kc> in modo che il 
    esso muova il <kc>DDR robot</kc> fino alla <kc>INDOOR</kc> e prelevi il carico. L'interazione può avvenire in due differti modi:
    <ul>
        <li><b>Dispatch</b>: messaggio <i>fire&forget</i> che non richiede uan risposta da parte del destinatario</li>
        <li><b>Request</b>: messaggio che richiede una risposta da parte del destinatario</li>
    </ul>
    Dal momento che il <i>WasteService</i> gestisce l'azione di deposito in tutte le sue parti, esso è interessato a sapare quando il 
    <i>transportTrolley</i> ha concluso tale operazione in modo da potergli comandare l'esecuzione di un'altra azione, per tale motivo
    sarebbe opportuno utilizzare un messaggio di tipo <kc>request-reply</kc>:
    <pre>
<key2>Request</key2> pickup : pickup(_)
<key2>Reply</key2> pickupdone : pickupdone(_)</pre>

    <b><ks>Dropout</ks></b><br><br>
    Quando il <i>WasteService</i> riceve il messaggio di <kc>pickupdone</kc> invia al <i>transportTrolley</i> un messaggio di <kc>dropout</kc>, in modo che esso 
    possa muovere il <i>DDR robot</i> verso il container e vi depositi il carico. Anche in questo caso l'interazione può avvenire in due differti modi:
    <ul>
        <li><b>Dispatch</b></li>
        <li><b>Request</b></li>
    </ul>
    Poichè il committente ha specificato che sarebbe opportuno mandar via il <i>truck</i> il prima possibile, 
    bisognerebbe evitare che il <i>WasteService</i> debba attendere la conclusione dell'azione di <kc>dropout</kc> 
    prima di poter gestire la richiesta di un altro <i>truck</i>. Per tale motivo utilizzare un messaggio di tipo <i>request-reply</i> 
    risulta poco pratico, sarebbe meglio utilizzare un messaggio di tipo <kc>dispatch</kc>, in modo che mentre il <i>transportTrolley</i>
    esegue il <i>dropout</i> il <i>WasteService</i> possa gestire la richiesta di un altro <i>truck</i>:

    <pre>
<key3>// MATERIAL = PLASTIC | GLASS</key3>
<key2>Dispatch</key2> dropout : dropout(MATERIAL)</pre>
    
    <h4>Stato della Service Area</h4>
</div>

<div class="remark">
    <div id="BackHome"><h3>Requirement: Back to Home</h3></div>
    From the requirements we know that when the action of <kc>deposit action</kc> is finished 
    and if there are no other requests the <kc>transport trolley</kc> must return to the <kc>HOME</kc>. 
    <h4>Who sends the backHome command</h4>
    To solve this problem, it is necessary to understand who communicates to the <i>transport trolley</i> to return to the <i>HOME</i> position <br>
    There can be two entities that deal with this: <br>
    <ol>
        <li>WasteService</li>
        <li>Transport Trolley</li>
    </ol>

    <ks><b>WasteService</b></ks> <br><br>
    It is the <kc>WasteService</kc> to communicate to the <kc>transport trolley</kc> to "re-enter" to the position of <i>HOME</i>.<br>
    Remember that the <i>wasteService</i> is an active entity and specifically has the task of managing requests that come from 
    <kc>truck</kc>. So you know whether there are still requests within the system that need to be handled or not. 
    When there are no requests it will be its task in some way (via commands or messages) to communicate to the <i>transport trolley</i> to return to <i>HOME</i>.
    <br><br>
    <ks><b>Transport Trolley</b></ks> <br><br>
    It is the <i>transport trolley</i> itself that moves to <i>HOME</i>.<br>
    This solution is not able to independently check if there are still requests in the system, as there is no "direct" connection between <i>truck</i> and <i>transport trolley.</i>
    Therefore by itself the <i>transport trolley</i> could return in <i>HOME</i>, but the risk is that there are within the system still some demands to manage of which the <i>transport trolley</i>
    It doesn’t know, so there’s no answer. In any case, a possible solution could be to send a message by the <i>transport trolley</i>.
    <br><br>
    The first solution is the one suggested to the developer because among all it has the advantage of "knowing" if there are still system requests to manage.

    <h4>Waste Service and Transport Trolley interaction</h4>
    The two components interact with each other by exchanging messages.
    Specifically, also based on when discussed in the previous point and assuming that the first solution is the convenient one,
    the <i>WasteService</i> could communicate to the <i>transport trolley</i> to return to <i>HOME</i> by means of a message such as:
    <pre>
<key2>forward</key2> transporttrolley <key2>-m</key2> gotohome: gothome(_)</pre>

    <h5>How does <i>transport trolley</i> understand that the Transport Trolley has completed the dropout</h5>
    Analysis of the <kc>deposit action</kc> problem showed that the pickup operation should be treated 
    as a <key2>Request</key2> while that of dropout as a <key2>Dispatch</key2>. 
    Thus the problem arises of informing the WasteService when the <i>transport trolley</i> completes the <i>dropout</i> operation. <br>
    A solution to this problem could be if the <i>transport trolley</i> sends a message to <i>WasteService</i> to inform him 
    the completion of the operation, as follows:
    <pre>
<key2>forward</key2> wasteService <key2>-m</key2> dropoutdone: dropoutdone(_)</pre>
    
    When the <i>WasteService</i> receives this message it may be in two different states: <br>
    <ol>
        <li>idle: waiting for a new request from the truck or a message from the <i>transport trolley</i></li>
        <li>requestEvaluation: evaluating whether to accept or reject a request from the truck</li>
    </ol>
    In the first case the <i>WasteService</i> immediately fetches the message from the queue and 
    Transitions to the backhome state in which it sends the command to the <i>transport trolley</i>:
    <pre>
<key2>Dispatch</key2> gotohome : gotohome(_)</pre>
    
    In the second case the <kc>dropoutdone</kc> message is inserted in the queue but not processed immediately. <br>
    The <i>WasteService</i> continues to evaluate the request and if the evaluation result is negative, sends a <kc>loadrejected</kc>
    to the truck, transitioning to the <i>idle</i> state where it picks the <i>dropoutdone</i> message from the queue and processes it as in the <b>n1</b> case.
    If the evaluation is positive, the <i>WasteService</i> sends a <i>pickup</i> request to the <i>transport trolley</i>
    and then takes the <i>dropoutdone</i> message from the queue and discards it. Then listens for a reply from the trolley.
      
</div>
<div class="remark">
    <div id="ASAP" ><h3>Requirement: As soon as possible</h3></div>
    After the interaction with the customer we made it clear that the truck must be sent away as soon as possible. We need to identify when the truck should leave the <kc>INDOOR</kc> and  how to send it away.
    <h4>Leave the <kc>INDOOR</kc></h4>
    Possible solutions:
    <ul>
        <li>The truck could leave the <kc>INDOOR</kc> immediately after unloading the load</li>
        <li>The truck could leave the <kc>INDOOR</kc> after the <kc>transport trolley</kc> has unloaded the waste load in the container</li>
    </ul>
    To meet the requirement of the customer and then send the truck away as soon as possible, we will use the first option that results in the end of the <kc>pickup </kc>action.
    

    <h4>How to send it away</h4>
    Possible solutions:
    <ul>
        <li>We can use the <kc>loadaccept</kc> message to send the truck away. This solution consists in wait to send the "loadaccept" until the <kc>transport trolley</kc> has completed the <kc>pickup</kc> action</li>
        <li>We can send the truck away by sending it a new message as soon as the <i>transport trolley</i> completes the <i>pickup</i> action.
    </ul>
    It is less expensive in terms of load on the network to send a single message (loadaccept) to accept the load and to send the truck away.
    <pre>
    <key2>State</key2> acceptRequest{
        <key2>request</key2> transporttrolley <key2>-m</key2> pickup : pickup
    }<key2>Transition</key2> t0 <key2>whenReply</key2> pickupdone -> dropout
                                                        
    <key2>State</key2> dropout{
        [# boxState.updateBoxWeight(requestMaterialToStore, requestWeightToStore) #]				
        <key2>replyTo</key2> storeWaste <key2>with</key2> loadaccept : loadaccept(_)
        [#var TYPE = requestMaterialToStore.toString()#]
        <key2>request</key2> transporttrolley <key2>-m</key2> dropout : dropout(TYPE)
    }<key2>Transition</key2> t0 <key2>whenReply</key2> dropoutdone -> idle                                         
}
    </pre>
    After the <b><i>WasteService</i></b> receives the <kc>pickupdone</kc> reply from the <b><i>transportTrolley</i></b>, it transits 
    in the <kc>dropout state</kc> and sends to the <b><i>SmartDevice</i></b> the <kc>loadaccept</kc> reply.
</div>
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	

<div style="background-color:rgba(60, 131, 186, 0.9); width:50%;text-align:center;color:white; margin-left: 25%; border-radius: 25px;" >
    <br>
    By students: <br>
    Name: Annamaria Simonitto, Enrico Valastro, Alessio Reitano   
    <br>
    Email: annamaria.simonitto@studio.unibo.it, enrico.valastro@studio.unibo.it, alessio.reitano@studio.unibo.it
    <br><br>
    <img src="../../Sprint0/userDocs/resouces/images/AnnamariaSimonitto.jpg" alt="" width="8%" height="8%">
    <img src="../../Sprint0/userDocs/resouces/images/EnricoValastro.jpeg" alt="" width="8.5%" height="8.5%">
    <img src="../../Sprint0/userDocs/resouces/images/AlessioReitano.jpeg" alt="" width="10%" height="10%">
</div> 
</body>
</html>