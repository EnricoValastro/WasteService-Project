<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family:monospace;
    font-weight: 500;
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
key{
    font-family:monospace;
    font-weight: 500;	
    color: #304ceb;
}
key2{
    font-family:monospace;
    font-weight: 500;
    color: #ad0d0f;
}

key3{
    font-family:monospace;
    font-weight: 500;
    color: #01b948;
}

key4{
    font-family:monospace;
    font-weight: 500;

    color: #008232;
}

pro{
    font-weight: bold;
    color:blue;
}
cons{
    font-weight: bold;
    color: red;
}

m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #6dd4f4b5;
    font-size: 100%;
	width: 100%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #91df4d;
    font-size: 100%;
    width: 100%;
	border-radius: 5px;
	padding: 2px;
}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #E3F2FD;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
div.remarkTest{
	background-color: #d4fbd7;
    border: 1.5px solid #d4fbd7;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    
<head>
    <meta charset="UTF-8">
    <title>Sprint1</title>
</head>
    
<body>
<div id="top">
<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  

<div class="body"> 
<a href="../../Sprint0/userDocs/sprint0.html">Sprint 0</a>
<a href="./sprint1.html">Sprint 1</a>
<a href="../../Sprint2/userDocs/sprint2.html">Sprint 2</a>
<a href="../../Sprint3/userDocs/sprint3.html">Sprint 3</a>
<h2>Introduction</h2>
<div class="remark">
    Progetto finale di ISS finalizzato allo sviluppo software di un impianto di smistamento dei rifiuti attraverso un robot che preleva il carico del camion e lo porta al container appropriato.
 </div>
 
<h2>Requirements</h2>
<div class="remark">
    <a href="../../Sprint0/userDocs/resouces/html/TemaFinale22.html">TemaFinale22</a>
</div>

<h2>Work Plan</h2>
<div class="remark">
    In questo Sprint ci concentreremo sul <kc>Core Business</kc> del sistema, analizzeremo le principali problematiche
        relative al core business, proponendo soluzioni e individuando le migliori tra di esse.
        Svilupperemo inoltre un prototipo funzionante del sottoproblema analizzato e dei test automatizzati per verificarne il corretto funzionamento. <br>
        In particolare, analizzeremo le problematiche relative a:
        <ul>
            <li>
                <a href="#depAct"><b>Deposit Action</b></a>
                <ul>
                    <li>Come spostare il <kc>transport trolley</kc> a destinazione</li>
                    <li>Come interagiscono i componenti del sistema</li>
                    <li>Come gestire lo stato della <kc>Service Area</kc></li>
                </ul>
            </li>
            <li>
                <a href="#BackHome"><b>Back to Home</b></a>
                <ul>
                    <li>Chi gestisce l'azione "<i>back to home</i>"</li>
                    <li>Come interagiscono i componenti</li>
                </ul>
            </li>
            <li> 
                <a href="#ASAP"><b>Send the truck away as soon as possible</b> </a>
                <ul>
                    <li>Identificare il momento in cui il <kc>truck</kc> deve abbandonare l'<kc>INDOOR</kc></li>
                    <li>Come dire al <i>truck</i> di lasciare l' <kc>INDOOR</kc></li>
                </ul>
            </li>
        </ul>
        
</div>

<h2>Problem analysis</h2>
<div class="remark">
    <h3>Sprint0 result</h3>
    Al termine dell'analisi dei requisiti, riportata in <a href="../../Sprint0/userDocs/sprint0.html">Sprint0</a>, l'architettura logica è la seguente: <br></br>
    <img src="../../Sprint0/userDocs/resouces/images/newLogicalArch.png" alt="" style="width: 40%; height: 40%;">
    <br>
</div>
<div class="remark">
    <div id="depAct"><h3>Requirement: Deposit Action</h3></div>
    <h4>Muovere il robot verso una destinazione</h4>
    <h5>Orientate in the environment</h5>
    Dai requisiti risulta chiaro che le dimensioni della stanza siano note apriori, così come sono note le posizioni dei punti d'interesse
    (<kc>HOME</kc>, <kc>INDOOR</kc>, <kc>PLASTICBOX</kc>, <kc>GLASSBOX</kc>) e altri valori costanti.
    Affinchè il sistema sia a conoscenza di tali informazioni, sarebbe utile configurarlo in maniera opportuna. <br><br>
    A tal proposito si potrebbero seguire due differenti approcci: <br>
    <ol>
        <li>Cablare i valori nel codice dell'applicazione</li>
        <li>Utilizzare un file di configurazione</li>
    </ol>
    Dal momento che il software debba essere capace di funzionare correttamente in <kc>Service areas</kc> di qualsiasi dimensioni, 
    la soluzione <b>n.1</b> risulta poco riutilizzabile e quindi inadatta, in quanto un cambiamento di <i>Service Area</i> richiederebbe un 
    cambiamento nel codice dell'applicazione con conseguente <i>rebuild</i> dell'applicazione stessa. <br>
    Per tale motivo consigliamo di utilizzare un <ks>file di configurazione</ks> che può essere facilmente modificato senza richiedere 
    cambiamenti di codice. Il file di configurazione è consultabile in <a href="./resources/json/wasteServiceSystemConfig.json">wasteServiceSystemConfig.json</a>
    <div id="CONF">
        <pre>
{
    <key4>"LOCATION"</key4>: {
        <key4>"HOME"</key4>: ... ,
        <key4>"INDOOR"</key4>: ... ,
        <key4>"PLASTICBOX"</key4>: ... ,
        <key4>"GLASSBOX"</key4>: ...
    },
    <key4>"MAXPB"</key4>: 500,
    <key4>"MAXGB"</key4>: 500,
    <key4>"DLIMIT"</key4>: 40
}</pre>
            
    </div>
    
    Nasce quindi la problematica di come rappresentare la posizione dei punti d'interesse (<kc>HOME</kc>, <kc>INDOOR</kc>, <kc>PLASTICBOX</kc>, <kc>GLASSBOX</kc>), e del robot.
    <br><br>
    E' possibile, anche in questo caso, seguire approcci differenti:
    <ol>
        <li>Utilizzare un sistema di coordinate GPS (DMS: gradi-minuti-secondi)</li>
        <li>Utilizzare un sistema di coordinate cartesiane X e Y</li>
        <li>Utilizzare gli elementi strutturali della <kc>Service Area</kc> (pareti, ostacoli ecc) come punti di riferimento</li>
    </ol>    
    <br>
    <ks><b>Coordinate GPS</b></ks> <br><br>
    L'utilizzo di coordinate GPS richiede la conoscenza delle coordinate GPS dei luoghi d'interesse e la presenza di un GPS a bordo del 
    <kc>DDR robot</kc>. <br><br> 
    I vantaggi e svantaggi di tale approccio sono:
    <br>
    <pro>+</pro>   Maggiore precisione <br>
    <cons>-</cons> Dotare il <i>DDR robot</i> di un sensore GPS. <br>
    <cons>-</cons> Processamento delle coordinate GPS per comprendere quali "mosse" il robot debba eseguire. <br>
    <cons>-</cons> Maggiore complessità. <br>
    <cons>-</cons> Introduzione di un ulteriore <i>overhead</i> di rete. <br> <br>

    <ks><b>Coordinate cartesiane</b></ks> <br><br>
    L'utilizzo delle coordinate cartesiane impone la necessità di scegliere un'unità di misura in modo da mappare opportunamente la 
    <i>Service Area</i>, a tal proposito si potrebbe utilizzare il <i>DDR robot</i> come unità di misura e mappare la <i>Servive Area</i>
    su di una griglia con celle di lato <kc>RD</kc> (dimensione DDR robot) come mostrato nella figura seguente:
    <img src="./resources/img/ServiceAreaMap.png" alt="">
    <br> <br>
    I luoghi d'interesse sono quindi rappresentati da una coppia di valori <b>X</b> e <b>Y</b>:
    <pre>
(0,0) indica la cella HOME
(X, Y) indica la cella che si trova X celle sotto HOME e Y celle a destra</pre>
    I vantaggi e gli svantaggi di questo approccio sono i seguenti: <br>
    <pro>+</pro> Minor complessità rispetto al caso precedente <br>
    <pro>+</pro> Possibilità di riutilizzare software gia sviluppato per mappare (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.mapperQak22">unibo.mapperQak22</a>), 
    identificare il percorso (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.planner22">unibo.planner22</a>) 
    ed eseguire il path trovato (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.pathexecutor">unibo.pathexecutor</a>) <br>
    <cons>-</cons> Necessità di mappare la stanza  <br>
    <cons>-</cons> Potrebbero essere necessari degli aggiustamenti in quanto le dimensioni della stanza potrebbero non essere multiple di RD <br><br>
    <ks><b>Punti di riferimento</b></ks> <br><br>
    Questa soluzione prende ispirazione dal <kc>BoundaryWalker</kc>, un robot capace di muoversi lungo il perimetro di una qualsiasi 
    stanza delimitata da pareti, sfruttando la collissione con le pareti per capire quando effettuare una rotazione. <br>
    Sfruttando il fatto che i punti d'interesse si trovino agli angoli della stanza la soluzione 
    propone di utilizzare il sonar a bordo del <i>DDR robot</i> per rilevare la collissione con le pareti in modo da capire quando si è
    raggiunto un determinato punto d'interesse. <br> <br>
    I vantaggi e gli svantaggi di questo approccio senza coordinate, sono i seguenti: <br>
    <pro>+</pro> Minor complessità rispetto ai casi precedenti <br>
    <pro>+</pro> Non necessita l'utilizzo di software esterno (<i>unibo.planner22</i>, <i>unibo.pathexecutor</i>, <i>unibo.mapperQak22</i>) <br>
    <cons>-</cons> Il codice necessario a muovere il robot dipende dal punto di partenza e dal punto di arrivo, pertanto 
    sarà necessario prevedere tutti i possibili percorsi che il robot può effettuare <br>
    <cons>-</cons> Bassa riutilizzabilità del software, se i punti d'interesse non si trovassero agli angoli della stanza la soluzione 
    smetterebbe di funzionare<br>
    <br>
    <b>In conclusione</b> si consiglia vivamente agli sviluppatori di utilizzare il sistema di coordinate cartesiane, in quanto è più semplice da implementare,
    permette la riutilizzabilità del software anche in <kc>Service Area</kc> differenti e permette l'utillizzo dei software gia sviluppati 
    per mappare, pianificare e eseguire il percorso. <br>
    Sulla base delle considerazione fatte finora il file di configurazione <a href="#CONF">sopracitato</a> conterrà le seguenti informazioni:
    <pre>
{
    <key4>"LOCATION"</key4>: {
        <key4>"HOME"</key4>: [0, 0],
        <key4>"INDOOR"</key4>: [16, 0],
        <key4>"PLASTICBOX"</key4>: [16, 19],
        <key4>"GLASSBOX"</key4>: [0, 19]
    },
    <key4>"MAXPB"</key4>: 500,
    <key4>"MAXGB"</key4>: 500,
    <key4>"DLIMIT"</key4>: 40
}</pre>

    <h5>Path finding</h5>
    Una volta compreso come orientarsi nella stanza e come individuare i punti d'interesse nasce ora il problema di comprendere quale sia 
    il percorso da intraprendere per raggiungere un determinato punto d'interesse. <br> <br>
    Anche in questo caso gli approcci possibili sono due: <br>
    <ol>
        <li> Muoversi in linea retta</li>
        <li> Muoversi lungo il perimetro della stanza</li>
    </ol>
    <br>
    <ks><b>Linea retta</b></ks> <br><br>
    Questa soluzione prevede di far muovere il robot sull'unica retta che collega il punto di partenza con il punto di arrivo, come mostrato in figura: <br>
    <img src="./resources/img/path1.png" alt=""><br><br>
    Tuttavia, il problema di questa soluzione risiede nel fatto che il DDR robot è in grado di ruotare su se stesso di 90° alla volta, come riportato in <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/VirtualRobot.html">DDR robot</a>.
    Pertanto il <i>robot</i> non è capace di muoversi su di una linea a diversa angolazione quindi il percorso da intraprendere sarebbe il seguente:<br> 
    <img src="./resources/img/path2.jpg" alt=""><br><br>
    Quindi se si volesse seguire il percorso diretto si dovrebbe modificare opportunamente il codice del <kc>basicrobot22</kc> in modo da 
    riuscire a effettuare rotazioni ad angolature diverse. <br><br>
    I vantaggi e svantaggi di questo approccio sono i seguenti: <br>
    <pro>+</pro> Percorso più breve se si riuscisse a modificare opportunamente il <i>basicrobot22</i> <br>
    <cons>-</cons> Necessità di modificare il <i>basicrobot22</i> <br>
    <cons>-</cons> Non è possibile utilizzare il software già sviluppato per pianificare(<i>unibo.planner22</i>) e eseguire il percorso(<i>unibo.pathexecutor</i>)
    <br><br>
    <ks><b>Boundary Walk</b></ks> <br><br>
    Questa soluzione consiste nel far muovore il robot lungo il perimetro della stanza fino a destinazione, 
    come mostrato in figura: <br>
    <img src="./resources/img/path3.jpg" alt=""><br><br>
    I vantaggi e gli svantaggi di questo approccio sono i seguenti: <br>
    <pro>+</pro> Si dispone già di componenti in grado di pianificare un percorso a partire dalle coordinate cartesiane della destinazione (<i>unibo.planner22</i>) e di eseguirlo (<i>unibo.pathexecutor</i>) <br>
    <cons>-</cons> Il percorso potrebbe essere più lungo rispetto al caso precedente. <br><br>
    <b>In conclusione</b>, considerando quando detto finora e considerando che al committente non interessa che il robot si muova sul percorso più breve, 
    consigliamo agli svilippatori di utilizzare la soluzione <i>Boundary Walk</i> in quanto permette di utilizzare
    il software già sviluppato per pianificare e eseguire il percorso abbattendo cosi i tempi di sviluppo. <br><br>
    Per quanto riguarda il <kc>pathexecutor</kc> esso è modellato come un attore, utilizzando il linguaggio QAk, che riceve una richiesta
    di eseguire un percorso e risponde con un messaggio di conferma una volta completato il percorso o con una risposta di fallimento in caso contrario,
    specificando la parte di percorso non eseguita. Il codice QAk del <i>pathexecutor</i> è consultabile <a href="./resources/qak/basicrobot.qak">qui</a> <br>
    <pre>
<key2>Request</key2> dopath     : dopath(PATH)
<key2>Reply</key2>   dopathdone : dopathdone(ARG)
<key2>Reply</key2>   dopathfail : dopathfail(PATHSTILLTODO)</pre>

    L'introduzione dell'attore <i>pathexecutor</i> comporta una modifica nell'architettura logica del sistema, esso si trova sullo stesso contesto del <i>basicrobot</i> pertanto l'architettura risultante sarà la seguente: <br>
    <img src="./resources/img/ArchLogic1.1.png" alt="" style="width: 40%; height: 40%;"><br><br>

    Per quanto riguarda il <kc>planner22</kc> esso è un utility Kotlin che permette di calcolare il percorso da intraprendere per raggiungere un determinato punto
    individuato dalle coordinate X e Y. Il codice Kotlin del <i>planner22</i> è consultabile <a href="./resources/kotlin/planner22Util.kt">qui</a> <br>
    Il suo utilizzo è molto semplice, per esempio per calcolare il path verso la destinazione "X=10" e "Y=12" basta eseguire il seguente codice:
    <pre>
planner22Util.initAI()
planner22Util.setGoal(10,12)
planner22Util.doPlan()</pre>

    <div id="actManager"><h5>Deposit e move actions managing</h5></div>
    Bisogna a questo punto comprendere quale componente del sistema debba essere il responsabile delle operazioni di deposito e movimento.
    Tali operazioni devono essere responsabilità del <kc>WasteService</kc>, del <kc>transportTrolley</kc> o sarebbe opportuno 
    dividere le responsabilità tra i due attori? <br><br>
    Risulta evidente assegnare al <i>WasteService</i> la responsabilità delle operazioni di deposito, in quanto esso è il destinatario 
    delle richieste di deposito provenienti dal truck. <br>
    Per quanto riguarda invece le operazioni di movimento, tale responsabilità può essere assegnato sia al <i>WasteService</i> che al <i>transportTrolley</i>.
    Tuttavia, volendo rispettare il principio di <a href="https://it.wikipedia.org/wiki/Principio_di_singola_responsabilit%C3%A0"><i><b>singola responsabilità</b></i></a> e volendo evitare di avere un attore troppo complesso,
    si consiglia agli sviluppatori di assegnare al <i>transportTrolley</i> la responsabilità delle operazioni di movimento. In tal modo il <i>transportTrolley</i>
    fungerà da attuatore, e nel caso in cui esso debba far uso di un <kc>planner</kc>, potrebbe essere posto su di un nodo computazionale più potente, 
    senza causare un eccessivo <i>overhead</i> sulla rete dovuto ai messaggi di movimento. <br><br>
    In ultima analisi, si potrebbe decidere di attuare un'ulteriore separazione delle responsabilità operando come segue: <br><br>
    Attribuire al componente <i>WasteService</i> le responsabilità di: 
    <ol>
        <li>Accettare/Rifiutare richieste da parte del <i>truckDriver</i></li>
        <li>Coordinare le operazioni di carico e scarico, cioè richiedere o comandare al <i>transportTrolley</i> l'esecuzione di qualche azione</li>
    </ol>
    Attribuire al componente <i>transportTrolley</i> le responsabilità di:
    <ol>
        <li>Muovere il DDR robot verso la destinazione stabilita</li>
        <li>Eseguire le azioni di carico e scarico del materiale</li>
    </ol>

    Seguire tale approccio richiederebbe, quindi, una modifica dell'architettura logica del sistema, in quanto prevederebbe la suddivisione del <i>WasteService</i> in due componenti 
    distinti, uno dedito alla ricezione e valutazione delle richieste di deposito e uno dedito alla coordinazione delle operazioni carico/scarico. Allo stesso modo, bisognerebbe 
    operare una modifica nell'architettura del <i>transportTrolley</i>, in quanto sarebbe opportuno attribuire ad un componente la responsabilità delle operazioni di movimento e 
    ad un altro la responsabilità delle operazioni di carico/scarico. <br><br>
    <ks>Seguire questa strada permetterebbe di ottenere componenti che adempiono ad una singola responsabilità e tale responsabilità sarebbe totalmente incapsulata nel componente stesso.</ks>
    
    <h4>Interazione tra i componenti</h4>
    Per quanto riguarda  l'interazione tra i componenti possiamo, in prima battuta, affermare che essi interagiscono a scambio di messaggi.
    L'utilizzo del linguagguio <kc>QAk</kc> ci permette di tipizzare i messaggi in modo tale da avere un controllo maggiore sulle interazioni tra i componenti.
    Nasce quindi il problema di individuare il tipo di messaggio per ogni interazione:

    <h5>Deposit request</h5>
    Come detto in precedenza, il <kc>WasteService</kc> è il destinatario delle richieste di deposito provenienti dal <kc>truck</kc>.
    Come risulta già evidente in fase di analisi questa interazione è di tipo <kc>request-reply</kc>:
    <pre>
<key3>// MATERIAL = PLASTIC | GLASS</key3>
<key2>Request</key2> storewaste   : storewaste(MAT, QUA)
<key2>Reply</key2>   loadaccept   : loadaccept(_)
<key2>Reply</key2>   loadrejected : loadrejected(_)</pre>

    <h5>Deposit action</h5>
    L'azione di deposito è costituita da due fasi: la fase di <kc>pickup</kc> e la fase di <kc>dropout</kc>. <br>
    Come analizzato in <a href="#actManager">precedenza</a>, l'azione di deposito è gestita dal <kc>WasteService</kc> ma viene eseguita dal 
    <kc>transportTrolley</kc>. E' necessario quindi che i due si scambino opportuni messaggi. <br><br>

    <b><ks>Pickup</ks></b><br><br>
    Quando il <i>WasteService</i> accetta un carico, invia al <i>transportTrolley</i> un messaggio di <i>pickup</i> in modo che  
    esso muova il <kc>DDR robot</kc> fino alla <kc>INDOOR</kc> e prelevi il carico. L'interazione può avvenire in due differti modi:
    <ul>
        <li><b>Dispatch</b>: messaggio <i>fire&forget</i> che non richiede una risposta da parte del destinatario</li>
        <li><b>Request</b>: messaggio che richiede una risposta da parte del destinatario</li>
    </ul>
    Dal momento che il <i>WasteService</i> gestisce l'azione di deposito in tutte le sue parti, esso è interessato a sapere quando il 
    <i>transportTrolley</i> ha concluso tale operazione in modo da potergli comandare l'esecuzione di un'altra azione, per tale motivo
    sarebbe opportuno utilizzare un messaggio di tipo <kc>request-reply</kc>:
    <pre>
<key2>Request</key2> pickup     : pickup(_)
<key2>Reply</key2>   pickupdone : pickupdone(_)</pre>

    <div id="drp"><b><ks>Dropout</ks></b><br><br></div>
    Quando il <i>WasteService</i> riceve il messaggio di <kc>pickupdone</kc> invia al <i>transportTrolley</i> un messaggio di <i>dropout</i>, in modo che esso 
    possa muovere il <i>DDR robot</i> verso il container e vi depositi il carico. Anche in questo caso l'interazione può avvenire in due differti modi:
    <ul>
        <li><b>Dispatch</b></li>
        <li><b>Request</b></li>
    </ul>
    Poichè il committente ha specificato che sarebbe opportuno mandar via il <i>truck</i> il prima possibile, 
    bisognerebbe evitare che il <i>WasteService</i> debba attendere la conclusione dell'azione di <i>dropout</i> 
    prima di poter gestire la richiesta di un altro <i>truck</i>. Per tale motivo utilizzare un messaggio di tipo <i>request-reply</i> 
    risulta poco pratico, sarebbe meglio utilizzare un messaggio di tipo <kc>dispatch</kc>, in modo che, mentre il <i>transportTrolley</i>
    esegue il <i>dropout</i>, il <i>WasteService</i> possa gestire la richiesta di un altro <i>truck</i>:

    <pre>
<key3>// MATERIAL = PLASTIC | GLASS</key3>
<key2>Dispatch</key2> dropout : dropout(MATERIAL)</pre>
    
    <h4>Gestione degli stati</h4>
    <h5>Stato della Service Area</h5>
    Affinche il <kc>WasteService</kc> possa rispondere in maniera opportuna alle richieste di deposito dei <kc>truck</kc> 
    è necessario che esso sia a conoscenza dello stato interno (peso corrente, peso massimo) dei container della <kc>Service Area</kc>. <br>
    Nasce quindi la problematica di come mantenere lo stato della <i>Service Area</i>. Le soluzioni possibili sono: 
    <ul>
        <li>Cablare i valori all'interno del codice del <i>WasteService</i></li>
        <li>Utilizzare una classe (Kotlin) che rappresenti lo stato della <i>Service Area</i></li>
    </ul>

    <b><ks>Stato cablato</ks></b><br><br>
    La prima soluzione prevede di cablare lo stato della <i>Service Area</i> all'interno del codice QAk del <i>WasteService</i> come di seguito:
    <pre>
<key2>QActor</key2> wasteservice <key2>context</key2> ctxwasteservice {
    [#
        var glassCurrWeight : Double 
        var glassMaxWeight = MAXGB
        var plasticCurrWeight : Double 
        var plasticMaxWeight = MAXPB
    #]
    <key2>State</key2> s0 <key2>initial</key2>{...}    
}</pre>
    
    Questa soluzione è quella più semplice, ma presenta dei problemi di manutenibilità e scalabilità, peraltro se all'interno del sistema 
    ci fossero altri componenti interessati a conoscoscere lo stato della <i>Service Area</i>, il <i>WasteService</i> potrebbe doversi  
    occupare della gestione di tali richieste, ne risulterebbe quindi un attore complesso e che viola il <i>principio di singola responsabilità</i>. <br><br>

    <b><ks>Data class</ks></b><br><br>
    La seconda soluzione prevede di utilizzare una classe Kotlin, nello specifico una <kc>data class</kc>, 
    che rappresenti lo stato della <i>Service Area</i> e che venga interpellata ogni qual volta il <i>WasteService</i> deve valutare 
    una nuova richiesta di deposito e che venga aggiornata ogni qual volta un carico viene accettato. <br>
    Un esempio completo di tale soluzione è consultabile in <a href="./resources/kotlin/ServiceAreaState.kt">ServiceAreaState.kt</a>:
    <pre>
<key>enum</key> <key>class</key> Material {
    PLASTIC, GLASS
}

<key>data class</key> ServiceAreaState(
    <key>private val</key> boxMaxWeight : MutableMap < Material, Double > = Material.values().associateWith { 0.0 }.toMutableMap(),
    <key>private val</key> boxCurrentWeight : MutableMap < Material, Double > = Material.values().associateWith { 0.0 }.toMutableMap()
) {  
}</pre>
    Questa soluzione risulta molto più pratica della precedente, lo stato della <i>Service Area</i> adesso è accessibile dall'esterno 
    senza sovraccaricare il <i>WasteService</i>. <br>
    Bisogna adesso comprendere come il <i>WasteService</i> debba accedere ai dati della <kc>ServiceAreaState</kc>. Le soluzioni possibili 
    sono due:
    <ul>
        <li>Accesso diretto: il <i>WasteService</i> accede direttamente ai dati della classe</li>
        <li>Accesso indiretto: il <i>WasteService</i> demanda l'operazione di accesso ad un altro componente</li>
    </ul>

    <b><ks>Accesso diretto</ks></b><br><br>
    Questa soluzione prevede che il <i>WasteService</i> acceda direttamente ai dati della classe <kc>ServiceAreaState</kc>, sebbene questo 
    approccio sia più semplice e diretto responsabilizza il <i>WasteService</i> a gestire lo stato della <i>Service Area</i> violando così 
    il principio di <i>singola responsabilità</i>. Inoltre la soluzione risulta poco scalabile, in quanto se il sistema dovesse 
    crescere e i parametri da valutare aumentassero, il carico di lavoro del <i>WasteService</i> aumenterebbe. <br><br>

    <b><ks>Accesso indiretto</ks></b><br><br>
    Questa soluzione prevede che, al momento del bisogno il <i>WasteService</i> richieda ad un componente incaricato di 
    gestire lo stato della <i>Service Area</i> di fornirgli i dati richiesti. In questo modo il <i>WasteService</i> viene svincolato 
    dalla responsabilità di valutare le richieste (<kc>storeWaste</kc>) e si occuperà solo di rispondere al <i>truck</i> e gestire il 
    <i>transportTrolley</i>. <br>
    Il componente incaricato di gestire lo stato della <i>Service Area</i> può essere modellato come un attore QAk che verrà opportunamente 
    interpellato dal <i>WasteService</i>. Sebbene questa soluzione preveda l'aggiunta di un nuovo attore QAk al sistema e lo scambio di messaggi 
    tra i due, consigliamo agli sviluppatori di adottare questo approccio. <br>
    In tal caso i messaggi scambiati tra il <i>WasteService</i> e il nuovo attore sarebbero:
    <pre>
<key2>Request</key2>  evalreq    : evalreq(MAT, QUA)            <key3>// MAT = PLASTIC | GLASS</key3>
<key2>Reply</key2>    evalok     : evalok(_)
<key2>Reply</key2>    evalko     : evalko(_)
<key2>Dispatch</key2> update     : update(MAT, QUA)</pre>
    
    L'inserimento di questo nuovo attore all'interno del sistema modifica l'architettura logica come in figura: <br>
    <img src="./resources/img/ArchLogicSprint1CM.png" alt="" style="width: 45%; height: 45%; ">

    <br>
    <h5>Stato del TransportTrolley</h5>

    In previsione delle fasi successive del progetto, sarebbe opportuno mantenere lo stato del <i>transportTrolley</i>. In particolare occorrerebe tenere traccia della posizione 
    del <i>transportTrolley</i> e del suo stato (inteso come stato di attività). <br>
    Dall'<a href="../../Sprint0/userDocs/sprint0.html">analisi dei requisiti </a> è emerso che lo stato del <i>transportTrolley</i> e la sua posizione nella stanza possono essere 
    rappresentati dai seguenti enumerativi:
    <pre>
<key>enum</key> <key>class</key> CurrStateTrolley { <i>IDLE</i>, <i>STOPPED</i>, <i>MOVING</i>, <i>PICKINGUP</i>, <i>DROPPINGOUT</i> }</pre>
    <pre>
<key>enum</key> <key>class</key> TTPosition { <i>HOME</i>, <i>INDOOR</i>, <i>PLASTICBOX</i>, <i>GLASSBOX</i> }</pre>

    Sebbene quanto stabilito in fase di analisi dei requisiti sia corretto, occorre tenere presente che il <i>transportTrolley</i> potrebbe trovarsi in una posizione diffirente da 
    quelle indicate nell'enumerativo <kc>TTPosition</kc>. In particolare, durante un'azione di movimento, il <i>transportTrolley</i> potrebbe trovarsi in una posizione 
    intermedia tra due punti d'interesse della stanza. Per questo motivo riteniamo necessaria la seguente modifica dell'enumerativo <i>TTPosition</i>: 
    <pre>
<key>enum</key> <key>class</key> TTPosition { <i>HOME</i>, <i>INDOOR</i>, <i>PLASTICBOX</i>, <i>GLASSBOX</i>, <i>ONTHEROAD</i> }</pre>
    Come nel caso precedente, le soluzioni possibili per mantenere lo stato del <i>transportTrolley</i> sono diverse. Consigliamo agli sviluppatori di adottare la soluzione che 
    prevede di mantenere lo stato in una classe in modo che esso sia accessibile da terze parti, come riportato di seguito: 
    <pre>
<key>enum class</key> CurrStateTrolley {
    IDLE, STOPPED, MOVING, PICKINGUP, DROPPINGOUT
}
<key>enum class</key> TTPosition{
    HOME, INDOOR, PLASTICBOX, GLASSBOX, ONTHEROAD
}
<key>data class</key> TransportTrolleyState(
        <key>private var</key> currState : CurrStateTrolley = CurrStateTrolley.IDLE,
        <key>private var</key> currPosition : TTPosition = TTPosition.HOME
){
    <key>fun</key> setCurrState(state : CurrStateTrolley) {...}
    <key>fun</key> setCurrPosition(position : TTPosition) {...}
    <key>fun</key> getCurrState() : CurrStateTrolley {...}
    <key>fun</key> getCurrPosition() : TTPosition {...}
}</pre>

    Il codice completo di questa classe è consultabile in <a href="./resources/kotlin/TransportTrolleyState.kt">TransportTrolleyState.kt</a>
    
</div>

<div class="remark">
    <div id="BackHome"><h3>Requirement: Back to Home</h3></div>
    Dai requisiti sappiamo che appena la <kc>deposit action</kc> termina se non ci sono altre richieste da servire il 
    <kc>transport trolley</kc> deve ritornare alla posizione <kc>HOME</kc>. Tale requisito apre diverse problematiche. 
    <h4>Gestione back to Home</h4>
    Bisogna comprendere a quale componente sia più opportuno affidare la responsabilità del rientro alla posizione <i>HOME</i>.
    In <a href="#actManager">precedenza</a> si è stabilito che sarebbe opportuno assegnare al <kc>WasteService</kc> la responsabilità di gestire le attività del <kc>DDR robot</kc> 
    mentre al <i>transportTrolley</i> la responsabilità di gestire le movenze e l'esecuzione delle attività. <br><br>
    Bisogna quindi comprendere sotto quale di queste due categorie ricada il requisito <kc>back to Home</kc>, si tratta di un'azione o semplicemente di 
    una movenza? <br><br>
    Il requisito <i>back to Home</i> può essere visto come una movenza del robot, cioè come un'azione che sposta il <i>DDR robot</i> dalla sua posizone attuale fino alla posizone <i>HOME</i>.
    Tuttavia poichè tale movenza è condizionata dal soddisfacimento di un requisito (assenza di nuove richieste nel sistema) essa può essere considerata 
    come una attività che il <i>DDR robot</i> deve svolgere quando si verificano determinate condizioni. <br>
    Inoltre la condizione che deve essere verificata per eseguire il <i>back to Home</i> è l'assenza di nuove richieste nel sistema, e poichè le richieste 
    sono gestite dal <i>WasteService</i> è opportuno che sia questo componente a coordinare l'esecuzione di tale compito. <br>

    <h4>Interazione tra i componenti</h4>
    Una volta compreso che il <i>WasteService</i> gestisce il <i>back to Home</i>, bisogna comprendere che tipo di interazione avvenga tra 
    il <i>WasteService</i> e il <i>transportTrolley</i> affinchè quest'ultimo esegua il ritorno alla <i>HOME</i>. <br>
    Anche in questa situazione le alternative sono due:
    <ul>
        <li>Request</li>
        <li>Dispatch</li>
    </ul>

    Poichè il <i>WasteService</i> non è interessato a conoscere l'esito del rientro in <i>HOME</i>, 
    sarebbe opportuno optare per l'utilizzo di un <i>Dispatch</i>, in tal modo il <i>WasteService</i> non dovrà gestire il messaggio di risposta.
    Sulla base di ciò, consigliamo agli sviluppatori di utilizzare il seguente messaggio per l'esecuzione del <i>back to Home</i>:
    <pre>
<key2>Dispatch</key2> gotohome : gotohome(_)</pre>
    
    Il <i>WasteService </i> deve quindi ordinare al <i>transportTrolley</i> di rientrare in <i>Home</i> se quest'ultimo ha concluso 
    l'operazione di deposito e se nel sistema non ci sono altre richieste da servire. <br>
    Tuttavia, l'analisi del problema <a href="#drp"><i>deposit action</i></a> ha evidenziato il fatto che il messaggio <kc>dropout</kc> 
    sia di tipo <i>Dispatch</i>, ciò implica che il <i>WasteService</i> non si aspetta nessuna risposta a tale messaggio. <br>
    Bisogna quindi comprendere come possa fare il <i>WasteService</i> a sapere quando il <i>transportTrolley</i> ha terminato l'esecuzione 
    del <i>dropout</i>. Le alternative possibili sono due:
    <ul>
        <li>Modificare il tipo del messaggio <i>dropout</i> in <i>request</i></li>
        <li>Fare in modo che il <i>transportTrolley</i> invii in maniera autonoma un messaggio di "notifica" quando termina l'esecuzione 
        dell'operazione <i>dropout</i></li>
    </ul>
    La prima soluzione è da evitare, in quanto come analizzato precedentemente l'uso di un messaggio di tipo <i>request</i> per il <i>dropout</i> è inopportuno.
    La seconda soluzione è quella consigliata, in quanto permette al <i>WasteService</i> di sapere quando il <i>transportTrolley</i> ha terminato 
    l'operazione di scarico senza la necessità di attendere una risposta. <br>
    Per tale motivo consigliamo agli sviluppatori di utilizzare il seguente messaggio per la notifica di fine operazione <i>dropout</i>:
    <pre>
<key2>Event</key2> dropoutdone : dropoutdone(_)</pre>
    
    I messaggi di tipo <ks>Event</ks> non vengono inseriti nella coda di messaggi dei componenti, questo ci permette di gestire il messaggio solo quando il <i>wasteservice</i> 
    non sta svolgendo altre attività e scartarlo in tutti gli altri casi. <br>

    Se al momento della ricezione di tale evento il <i>wasteservice</i> non sta valutando nessuna nuova richiesta, raccoglierà l'evento e invierà al <i>transportTrolley</i> 
    il messagio <kc>gotohome</kc>, altrimenti l'evento verà perso.
    
</div>

<div class="remark">
    <div id="ASAP" ><h3>Requirement: As soon as possible</h3></div>
    Dopo l'interazione con il committente abbiamo chiarito che il <i>truck</i> deve essere liberato il prima possibile. 
    Bisogna identificare quindi il momento migliore in cui il camion deve lasciare l'<kc>INDOOR</kc> e bisogna capire
    quale sia il modo migliore per mandarlo via.
    <h4>Leave the <kc>INDOOR</kc></h4>
    E' possibile liberare il <i>truck</i> in due momenti:
    <ul>
        <li>Non appena il <i>transportTrolley</i> preleva il carico</li>
        <li>Non appena il <i>transportTrolley</i> deposita il carico nel container</li>
    </ul>
    Sulla base di quanto detto dal committente, il momento migliore per liberare il <i>truck</i> è subito dopo la fine dell'operazione di <i>pickup</i>,
    ovvero quando il <i>WasteService</i> riceve il messaggio:
    <pre>
<key2>Reply</key2> pickupdone : pickupdone(_)</pre>

    <h4>How to send it away</h4>
    Anche in questo caso le soluzioni possibili sono due:
    <ul>
        <li>Utilizzare il messaggio <kc>loadaccept</kc> per mandare via il <i>truck</i></li>
        <li>Utilizzare un nuovo messaggio</li>
    </ul>
    La prima soluzione consiste nel ritardare l'invio del messaggio <i>loadaccept</i> fino a quando il <i>WasteService</i> non riceve il messaggio
    <kc>pickupdone</kc>. <br>
    La seconda soluzione, invece, prevede di inviare immediatamente il messaggio <i>loadaccept</i> e inviare un nuovo messaggio, non appena 
    il <i>WasteService</i> riceve il <i>pickupdone</i>, per mandare via il <i>truck</i>. <br>
    Le due soluzioni siano molto simili, la prima permette di risparmiare l'invio di un messaggio sulla rete diminuendo 
    quindi il carico di rete (<kc>overhead</kc>), d'altra parte la seconda potrebbe essere più opportuna per differenziare le due fasi ed evitare al <i>truck drive</i> 
    una lunga attesa prima di sapere se il carico è stato accettato o meno. <br>
    Per meglio comprendere le due soluzioni si mostrano, partendo dal primo caso, i due possibili prototipi d'interazione:
    <pre>
<key2>State</key2> acceptRequest{
    <key2>request</key2> transporttrolley <key2>-m</key2> pickup : pickup
}<key2>Transition</key2> t0 <key2>whenReply</key2> pickupdone -> dropout
                                                    
<key2>State</key2> dropout{
    <key2>replyTo</key2> storewaste <key2>with</key2> loadaccept : loadaccept(_)
    <key2>request</key2> transporttrolley <key2>-m</key2> dropout : dropout(MATERIAL)
}<key2>Transition</key2> t0 <key2>whenReply</key2> dropoutdone -> idle                                         
}</pre>
Nel secondo caso è necassario utilizzare un nuovo messaggio per mandare via il <i>truck</i>, il messaggio in questione potrebbe essere il seguente:
<pre>
<key2>Dispatch</key2> leaveindoor : leaveindoor(_)</pre>
Il prototipo d'interazione sarebbe il seguente:
    <pre>
<key2>State</key2> acceptRequest{
    <key2>replyTo</key2> storewaste <key2>with</key2> loadaccept : loadaccept(_)
    <key2>request</key2> transporttrolley <key2>-m</key2> pickup : pickup
}<key2>Transition</key2> t0 <key2>whenReply</key2> pickupdone -> dropout
                                                    
<key2>State</key2> dropout{
    <key2>forward</key2> smartdevice <key2>-m</key2> leaveindoor : leaveindoor(_)
    <key2>request</key2> transporttrolley <key2>-m</key2> dropout : dropout(MATERIAL)
}<key2>Transition</key2> t0 <key2>whenReply</key2> dropoutdone -> idle                                         
}</pre>
    
</div>

<div class="remark">
    <h3>Architettura Logica</h3>
    Sulla base di quanto emerso in fase di analisi del problema è possibile ridefinire l'architettura logica della <kc>Business Core</kc> e 
    quindi quella dell'intero sistema.<br> 
    La nuova architettura logica è riportata di seguito: <br><br>
    <img src="./resources/img/ArchLogicSprint1.png" alt="" style="width:60% ; height:60% ;">
</div>

<h2>Sprint1 - Review</h2>
<div class="remark">
</div>

<h2>Project</h2>
<div class="remark">
    <h3>WasteService Component</h3>
    Come suggerito dagli analisti, è stato deciso di progettare il <kc>WasteService</kc> come due componenti separati, uno dedito alla ricezione e valutazione delle richieste 
    da parte del <i>truck</i>, l'altro dedito al coordinamente delle azioni di carico e scarico del <i>transportTrolley</i>.<br>
    Il <i>WasteService</i> viene quindi diviso nei due componenti:
    <ul>
        <li><b>WasteServiceHandler</b></li>
        <li><b>WasteServiceCore</b></li>
    </ul> 

    <h4>WasteServiceHandler</h4>
    Questo componente è progettato come un <ks>Handler</ks>, si occupa di ricevere le richieste <kc>storewaste</kc> e rispondere al mittente con una <kc>loadaccept</kc> o con 
    una <kc>loadrejected</kc>. Per valutare se la richiesta può essere accetta o meno il <i>WasteServiceHandler</i> si avvale del componente <kc>ContainerManager</kc>.<br>
    Dopo aver valutato la richiesta, in caso di esito positivo, il <i>WasteServiceHandler</i> comunica al componente <kc>WasteServiceCore</kc> che deve iniziare il processo di deposito, tramite 
    il seguente messaggio:
    <pre>
<key2>Dispatch</key2> dojob : dojob(MAT)        <key3>// MAT = PLASTIC | GLASS</key3></pre>
    La figura seguente riporta lo schema d'interazione dei componenti: <br><br>
    <img src="./resources/img/InteractionSchemaWSH.png" alt="" style="width: 50%; height: 50%;">
<br><br>
    Il componente verrà implementato come una <ks>coroutines Kotlin</ks>. In particolare, faremo uso del metalinguaggio QAk che ci permetterà di semplificare il lavoro di sviluppo.
    Di seguito viene riportato il progetto della macchina a stati finiti del <i>WasteServiceHandler</i> e la sua implementazione tramite linguaggio QAk:<br>
    <img src="./resources/img/FSMwasteServiceHandler.png" alt="" style="width:50% ; height:50% ;"> <br><br>
    Quando si trova nello stato <b><i>idle</i></b> il <i>WasteServiceHandler</i> rimane in attesa di una richesta (<kc>storewaste</kc>) da parte del <kc>truck</kc> o di un messagio di fine (<kc>exit</kc>). 
    Non appena arriva la richiesta, il <i>WasteServiceHandler</i> inizia la valutazione transitando nello stato di <b><i>evalRequest</i></b>, in cui interroga il 
    <i>ContainerManager</i>. Se la risposta è positiva il <i>WasteServiceHandler</i> accetta la richiesta del <i>truck</i> transitando 
    nello stato <b><i>acceptRequest</i></b>, altrimenti transita nello stato <b><i>rejectRequest</i></b>. <br>
    
    <pre>
<key2>QActor</key2> wasteservicehandler <key2>context</key2> ctxwasteservice{
    <key2>State</key2> init <key2>initial</key2> {
        ....
    }<key2>Goto</key2> idle

    <key2>State</key2> idle {
        ....
    }<key2>Transition</key2> t0 <key2>whenRequest</key2> storeWaste -> evalReq
                    <key2>whenMsg</key2> exit -> end
    
    <key2>State</key2> evalReq {
        ....
    }<key2>Transition</key2> t0 <key2>whenReply</key2> evalOk -> acceptRequest
                    <key2>whenReply</key2> evalKo -> rejectRequest
    
    <key2>State</key2> acceptRequest {
        ....
    }<key2>Goto</key2> idle

    <key2>State</key2> rejectRequest {
        ....
    }<key2>Goto</key2> idle

    <key2>State</key2> end {
        <key2>terminate</key2> 1
    }
}</pre>
    Il codice completo è consultabile nel file <a href="./resources/qak/wasteService.qak">wasteService.qak</a>. 

    <h4>WasteServiceCore</h4>
    Questo componente è progettato come un <ks>Dispatcher</ks> di messaggi, quando riceve un messaggio <kc>dojob</kc> dal <kc>WasteServiceHandler</kc> avvia una catena di interazioni con 
    il <kc>transportTrolley</kc> al fine di portare a conclusione l'operazione di prelievo e deposito. Al termine dell'azione di <kc>pickup</kc>, il <i>WasteServiceCore</i> 
    invia un messaggio al <i>truck</i> per comunicargli di lasciare l'<kc>INDOOR</kc>. <br>
    La figura seguente riporta lo schema d'interazione dei componenti: <br><br>
    <img src="./resources/img/InteractionSchemaWSC.png" alt="" style="width: 50%; height: 50%;">
    <br><br>
    Come nel caso precedente il componente verrà implementato come una una <ks>coroutines Kotlin</ks> utilizzando il metalinguaggio QAk.
    Di seguito viene riportato il progetto della macchina a stati finiti e la sua implementazione in linguaggio QAk.<br><br>
    <img src="./resources/img/FSMwasteServiceCore.png" alt="" style="width:50% ; height:50% ;"> <br><br>
    Nello stato <i><b>idle</b></i> il <i>WasteServiceCore</i> è in ascolto di un evento <kc>dropoutdone</kc> da parte del <i>transportTrolley</i> o <br>di un messaggio <kc>dojob</kc> da parte del <i>WasteServiceHandler</i>.
    Nel primo caso il componente transita nello stato <i><b>backhome</b></i> ed invia al <i>transportTrolley</i> il messaggio <kc>gotohome</kc>, ritorna quindi in <i><b>idle</b></i>. <br>
    Nel secondo caso il componente transita nello stato <b><i>pickup</i></b> in cui richiede al <i>transportTrolley</i> l'esecuzione di una <kc>pickup</kc>, rimanendo in attessa 
    di una conferma di operazione avvenuta (<kc>pickupdone</kc>). Una volta ricevuta la conferma da parte del <i>transportTrolley</i>, il <i>WasteServiceCore</i> transita allo stato 
    <i><b>dropout</b></i> in cui notifica al <i>truck</i> di liberare l'INDOOR e successivamente invia al <i>transportTrolley</i> un messaggio <kc>dropout</kc>, ritorna quindi allo 
    stato <b><i>idle</i></b>.
   
    <pre>
<key2>QActor</key2> wasteservicecore <key2>context</key2> ctxwasteservice{

    <key2>State</key2> init <key2>initial</key2> {
        ....
    }<key2>Goto</key2> idle

    <key2>State</key2> idle {
        ....
    }<key2>Transition</key2> t0 <key2>whenMsg</key2> doJob -> pickup
                    <key2>whenEvent</key2> droputdone -> backHome
                    <key2>whenMsg</key2> exit -> end
        
    <key2>State</key2> backHome {
        ....
    }<key2>Goto</key2> idle 
    
    <key2>State</key2> pickup {
        ....
    }<key2>Transition</key2> t0 <key2>whenReply</key2> pickupdone -> dropout

    <key2>State</key2> dropout {
        ....
    }<key2>Goto</key2> idle     

    <key2>State</key2> end {
        <key2>terminate</key2> 1
    }
}</pre>
    Il codice completo è disponibile in <a href="./resources/qak/wasteService.qak">wasteService.qak</a>.

    <h4>Architettura Logica</h4>
    La divisione del componente <kc>WasteService</kc> in due componenti distinti <kc>WasteServiceHandler</kc> e <kc>WasteServiceCore</kc>, comporta una sensibile modifica all'architettura 
    logica del sistema, che assume la forma seguente: <br><br>
    <img src="./resources/img/ArchLogicSprint1WSH_C.png" alt="" style="width:50% ; height:50% ;"> 

</div>

<div class="remark">
    <h3>ContainerManager Component</h3>
    Il <kc>ContainerManager</kc> è il componente incaricato di gestire lo stato della <kc>Service Area</kc> e valutare le richieste per conto del <kc>WasteServiceHandler</kc>. <br>
    La stato della <i>Service Area</i> è mantenuto in una <ks>data class Kotlin</ks> che espone la seguente interafaccia:
    <pre>
<key>enum</key> <key>class</key> Material {
    PLASTIC, GLASS
}

<key>data class</key> ServiceAreState(
    <key>private val</key> boxMaxWeight : MutableMap < Material, Double > = Material.values().associateWith { 0.0 }.toMutableMap(),
    <key>private val</key> boxCurrentWeight : MutableMap < Material, Double > = Material.values().associateWith { 0.0 }.toMutableMap()
) {
    <key>fun</key> updateBoxWeight(material: Material, value : Double)
    <key>fun</key> getCurrBoxWeight(material: Material) : Double 
    <key>fun</key> canStore(material: Material, value: Double) : Boolean 
    <key>fun</key> getMaxBoxWeight(material: Material) : Double
}</pre>
    La <kc>ServiceAreaState</kc>, il cui codice è consultabile <a href="./resources/kotlin/ServiceAreaState.kt">qui</a>, offre inoltre i metodi per effetutare la serializzazione e la deserializzazione dell'oggetto:
    <pre>
<key>fun</key> toJsonString() : String
<key>companion object</key>{
    <key>fun</key> fromJsonString(str : String) : ServiceAreaState
}</pre>
    Che rispettivamente, ritornano la rappresentazione <ks>JSON</ks> dell'oggetto e l'oggetto della classe ricostruito a partire dalla sua rappresentazione <i>JSON</i>. <br>
    Per quanto riguarda il <i>ContainerManager</i>, sarà implementato come una <ks>coroutines Kotlin</ks> utilizzando il metalinguaggio QAk. Di seguito sono riportati il progetto 
    della macchina a stati finiti e la sua implementazione in QAk. <br><br>
    <img src="./resources/img/FSMcontainerManager.png" alt="" style="width:50% ; height:50% ;">
    <br><br>

    Il codice dell'attore QAk che implementa questa FSM é consultabile in: <a href="./resources/qak/wasteService.qak">wasteService.qak</a>
    <pre>
<key2>QActor</key2> containermanager <key2>context</key2> ctxwasteservice{
    
    <key2>State</key2> init <key2>initial</key2> {
                ....
    }<key2>Goto</key2> idle
            
    <key2>State</key2> idle {
                ....
    }<key2>Transition</key2> t0 <key2>whenRequest</key2> evalreq -> evaluation
                          <key2>whenMsg</key2> update -> update
                          <key2>whenMsg</key2> exit -> end
            
    <key2>State</key2> evaluation {
                ....
    }<key2>Goto</key2> idle
            
    <key2>State</key2> update {
                ....
    }<key2>Goto</key2> idle

    <key2>State</key2> end{
                ....
    }
}</pre>
    
    L'infrastruttura QAk ci permette, tra le altre cose, di sviluppare componenti (coroutines Kotlin) definiti in modo da essere delle risorse <ks>CoAP</ks> osservabili. <br>
    Tale agevolazione ci permette, in maniera semplice, di predisporre il componente al soddisfacimento di esigenze future.
    In particolare, nelle fasi successive del progetto, sarà necessario conoscere lo stato dei container della <i>Service Area</i>, per tale motivo il <i>ContainerManager</i> 
    sarà progettato in modo da poter notificare agli interessati i cambiamenti all'interno della <i>Service Area</i>. <br>
    Per fare questo sarà sufficente che il <i>ContainerManager</i> esegua il seguente comando:
    <pre>
[# val boxState  = wasteservice.state.ServiceAreaState() #]
<key2>updateResource</key2>[#boxState.toJsonString()#]</pre>
Questo comando inviera al <ks>server CoAP</ks> la stringa <i>JSON</i> che rappresenta l'oggetto di classe <i>ServiceAreaState</i>
</div>

<div class="remark">
    <h3>TransportTrolley Component</h3>
    Anche in questo caso si è scelto di seguire la strada consigliata dagli analisti. Pertanto, il <kc>transportTrolley</kc> è stato progettato come due componenti separati, 
    uno dedito all'esecuzione delle azioni di movimento, l'altro dedito all'esecuzioni delle azioni di carico e scarico. Tuttavia, si è reso necessario l'introduzione di un terzo 
    componente, che prenda in carico le richieste provenienti dal <kc>WasteServiceHandler</kc> e faccia da <i>orchestratore</i> per gli altri componenti. <br>
    Il <i>transportTrolley</i> è stato quindi diviso in tre componenti:
    <ul>
        <li><b>TransportTrolleyCore</b></li>
        <li><b>TransportTrolleyMover</b></li>
        <li><b>TransportTrolleyExecutor</b></li>
    </ul>

    <h4>TransportTrolleyCore</h4>
    Questo componente è progettato sulle basi del pattern <ks>Mediator</ks>, si occupa di ricevere richieste e messaggi dal <kc>WasteServiceCore</kc> e coordina gli altri
    componenti (<kc>TransportTrolleyMover</kc>, <kc>TransportTrolleyExecutor</kc>) per soddisfare le richieste. <br>
    La figura seguente riporta lo schema di interazione dei componenti: <br><br>
    <img src="./resources/img/InteractionSchemaTTC.png" alt="" style="width:50% ; height:50% ;">
    <br><br>

    Anche questo componente verrà implementato come una <ks>coroutine Kotlin</ks> utilizzando il metalinguaggio QAk. Di seguito sono riportati il progetto della macchina 
    a stati finiti e la sua implementazione in QAk. <br><br>
    <img src="./resources/img/FSMtransportTrolleyCore.png" alt="" style="width:50% ; height:50% ;"><br><br>
    Nello stato <i><b>idle</b></i> il <i>TransportTrolleyCore</i> rimane in attesa di un comando (<kc>pickup</kc>/<kc>dropout</kc>/<kc>gotohome</kc>) da parte del <i>WasteServiceCore</i>. <br>
    Nel caso in cui arrivi il messaggio <kc>gotohome</kc>, il <i>TransportTrolleyCore</i> transita allo stato <i><b>bakcHome</b></i>, in cui richiede al <i>TransportTrolleyMover</i> di muovere il robot 
    verso la posizione <kc>HOME</kc>, nel caso in cui la risposta del <i>TransportTrolleyMover</i> sia positiva transita allo stato <i><b>backHomeRes</b></i> e quindi allo stato <i><b>idle</b></i>. <br>
    Nel caso in cui arrivi il messaggio <kc>pickup</kc>, il <i>TransportTrolleyCore</i> transita allo stato <i><b>pickupMove</b></i>, in cui richiede al <i>TransportTrolleyMover</i> di muovere il robot
    verso l'<kc>INDOOR</kc> e rimane in attesa di un messaggio di conferma o errore da parte del <i>TransportTrolleyMover</i>. Se arriva una conferma allora il 
    <i>TransportTrolleyCore</i> transita allo stato <i><b>pickupExec</b></i>, in cui chiede al <i>TransportTrolleyExecutor</i> di eseguire un'azione di carico, attende dunque 
    una conferma o un messaggio di errore dallo stesso. Se arriva una conferma il componente transita allo stato <b><i>pickupRes</i></b> in cui invia una <kc>pickupdone</kc> al 
    <i>WasteServiceCore</i>, rientra quindi allo stato <i><b>idle</b></i>.<br>
    Nel caso in cui arrivi il messaggio <kc>dropout</kc>, l'iter da seguire è lo stesso del caso precedente l'unica differenza sta nelle destinazioni verso cui bisogna muovere 
    il robot e nelle azioni da eseguire. <br>
    Nel caso in cui un'azione di movimento o l'esecuzione di un'azione di carico/scarico generino un errore, sono stati previsti due stati in cui tale errore verrà gestito.
    Il <i>TransportTrolleyCore</i> transita allo stato <i><b>moveErr</b></i> per gestire un errore di movimento. L'esecuzione di un movimento, genera errori solo nel caso 
    in cui il robot fisico incontri qualche ostacolo sul suo percorso. Poi che da requisiti sappiamo che l'ambiente in cui opera il robot è privo di ostacoli, 
    abbiamo deciso di gestire l'errore come segue: dopo aver ricevuto un messaggio di errore dal robot, il <i>TransportTrolleyMover</i> tenterà di completare il percorso 
    per tre volte, se fallisce per tre volte consecutivamente invierà al <i>TransportTrolleyCore</i> il messaggio <kc>moveKo</kc>, quest'ultimo transiterà nello stato di errore 
    sopracitato e richiederà assistenza. <br>
    Per quanto riguarda gli errori dovuti all'esecuzione di un'azione essi non sono gestiti in quanto il committente ha specificato che le azioni possono essere 
    simulate con dei <ks>delay</ks>, pertanto risultano infallibili. <br> 

    <pre>
<key2>QActor</key2> transporttrolleycore <key2>context</key2> ctxtransporttrolley{
    <key2>State</key2> init initial{
    }<key2>Goto</key2> idle

    <key2>State</key2> idle{
    }<key2>Transition</key2> t0 <key2>whenRequest</key2> pickup -> pickupMove
                    <key2>whenMsg</key2> dropout -> dropoutMove
                    <key2>whenMsg</key2> gotohome -> backHome
                    <key2>whenMsg</key2> exit -> end

    <key2>State</key2> pickupMove{
    }<key2>Transition</key2> t0 <key2>whenReply</key2> moveok -> pickupExec
                    <key2>whenReply</key2> moveko -> moveErr

    <key2>State</key2> pickupExec{
    }<key2>Transition</key2> t0 <key2>whenReply</key2> execok -> pickupRes
                    <key2>whenReply</key2> execko -> execErr

    <key2>State</key2> pickupRes{
    }<key2>Goto</key2> idle

    <key2>State</key2> dropoutMove{
    }<key2>Transition</key2> t0 <key2>whenReply</key2> moveok -> dropoutExec
                    <key2>whenReply</key2> moveko -> moveErr

    <key2>State</key2> dropoutExec{
    }<key2>Transition</key2> t0 <key2>whenReply</key2> execok -> dropoutRes
                    <key2>whenReply</key2> execko -> execErr

    <key2>State</key2> dropoutRes{
    }<key2>Goto</key2> idle

    <key2>State</key2> backHome{
    }<key2>Transition</key2> t0 <key2>whenReply</key2> moveok -> backHomeRes
                    <key2>whenReply</key2> moveko -> moveErr

    <key2>State</key2> backHomeRes {
    }<key2>Goto</key2> idle

    <key2>State</key2> moveErr{
    }<key2>Goto</key2> idle 

    <key2>State</key2> execErr{
        <key3>//Still to be implemented</key3>
    }

    <key2>State</key2> end{
        terminate 0
    }
}</pre>

    Il codice completo è consultabile in <a href="./resources/qak/transportTrolley.qak">transportTrolley.qak</a>

    <h4>TransportTrolleyMover</h4>
    Questo componente è progettato come un <ks>attuatore</ks>, il suo unico compito è quello di muovere il robot. Per fare ciò, fa uso di un planner (<a href="./resources/kotlin/planner22Util2.kt">planner22Util.kt</a>), 
    che calcola il percorso verso una data destinazione, e di un executor (<a href="./resources/qak/basicrobot.qak">basicrobot.qak</a> - <kc>pathexec</kc>) che esegue il percorso calcolato.
    La seguente figura riporta lo schema d'interazione dei componenti: <br><br>
    <img src="./resources/img/InteractionSchemaTTM.png" alt="" style="width:50% ; height:50% ;"> <br><br>
    Anche questo componente viene implementato facendo uso del metalinguaggio QAk, di seguito sono riportati la sua <ks>FSM</ks> e il codice QAk che la implementa. <br><br>
    <img src="./resources/img/FSMtransportTrolleyMover.png" alt="" style="width:50% ; height:50% ;"> <br><br>
    Nello stato <i><b>idle</b></i> il componente resta in attesa di un messaggio <kc>moveto</kc>, all'arrivo di questo messaggio transita nello stato <i><b>destinationEval</b></i>, 
    in cui, in base al payload del messaggio, comprende la destinazione verso cui deve muoversi il robot e facendo uso di una utility Kotlin anche le coordinate della destinazione.
    L'utility in questione è consultabile in <a href="./resources/kotlin/ServiceAreaConfig.kt">ServiceAreaConfig.kt</a>.<br>
    Il componente transita quindi allo stato <i><b>plan</b></i>, in cui servendosi dell'utility Kotlin <a href="./resources/kotlin/planner22Util2.kt">planner22Util.kt</a>, calcola 
    il percorso verso la destinazione. <br>
    Si transita quindi allo stato <i><b>moveExec</b></i> in cui il componente comunica al <kc>pathExec</kc> il path da eseguire. Successivamente attende una risposta positiva o negativa dal 
    <i>pathExec</i>. <br>
    In caso di esito positivo transita allo stato <i><b>lookForFix</b></i>, in cui controlla se la direzione del robot è quella attesa. Se il robot è orientato in maniera corretta 
    si transita allo stato <b><i>moveOk</i></b> in cui il <i>TransportTrolleyMover</i> risponde al <i>TransportTrolleyCore</i> con una <kc>moveok</kc>. 
    Se il robot non è orientato in maniera giusta, si transita allo stato <b><i>fixDir</i></b> in cui servendosi di un utility (<a href="./resources/kotlin/DirectionFixer.kt">DirectionFixer.kt</a> ) calcola il path necessario a mettere il robot nella giusta direzione.
    Transita allo stato <i><b>moveExec</b></i> e riesegue lo stesso procedimento. <br>
    Nel caso in cui l'esito sia negativo il componente transita allo stato <i><b>moveko</b></i> in cui riprova per un massimo di tre volte ad eseguire il percorso, se per tre volte consecutive fallisce, invia un messaggio di errore che mette fine 
    all'esecuzione dell'intero sistema.

    <pre>
<key2>QActor</key2> transporttrolleymover <key2>context</key2> ctxtransporttrolley{
    <key2>State</key2> init <key2>initial</key2>{
        [# unibo.kotlin.planner22Util.initAI() #]
    }<key2>Goto</key2> idle
    
    <key2>State</key2> idle{
    }<key2>Transition</key2> t0 <key2>whenRequest</key2> moveto -> destinationEval
                    <key2>whenMsg</key2> exit -> end
    
    <key2>State</key2> destinationEval{
    }<key2>Goto</key2> plan
    
    <key2>State</key2> plan{
        [#
            unibo.kotlin.planner22Util.setGoal(xDestination, yDestination)
            unibo.kotlin.planner22Util.doPlan()
            PATH = unibo.kotlin.planner22Util.get_actionSequenceAsString()
        #]
    }<key2>Goto</key2> execMove
    
    <key2>State</key2> execMove{
    }<key2>Transition</key2> t0 <key2>whenReply</key2> dopathdone -> lookForFix
                    <key2>whenReply</key2> dopathfail -> moveKo
    
    <key2>State</key2> lookForFix{
    }<key2>Goto</key2> fixDir <key2>if</key2>[# someToFix #]
                    <key2>else</key2> moveOk 

    <key2>State</key2> fixDir{
    }<key2>Goto</key2> execMove

    <key2>State</key2> moveOk{
    }<key2>Goto</key2> idle 
    
    <key2>State</key2> moveKo{
    }<key2>Transition</key2> t0 whenReply dopathdone -> lookForFix
                    <key2>whenReply</key2> dopathfail -> moveKo 
                    
    <key2>State</key2> end{
        <key2>terminate</key2> 0
    }
}</pre>
Il codice completo è consultabile in <a href="./resources/qak/transportTrolley.qak">transportTrolley.qak</a> <br> <br>

Al fine di poter valutare il giusto orientamento del robot, è stato necessario modificare il file di configurazione <a href="./resources/json/wasteServiceSystemConfig.json">wasteServiceSystemConfig.json</a> <br>
Il file adesso contiene anche l'angolo in cui il robot deve essere orientato in ognuna delle aree d'interesse. <br>

Il <i>planner22Util</i> permette al <i>TransportTrolleyMover</i> di conoscere la direzione attuale del robot, grazie al metodo:
<pre>
unibo.kotlin.planner22Util.getDirection()</pre>

Conoscendo questi due dati e servendosi dell'utility <a href="./resources/kotlin/DirectionFixer.kt">DirectionFixer.kt</a> è possibile calcolare il path necessario a mettere il robot nella giusta direzione. <br>


<h4>TransportTrolleyExecutor</h4>
Come nel caso precedente, questo componente è stato progettato per essere un <ks>attuatore</ks>. Il suo unico compito è quello di servire le richieste <kc>execaction</kc> provenienti dal 
<kc>TransportTrolleyCore</kc>. Il componente simula le azioni di carico/scarico tramite un <ks>delay</ks> variabile: <br>
<pre>
delay(kotlin.random.Random.nextLong(from : <key>Long</key>, until : <key>Long</key>))</pre>
La figura seguente riporta lo schema d'interazione dei componenti: <br><br>
<img src="./resources/img/InteractionSchemaTTE.png" alt="" style="width:50% ; height:50% ;"> <br><br>

Dal momento che questo componente esegue solo un <i>delay</i>, si potrebbe pensare di implementarlo come una utility che il <i>TransportTrolleyCore</i> richiama al momento del bisogno.
Tuttavia, questo tipo d'interazione bloccherebbe il flusso di esecuzione del <i>TransportTrolleyCore</i> fino alla fine del <i>delay</i>. Per tale motivo si sceglie di 
implementare questo componente come un attore QAk che permette un tipo di interazione <ks>sincrona non bloccante</ks>. Inoltre, procedendo in questo modo, si lascia una 
"strada" aperta, nel caso in cui in futuro il componente debba essere esteso con altre funzionalità. <br>
Di seguito vengono riportati il progetto della macchina a stati finiti e il codice QAk che la implementa:
    
<img src="./resources/img/FSMtransportTrolleyExe.png" alt="" style="width:50% ; height:50% ;"> <br><br>
Nello stato <i><b>idle</b></i> il componente resta in attesa di un messaggio <kc>execaction</kc>, all'arrivo di questo messaggio transita nello stato <i><b>actionEval</b></i>, 
in cui, in base al payload del messaggio, comprende l'azione da eseguire. Transita quindi allo stato <i><b>execPickup</b></i> o <i><b>execDropout</b></i> e simula l'esecuzione tramite un <i>delay</i>. <br>
Il componente quindi risponde al <i>TransportTrolleyCore</i> con un messaggio di conferma. Ritorna quindi allo stato <i><b>idle</b></i>. 
<pre>
<key2>QActor</key2> transporttrolleyexecutor <key2>context</key2> ctxtransporttrolley{

    <key2>State</key2> init <key2>initial</key2>{
    }<key2>Goto</key2> idle
    
    <key2>State</key2> idle{
    }<key2>Transition</key2> t0 <key2>whenRequest</key2> execaction -> actionEval
                    <key2>whenMsg</key2> exit -> end
    
    <key2>State</key2> actionEval{
    }<key2>Goto</key2> execPickup <key2>if</key2>[#action.equals("PICKUP")#]
                        <key2>else</key2> execDropout
    
    <key2>State</key2> execPickup{
    }<key2>Goto</key2> idle
    
    <key2>State</key2> execDropout{
    }<key2>Goto</key2> idle
    
    <key2>State</key2> end{
        <key2>terminate</key2> 0
    }
}</pre>
    Il codice completo è consultabile in <a href="./resources/qak/transportTrolley.qak">transportTrolley.qak</a>

</div>

<div class="remark">
    <h3>Architettura Logica</h3>
    La divisione del componente <kc>TransportTrolley</kc> in tre componenti distinti <kc>TransportTrolleyCore</kc>, <kc>TransportTrolleyMover</kc> e <kc>TransportTrolleyExecutor</kc>, e 
    le precedenti modfiche apportate al componente <kc>WasteService</kc>, comportano un sensibile cambiamento all'architettura logica del sistema, che assume la forma seguente: <br><br>
    <img src="./resources/img/ArchLogicSprint1New.png" alt="" style="width:60% ; height:60% ;">
</div>

<div class="remark">
    <h3>Planner22Util</h3>
    L'utilizzo del <i>planner22Util</i> per calcolare il percorso verso una destinazione, ha richiesto l'estensione delle sue funzionalità. <br>
    Le problematiche sorte consistevano nell'aggiornamento della mappa interna al planner, più nello specifico è stato necessario aggiornare la posizione corrente del robot 
    dopo ogni <i>path</i> portato a termine e non. <br> In questo modo, al successivo utilizzo del <i>planner22Util</i> il calcolo del percorso avviene partendo dalla posizione 
    attuale del robot e non dalla posizione <i>(0, 0)</i>. Le estensioni apportate sono riportate di seguito e il codice completo è consultabile in <a href="./resources/kotlin/planner22Util2.kt">planner22Util.qak</a>:
    <pre>
@JvmStatic <key>fun</key> updateAfterPath(path : String){       <key3>// Funzione per aggiornare la posizione dopo dopathdone</key3>
    <key>var</key> mypath = path
    <key>while</key> (!mypath.equals(<key3>""</key3>)){
        var mov = <key3>""</key3> + mypath[<key>0</key>]
        mypath = mypath.substring(<key>1</key>)
        updateMap(mov,<key3>""</key3>)
    }
}</pre>
    <pre>
@JvmStatic <key>fun</key> updateAfterFail( path: String ){      <key3>// Funzione per aggiornare la posizione dopo dopathfail</key3>
    <key>var</key> mypath = get_actionSequenceAsString()
    <key>while</key> (!mypath.equals(path)){
        var mov = <key3>""</key3> + mypath[<key>0</key>]
        mypath = mypath.substring(<key>1</key>)
        updateMap(mov,<key3>""</key3>)
    }
}</pre>
    Affinche il <kc>TransportTrolleyMover</kc> sia in grado di utilizzare correttamente il <i>planner22Util</i>, occorre che esso sia a conoscenza delle coordinate cartesiane 
    delle possibili destinazioni. Come consigliato dagli analisti, le informazione sulla configurazione della <kc>Service Area</kc> sono mantenute in un file di configurazione 
    <a href="./resources/json/wasteServiceSystemConfig.json">wasteServiceSystemConfig.json</a>. Per permettere al <i>TransportTrolleyMover</i> di accedere a tali informazioni 
    è stata creata un <i>utility kotlin</i> che legge il file di configurazione e restituisce le coordinate cartesiane di una destinazione data in input. Il codice è consultabile 
    in <a href="./resources/kotlin/ServiceAreaDestinationConfig.kt">ServiceAreaDestinationConfig.kt</a>
    <pre>
<key>companion object</key> {
    <key>val</key> DIR_TO_PLAN = mapOf<Int, String>(
                0 to "rightDir",
                90 to "downDir",
                180 to "leftDir",
                270 to "upDir"
        )
    <key>val</key> config = File("wasteServiceSystemConfig.json").readText(StandardCharsets.UTF_8)
    <key>val</key> JsonObject = JSONObject(config)
    <key>val</key> LocJsonObj = JSONObject(JsonObject.get("LOCATION").toString())

    <key>fun</key> getXDestination(pos : String) : Int

    <key>fun</key> getYDestination(pos : String) : Int

    <key>fun</key> getDirection(pos : String) : Int
    
    <key>fun</key> getPlannerDirection(pos : String) : String
}</pre>

</div>

<h2>Test Plan</h2>
<div class="remarkTest">
    Coming soon...
</div>

<br/><br/> 	

<div style="background-color:rgba(60, 131, 186, 0.9); width:50%;text-align:center;color:white; margin-left: 25%; border-radius: 25px;" >
    <br>
    By students: <br>
    Name: Annamaria Simonitto, Enrico Valastro, Alessio Reitano   
    <br>
    Email: annamaria.simonitto@studio.unibo.it, enrico.valastro@studio.unibo.it, alessio.reitano@studio.unibo.it
    <br><br>
    <img src="../../Sprint0/userDocs/resouces/images/AnnamariaSimonitto.jpg" alt="" width="8%" height="8%">
    <img src="../../Sprint0/userDocs/resouces/images/EnricoValastro.jpeg" alt="" width="8.5%" height="8.5%">
    <img src="../../Sprint0/userDocs/resouces/images/AlessioReitano.jpeg" alt="" width="10%" height="10%">
</div> 
</body>
</html>