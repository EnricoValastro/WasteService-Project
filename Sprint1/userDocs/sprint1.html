<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family:monospace;
    font-weight: 500;
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
key{
    font-family:monospace;
    font-weight: 500;	
    color: #304ceb;
}
key2{
    font-family:monospace;
    font-weight: 500;
    color: #ad0d0f;
}

key3{
    font-family:monospace;
    font-weight: 500;
    color: #01b948;
}

key4{
    font-family:monospace;
    font-weight: 500;

    color: #008232;
}

pro{
    font-weight: bold;
    color:blue;
}
cons{
    font-weight: bold;
    color: red;
}

m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #6dd4f4b5;
    font-size: 100%;
	width: 100%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #91df4d;
    font-size: 100%;
    width: 100%;
	border-radius: 5px;
	padding: 2px;
}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>
    
<head>
    <meta charset="UTF-8">
    <title>Sprint1</title>
</head>
    
<body>
<div id="top">
<h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
    
 
<h2>Requirements</h2>
<div class="remark">
    <a href="../../Sprint0/userDocs/resouces/html/TemaFinale22.html">TemaFinale22</a>
</div>

<h2>Work Plan</h2>
<div class="remark">
    In questo Sprint ci concentreremo sul <kc>Core Business</kc> del sistema, analizzeremo le principali problematiche
        relative al core business, proponendo soluzioni e individuando le migliori tra di esse.
        Svilupperemo inoltre un prototipo funzionante del sottoproblema analizzato e dei test automatizzati per verificarne il corretto funzionamento. <br>
        In particolare, analizzeremo le problematiche relative a:
        <ul>
            <li>
                <a href="#depAct"><b>Deposit Action</b></a>
                <ul>
                    <li>Come spostare il <kc>transport trolley</kc> a destinazione.</li>
                    <li>Come interagiscono i componenti del sistema.</li>
                    <li>Come gestire lo stato della<kc>Service Area</kc>.</li>
                </ul>
            </li>
            <li>
                <a href="#BackHome"><b>Back to Home</b></a>
                <ul>
                    <li>Chi gestisce l'azione "<i>back to home</i>"</li>
                    <li>Come interagiscono i componenti</li>
                </ul>
            </li>
            <li> 
                <a href="#ASAP"><b>Send the truck away as soon as possible</b> </a>
                <ul>
                    <li>Identificare il momento in cui il <kc>truck</kc> deve abbandonare l'<kc>INDOOR</kc></li>
                    <li>Come dire al <i>truck</i> di lasciare l' <kc>INDOOR</kc></li>
                </ul>
            </li>
        </ul>
        
</div>

<h2>Problem analysis</h2>
<div class="remark">
    <h3>Sprint0 result</h3>
    Al termine dell'analisi dei requisiti, riportata in <a href="../../Sprint0/userDocs/sprint0.html">Sprint0</a>, l'architettura logica è la seguente: <br></br>
    <img src="../../Sprint0/userDocs/resouces/images/newLogicalArch.png" alt="" style="width: 40%; height: 40%;">
    <br>
</div>
<div class="remark">
    <div id="depAct"><h3>Requirement: Deposit Action</h3></div>
    <h4>Muovere il robot verso una destinazione</h4>
    <h5>Orientate in the environment</h5>
    Dai requisiti risulta chiaro che le dimensioni della stanza siano note apriori, così come sono note le posizioni dei punti d'interesse
    (<kc>HOME</kc>, <kc>INDOOR</kc>, <kc>PLASTICBOX</kc>, <kc>GLASSBOX</kc>) e altri valori costanti.
    Affinchè il sistema sia a conoscenza di tali informazioni, sarebbe utile configurarlo in maniera opportuna. <br><br>
    A tal proposito si potrebbero seguire due differenti approcci: <br>
    <ol>
        <li>Cablare i valori nel codice dell'applicazione</li>
        <li>Utilizzare un file di configurazione</li>
    </ol>
    Dal momento che il software debba essere capace di funzionare correttamente in <kc>Service areas</kc> di qualsiasi dimensioni, 
    la soluzione <b>n.1</b> risulta poco riutilizzabile e quindi inadatta, inquanto un cambiamento di <i>Service Area</i> richiederebbe un 
    cambiamento nel codice dell'applicazione con conseguente <i>rebuild</i> dell'applicazione stessa. <br>
    Per tale motivo consigliamo di utilizzare un <ks>file di configurazione</ks> che può essere facilmente modificato senza richiedere 
    cambiamenti di codice. Poiche, al momento, l'unico componente interessato a conoscere i dati di configurazione è il <kc>wasteService</kc>
    il file di configurazione può essere posizionato sul suo nodo computazionale, ed è consultabile in <a href="./resources/json/wasteServiceSystemConfig.json">wasteServiceSystemConfig.json</a>
    <div id="CONF">
        <pre>
{
    <key4>"LOCATION"</key4>: {
        <key4>"HOME"</key4>: ... ,
        <key4>"INDOOR"</key4>: ... ,
        <key4>"PLASTICBOX"</key4>: ... ,
        <key4>"GLASSBOX"</key4>: ...
    },
    <key4>"MAXPB"</key4>: 500,
    <key4>"MAXGB"</key4>: 500,
    <key4>"DLIMIT"</key4>: 40
}</pre>
            
    </div>
    
    Nasce quindi la problematica di come rappresentare la posizione dei punti d'interesse (<kc>HOME</kc>, <kc>INDOOR</kc>, <kc>PLASTICBOX</kc>, <kc>GLASSBOX</kc>), e del robot.
    <br><br>
    E' possibile, anche in questo caso seguire approcci differenti:
    <ol>
        <li>Utilizzare un sistema di coordinate GPS (DMS: gradi-minuti-secondi)</li>
        <li>Utilizzare un sistema di coordinate cartesiane X e Y</li>
        <li>Utilizzare gli elementi strutturali della <kc>Service Area</kc> (pareti, ostacoli ecc) come punti di riferimento</li>
    </ol>    
    <br>
    <ks><b>Coordinate GPS</b></ks> <br><br>
    L'utilizzo di coordinate GPS richiede la conoscenza delle coordinate GPS dei luoghi d'interesse e la presenza di un GPS a bordo del 
    <kc>DDR robot</kc>. <br><br> 
    I vantaggi e svantaggi di tale approccio sono:
    <br>
    <pro>+</pro>   Maggiore precisione <br>
    <cons>-</cons> Dotare il <i>DDR robot</i> di un sensore GPS. <br>
    <cons>-</cons> Processamento delle coordinate GPS per comprendere quali "mosse" il robot debba eseguire. <br>
    <cons>-</cons> Maggiore complessità. <br>
    <cons>-</cons> Introduzione di un ulteriore <i>overhead</i> di rete. <br> <br>

    <ks><b>Coordinate cartesiane</b></ks> <br><br>
    L'utilizzo delle coordinate cartesiane impone la necessità di scegliere un'unità di misura in modo da mappare opportunamente la 
    <i>Service Area</i>, a tal proposito si potrebbe utilizzare il <i>DDR robot</i> come unità di misura e mappare la <i>Servive Area</i>
    su di una griglia con celle di lato <kc>RD</kc> (dimensione DDR robot) come mostrato nella figura seguente:
    <img src="./resources/img/ServiceAreaMap.png" alt="">
    <br> <br>
    I luoghi d'interesse sono quindi rappresentati da una coppia di valori <b>X</b> e <b>Y</b>:
    <pre>
(0,0) indica la cella HOME
(X, Y) indica la cella che si trova X celle sotto HOME e Y celle a destra</pre>
    I vantaggi e gli svantaggi di questo approccio sono i seguenti: <br>
    <pro>+</pro> Minor complessità rispetto al caso precedente <br>
    <pro>+</pro> Possibilità di riutilizzare software gia sviluppato per mappare (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.mapperQak22">unibo.mapperQak22</a>), 
    identificare il percorso (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.planner22">unibo.planner22</a>) 
    ed eseguire il path trovato (<a href="https://github.com/anatali/issLab2022/tree/main/unibo.pathexecutor">unibo.pathexecutor</a>) <br>
    <cons>-</cons> Necessità di mappare la stanza  <br>
    <cons>-</cons> Potrebbero essere necessari degli aggiustamenti in quanto le dimensioni della stanza potrebbero non essere multiple di RD <br><br>
    <ks><b>Punti di riferimento</b></ks> <br><br>
    Questa soluzione prende ispirazione dal <kc>BoundaryWalker</kc>, un robot capace di muoversi lungo il perimetro di una qualsiasi 
    stanza delimitata da pareti, sfruttando la collissione con le pareti per capire quando effettuare una rotazione. <br>
    Sfruttando il fatto che i punti d'interesse si trovino agli angoli della stanza la soluzione 
    propone di utilizzare il sonar a bordo del <i>DDR robot</i> per rilevare la collissione con le pareti in modo da capire quando si è
    raggiunto un determinato punto d'interesse. <br> <br>
    I vantaggi e gli svantaggi di questo approccio senza coordinate, sono i seguenti: <br>
    <pro>+</pro> Minor complessità rispetto ai casi precedenti <br>
    <pro>+</pro> Non necessita l'utilizzo di software esterno (<i>unibo.planner22</i>, <i>unibo.pathexecutor</i>, <i>unibo.mapperQak22</i>) <br>
    <cons>-</cons> Il codice necessario a muovere il robot dipende dal punto di partenza e dal punto di arrivo, pertanto 
    sarà necessario prevedere tutti i possibili percorsi che il robot può effettuare <br>
    <cons>-</cons> Bassa riutilizzabilità del software, se i punti d'interesse non si trovassero agli angoli della stanza la soluzione 
    smetterebbe di funzionare<br>
    <br>
    <b>In conclusione</b> si consiglia vivamente agli sviluppatori di utilizzare il sistema di coordinate cartesiane, in quanto è più semplice da implementare,
    permette la riutilizzabilità del software anche in <kc>Service Area</kc> differenti e permette l'utillizzo dei software gia sviluppati 
    per mappare, pianificare e eseguire il percorso. <br>
    Sulla base delle considerazione fatte finora il file di configurazione <a href="#CONF">sopracitato</a> conterrà le seguenti informazioni:
    <pre>
{
    <key4>"LOCATION"</key4>: {
        <key4>"HOME"</key4>: [0, 0],
        <key4>"INDOOR"</key4>: [16, 0],
        <key4>"PLASTICBOX"</key4>: [16, 19],
        <key4>"GLASSBOX"</key4>: [0, 19]
    },
    <key4>"MAXPB"</key4>: 500,
    <key4>"MAXGB"</key4>: 500,
    <key4>"DLIMIT"</key4>: 40
}</pre>

    <h5>Path finding</h5>
    Una volta compreso come orientarsi nella stanza e come individuare i punti d'interesse nasce ora il problema di comprendere quale sia 
    il percorso da intraprendere per raggiungere un determinato punto d'interesse. <br> <br>
    Anche in questo caso gli approcci possibili sono due: <br>
    <ol>
        <li> Muoversi in linea retta</li>
        <li> Muoversi lungo il perimetro della stanza</li>
    </ol>
    <br>
    <ks><b>Linea retta</b></ks> <br><br>
    Questa soluzione prevede di far muovere il robot sull'unica retta che collega il punto di partenza con il punto di arrivo, come mostrato in figura: <br>
    <img src="./resources/img/path1.png" alt=""><br><br>
    Tuttavia, il problema di questa soluzione risiede nel fatto che il DDR robot è in grado di ruotare su se stesso di 90° alla volta, come riportato in <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/VirtualRobot.html">DDR robot</a>.
    Pertanto il <i>robot</i> non è capace di muoversi su di una linea a diversa angolazione quindi il percorso da intraprendere sarebbe il seguente:<br> 
    <img src="./resources/img/path2.jpg" alt=""><br><br>
    Quindi se si volesse seguire il percorso diretto si dovrebbe modificare opportunamente il codice del <kc>basicrobot22</kc> in modo da 
    riuscire a effettuare rotazioni ad angolature diverse. <br><br>
    I vantaggi e svantaggi di questo approccio sono i seguenti: <br>
    <pro>+</pro> Percorso più breve se si riuscisse a modificare opportunamente il <i>basicrobot22</i> <br>
    <cons>-</cons> Necessità di modificare il <i>basicrobot22</i> <br>
    <cons>-</cons> Non è possibile utilizzare il software già sviluppato per pianificare(<i>unibo.planner22</i>) e eseguire il percorso(<i>unibo.pathexecutor</i>)
    <br><br>
    <ks><b>Buondary Walk</b></ks> <br><br>
    Questa soluzione consiste nel far muovore il robot lungo il perimetro della stanza fino a destinazione, 
    come mostrato in figura: <br>
    <img src="./resources/img/path3.jpg" alt=""><br><br>
    I vantaggi e gli svantaggi di questo approccio sono i seguenti: <br>
    <pro>+</pro> Si dispone già di componenti in grado di pianificare un percorso a partire dalle coordinate cartesiane della destinazione (<i>unibo.planner22</i>) e di eseguirlo (<i>unibo.pathexecutor</i>) <br>
    <cons>-</cons> Il percorso potrebbe essere più lungo rispetto al caso precedente. <br><br>
    <b>In conclusione</b>, considerando quando detto finora e considerando che al committente non interessa che il robot si muova sul percorso più breve, 
    consigliamo agli svilippatori di utilizzare la soluzione <i>Boundary Walk</i> in quanto permette di utilizzare
    il software già sviluppato per pianificare e eseguire il percorso abbattendo cosi i tempi di sviluppo. <br><br>
    Per quanto riguarda il <kc>pathexecutor</kc> esso è modellato come un attore, utilizzando il linguaggio QAk, che riceve una richiesta
    di eseguire un percorso e risponde con un messaggio di conferma una volta completato il percorso o con una risposta di fallimento in caso contrario
    specificando la parte di percorso non eseguita. Il codice QAk del <i>pathexecutor</i> è consultabile <a href="./resources/qak/basicrobot.qak">qui</a> <br>
    <pre>
<key2>Request</key2> dopath     : dopath(PATH)
<key2>Reply</key2>   dopathdone : dopathdone(ARG)
<key2>Reply</key2>   dopathfail : dopathfail(PATHSTILLTODO)</pre>

    L'introduzione dell'attore <i>pathexecutor</i> comporta una modifica nell'architettura logica del sistema, esso si trova sullo stesso contesto del <i>basicrobot</i> pertanto l'architettura risultante sarà la seguente: <br>
    <img src="./resources/img/ArchLogic1.1.png" alt="" style="width: 40%; height: 40%;"><br><br>

    Per quanto riguarda il <kc>planner22</kc> esso è un utility Kotlin che permette di calcolare il percorso da intraprendere per raggiungere un determinato punto
    individuato dalle coordinate X e Y. Il codice Kotlin del <i>planner22</i> è consultabile <a href="./resources/kotlin/planner22Util.kt">qui</a> <br>
    Il suo utilizzo è molto semplice, per esempio per calcolare il path verso la destinazione "X=10" e "Y=12" basta eseguire il seguente codice:
    <pre>
planner22Util.initAI()
planner22Util.setGoal(10,12)
planner22Util.doPlan()</pre>

    <div id="actManager"><h5>Deposit e move actions managing</h5></div>
    Bisogna a questo punto comprendere quale componente del sistema debba essere il responsabile delle operazioni di deposito e movimento.
    Tali operazioni devono essere responsabilità del <kc>WasteService</kc>, del <kc>transportTrolley</kc> o sarebbe opportuno 
    dividere le responsabilità tra i due attori? <br><br>
    Risulta evidente assegnare al <i>WasteService</i> la responsabilità delle operazioni di deposito, in quanto esso è il destinatario 
    delle richieste di deposito provenienti dal truck. <br>
    Per quanto riguarda invece le operazioni di movimento, tale responsabilità può essere assegnato sia al <i>WasteService</i> che al <i>transportTrolley</i>.
    Tuttavia volendo rispettare il principio di <i><b>singola responsabilità</b></i> e volendo evitare di avere un attore troppo complesso,
    si consiglia agli sviluppatori di assegnare al <i>transportTrolley</i> la responsabilità delle operazioni di movimento. In tal modo il <i>transportTrolley</i>
    fungerà da attuatore, e nel caso in cui esso debba far uso di un <kc>planner</kc>, potrebbe essere posto su di un nodo computazionale più potente, 
    senza causare un eccessivo <i>overhead</i> sulla rete dovuto ai messaggi di movimento.

    <h4>Interazione tra i componenti</h4>
    Per quanto riguarda  l'interazione tra i componenti possiamo, in prima battuta, affermare che essi interagiscono a scambio di messaggi.
    L'utilizzo del linguagguio <kc>QAk</kc> ci permette di tipizzare i messaggi in modo tale da avere un controllo maggiore sulle interazioni tra i componenti.
    Nasce quindi il problema di individuare il tipo di messaggio per ogni interazione:

    <h5>Deposit request</h5>
    Come detto in precedenza, il <kc>WasteService</kc> è il destinatario delle richieste di deposito provenienti dal <kc>truck</kc>, 
    come risulta già evidente in fase di analisi questa interazione è di tipo <kc>request-reply</kc>:
    <pre>
<key3>// MATERIAL = PLASTIC | GLASS</key3>
<key2>Request</key2> storeWaste   : storeWaste(MATERIAL, TRUCKLOAD)
<key2>Reply</key2>   loadaccept   : loadaccept(_)
<key2>Reply</key2>   loadrejected : loadrejected(_)</pre>

    <h5>Deposit action</h5>
    L'azione di deposito è costituita da due fasi: la fase di <kc>pickup</kc> e la fase di <kc>dropout</kc>. <br>
    Come analizzato in <a href="#actManager">precedenza</a>, l'azione di deposito è gestita dal <kc>WasteService</kc> ma viene eseguita dal 
    <kc>transportTrolley</kc>. E' necessario quindi che i due si scambino opportuni messaggi. <br><br>

    <b><ks>Pickup</ks></b><br><br>
    Quando il <i>WasteService</i> accetta un carico, invia al <i>transportTrolley</i> un messaggio di <i>pickup</i> in modo che  
    esso muova il <kc>DDR robot</kc> fino alla <kc>INDOOR</kc> e prelevi il carico. L'interazione può avvenire in due differti modi:
    <ul>
        <li><b>Dispatch</b>: messaggio <i>fire&forget</i> che non richiede una risposta da parte del destinatario</li>
        <li><b>Request</b>: messaggio che richiede una risposta da parte del destinatario</li>
    </ul>
    Dal momento che il <i>WasteService</i> gestisce l'azione di deposito in tutte le sue parti, esso è interessato a sapere quando il 
    <i>transportTrolley</i> ha concluso tale operazione in modo da potergli comandare l'esecuzione di un'altra azione, per tale motivo
    sarebbe opportuno utilizzare un messaggio di tipo <kc>request-reply</kc>:
    <pre>
<key2>Request</key2> pickup     : pickup(_)
<key2>Reply</key2>   pickupdone : pickupdone(_)</pre>

    <div id="drp"><b><ks>Dropout</ks></b><br><br></div>
    Quando il <i>WasteService</i> riceve il messaggio di <kc>pickupdone</kc> invia al <i>transportTrolley</i> un messaggio di <i>dropout</i>, in modo che esso 
    possa muovere il <i>DDR robot</i> verso il container e vi depositi il carico. Anche in questo caso l'interazione può avvenire in due differti modi:
    <ul>
        <li><b>Dispatch</b></li>
        <li><b>Request</b></li>
    </ul>
    Poichè il committente ha specificato che sarebbe opportuno mandar via il <i>truck</i> il prima possibile, 
    bisognerebbe evitare che il <i>WasteService</i> debba attendere la conclusione dell'azione di <i>dropout</i> 
    prima di poter gestire la richiesta di un altro <i>truck</i>. Per tale motivo utilizzare un messaggio di tipo <i>request-reply</i> 
    risulta poco pratico, sarebbe meglio utilizzare un messaggio di tipo <kc>dispatch</kc>, in modo che, mentre il <i>transportTrolley</i>
    esegue il <i>dropout</i>, il <i>WasteService</i> possa gestire la richiesta di un altro <i>truck</i>:

    <pre>
<key3>// MATERIAL = PLASTIC | GLASS</key3>
<key2>Dispatch</key2> dropout : dropout(MATERIAL)</pre>
    
    <h4>Stato della Service Area</h4>
    Affinche il <kc>WasteService</kc> possa rispondere in maniera opportuna alle richieste di deposito dei <kc>truck</kc> 
    è necessario che esso sia a conoscenza dello stato interno (peso corrente, peso massimo) dei container della <kc>Service Area</kc>. <br>
    Nasce quindi la problematica di come rappresentare lo stato della <i>Service Area</i>, le soluzioni possibili sono: 
    <ul>
        <li>Cablare i valori all'interno del codice del <i>WasteService</i></li>
        <li>Utilizzare una classe (Kotlin) che rappresenti lo stato della <i>Service Area</i></li>
    </ul>

    <b><ks>Stato cablato</ks></b><br><br>
    La prima soluzione prevede di cablare lo stato della <i>Service Area</i> all'interno del codice QAk del <i>WasteService</i> come di seguito:
    <pre>
<key2>QActor</key2> wasteservice <key2>context</key2> ctxwasteservice {
    [#
        var glassCurrWeight = 0
        var glassMaxWeight = 500
        var plasticCurrWeight = 0
        var plasticMaxWeight = 500
    #]
    <key2>State</key2> s0 <key2>initial</key2>{...}    
}</pre>
    
    Questa soluzione è quella più semplice, ma presenta dei problemi di manutenibilità e scalabilità, peraltro se all'interno del sistema 
    ci fossero altri componenti interessati a conoscoscere lo stato della <i>Service Area</i>, il <i>WasteService</i> potrebbe doversi  
    occupare della gestione di tali richieste, ne risulterebbe quindi un attore complesso e che viola il <i>principio di singola responsabilità</i>. <br><br>

    <b><ks>Data class</ks></b><br><br>
    La seconda soluzione prevede di utilizzare una classe Kotlin, nello specifico una <kc>data class</kc>, 
    che rappresenti lo stato della <i>Service Area</i> e che venga interpellata ogni qual volta il <i>WasteService</i> deve valutare 
    una nuova richiesta di deposito e che venga aggiornata ogni qual volta un carico viene accettato. <br>
    Un esempio completo di tale soluzione è consultabile in <a href="./resources/kotlin/ServiceAreaState.kt">ServiceAreaState.kt</a>:
    <pre>
<key>enum</key> <key>class</key> Material {
    PLASTIC, GLASS
}

<key>data class</key> WasteServiceState(<key>private val</key> boxMaxWeight : MutableMap < Material, Double > = 
        Material.values().associateWith { 0.0 }.toMutableMap(),
            <key>private val</key> boxCurrentWeight : MutableMap< Material, Double > =
                Material.values().associateWith { 0.0 }.toMutableMap()
) {
    <key>fun</key> updateBoxWeight(material: Material, value : Double){...}
    <key>fun</key> getCurrBoxWeight(material: Material) : Double {...}
    <key>fun</key> canStore(material: Material, value: Double) : Boolean {...}
}</pre>
    Questa soluzione risulta molto più pratica della precedente, lo stato della <i>Service Area</i> adesso è accessibile dall'esterno 
    senza sovraccaricare il <i>WasteService</i>. <br>
    Bisogna adesso comprendere come il <i>WasteService</i> debba accedere ai dati della <kc>ServiceAreaState</kc>. Le soluzioni possibili 
    sono due:
    <ul>
        <li>Accesso diretto: il <i>WasteService</i> accede direttamente ai dati della classe</li>
        <li>Accesso indiretto: il <i>WasteService</i> demanda l'operazione di accesso ad un altro componente</li>
    </ul>

    <b><ks>Accesso diretto</ks></b><br><br>
    Questa soluzione prevede che il <i>WasteService</i> acceda direttamente ai dati della classe <kc>ServiceAreaState</kc>, sebbene questo 
    approccio sia più semplice e diretto responsabilizza il <i>WasteService</i> a gestire lo stato della <i>Service Area</i> violando così 
    il principio di <i>singola responsabilità</i>. Inoltre la soluzione risulta poco scalabile, in quanto se il sistema dovesse 
    crescere e i parametri da valutare aumentassero, il carico di lavoro del <i>WasteService</i> aumenterebbe. <br><br>

    <b><ks>Accesso indiretto</ks></b><br><br>
    Questa soluzione prevede che, al momento del bisogno il <i>WasteService</i> richieda ad un componente incaricato di 
    gestire lo stato della <i>Service Area</i> di fornirgli i dati richiesti. In questo modo il <i>WasteService</i> viene svincolato 
    dalla responsabilità di valutare le richieste (<kc>storeWaste</kc>) e si occuperà solo di rispondere al <i>truck</i> e gestire il 
    <i>transportTrolley</i>. <br>
    Il componente incaricato di gestire lo stato della <i>Service Area</i> può essere modellato come un attore QAk che verrà opportunamente 
    interpellato dal <i>WasteService</i>. Sebbene questa soluzione preveda l'aggiunta di un nuovo attore QAk al sistema e lo scambio di messaggi 
    tra i due, consigliamo agli sviluppatori di adottare questo approccio. <br>
    In tal caso i messaggi scambiati tra il <i>WasteService</i> e il nuovo attore sarebbero:
    <pre>
<key2>Request</key2>  evalReq    : evalReq(MAT, QUA) 
<key2>Reply</key2>    evalOk     : evalOk(_)
<key2>Reply</key2>    evalKo     : evalKo(_)
<key2>Dispatch</key2> update     : update(MAT, QUA)</pre>
    
    L'inserimento di questo nuovo attore all'interno del sistema modifica l'architettura logica come in figura: <br>
    <img src="./resources/img/ArchLogicSprint1CM.png" alt="" style="width: 45%; height: 45%; ">
</div>

<div class="remark">
    <div id="BackHome"><h3>Requirement: Back to Home</h3></div>
    Dai requisiti sappiamo che appena la <kc>deposit action</kc> termina se non ci sono altre richieste da servire il 
    <kc>transport trolley</kc> deve ritornare alla posizione <kc>HOME</kc>. Tale requisito apre diverse problematiche. 
    <h4>Gestione back to Home</h4>
    Bisogna comprendere a quale componente sia più opportuno affidare la responsabilità del rientro alla posizione <i>HOME</i>.
    In <a href="#actManager">precedenza</a> si è stabilito che sarebbe opportuno assegnare al <kc>WasteService</kc> la gestione delle attività del <kc>DDR robot</kc> 
    mentre al <i>transportTrolley</i> la gestione delle movenze. <br><br>
    Bisogna quindi comprendere sotto quale di queste due categorie ricada il requisito <kc>back to Home</kc>, si tratta di un'azione o semplicemente di 
    una movenza? <br><br>
    Il requisito <i>back to Home</i> può essere visto come una movenza del robot, cioè come un'azione che sposta il <i>DDR robot</i> dalla sua posizone attuale fino alla posizone <i>HOME</i>.
    Tuttavia poichè tale movenza è condizionata dal soddisfacimento di un requisito (assenza di nuove richieste nel sistema) essa può essere considerata 
    come una attività che il <i>DDR robot</i> deve svolgere quando si verificano determinate condizioni. <br>
    Inoltre la condizione che deve essere verificata per eseguire il <i>back to Home</i> è l'assenza di nuove richieste nel sistema, e poichè le richieste 
    sono gestite dal <i>WasteService</i> è opportuno che sia lui ad essere incaricato della gestione di tale compito. <br>

    <h4>Interazione tra i componenti</h4>
    Una volta compreso che il <i>WasteService</i> gestisce il <i>back to Home</i>, bisogna comprendere che tipo di interazione avvenga tra 
    il <i>WasteService</i> e il <i>transportTrolley</i> affinchè quest'ultimo esegua il ritorno alla <i>HOME</i>. <br>
    Anche in questa situazione le alternative sono due:
    <ul>
        <li>Request</li>
        <li>Dispatch</li>
    </ul>

    Poichè il <i>WasteService</i> non è interessato a conoscere l'esito del rientro in <i>HOME</i>, 
    sarebbe opportuno optare per l'utilizzo di un <i>Dispatch</i>, in tal modo il <i>WasteService</i> non dovrà gestire il messaggio di risposta.
    Sulla base di ciò, consigliamo agli sviluppatori di utilizzare il seguente messaggio per l'esecuzione del <i>back to Home</i>:
    <pre>
<key2>Dispatch</key2> gotohome : gotohome(_)</pre>
    
    Il <i>WasteService </i> deve quindi ordinare al <i>transportTrolley</i> di rientrare in <i>Home</i> se quest'ultimo ha concluso 
    l'operazione di deposito e se nel sistema non ci sono altre richieste da servire. <br>
    Tuttavia, l'analisi del problema <a href="#drp"><i>deposit action</i></a> ha evidenziato il fatto che il messaggio <kc>dropout</kc> 
    sia di tipo <i>Dispatch</i>, ciò implica che il <i>WasteService</i> non si aspetta nessuna risposta a tale messaggio. <br>
    Bisogna quindi comprendere come possa fare il <i>WasteService</i> a sapere quando il <i>transportTrolley</i> ha terminato l'esecuzione 
    del <i>dropout</i>. Le alternative possibili sono due:
    <ul>
        <li>Modificare il tipo del messaggio <i>dropout</i> in <i>request</i></li>
        <li>Fare in modo che il <i>transportTrolley</i> invii in maniera autonoma un messaggio di "notifica" quando termina l'esecuzione 
        dell'operazione <i>dropout</i></li>
    </ul>
    La prima soluzione è da evitare, in quanto come analizzato precedentemente l'uso di un messaggio di tipo <i>request</i> per il <i>dropout</i> è inopportuno.
    La seconda soluzione è quella consigliata, in quanto permette al <i>WasteService</i> di sapere quando il <i>transportTrolley</i> ha terminato 
    l'operazione di scarico senza la necessità di attendere una risposta. <br>
    Per tale motivo consigliamo agli sviluppatori di utilizzare il seguente messaggio per la notifica di fine operazione <i>dropout</i>:
    <pre>
<key2>Dispatch</key2> dropoutdone : dropoutdone(_)</pre>
    Alla ricezione di tale messaggio il <i>WasteService</i> potrebbe trovarsi in due possibili stati:
    <ol>
        <li><b>idle</b>: in attesa di una richiesta da parte del <i>truck</i> o di un messaggio dal <i>transportTrolley</i></li>
        <li><b>requestEvaluation</b>: in cui valuta se accettare o rifiutare una nuova richiesta da parte del <i>truck</i></li>
    </ol>
    Nel primo caso, il <i>WasteService</i> preleva immediatamente il messaggio dalla coda e transita allo stato <kc>backHome</kc>, in cui 
    invia al <i>transportTrolley</i> il messaggio <kc>gotohome</kc>. <br><br>
    
    Nel secondo caso il messaggio <kc>dropoutdone</kc> viene inserito in coda e non processato. Il <i>WasteService</i> conclude la 
    valutazione della richiesta e se questa viene rifiutata invia al <i>truck</i> il messaggio <kc>loadrejected</kc>, transita 
    allo stato <i>idle</i>, preleva dalla coda il messaggio <i>dropoutdone</i> e lo processa come nel caso precedente.
    In caso contrario, se la richiesta è accettata, il <i>WasteService</i> invia al <i>transportTrolley</i> il messaggio <kc>pickup</kc>, preleva dalla coda
    il messaggio <i>dropoutdone</i>, lo scarta e si mette in attessa della risposta <kc>pickupdone</kc>.
    
</div>

<div class="remark">
    <div id="ASAP" ><h3>Requirement: As soon as possible</h3></div>
    Dopo l'interazione con il committente abbiamo chiarito che il <i>truck</i> deve essere liberato il prima possibile. 
    Bisogna identificare quindi il momento migliore in cui il camion deve lasciare l'<kc>INDOOR</kc> e bisogna capire
    quale sia il modo migliore per mandarlo via.
    <h4>Leave the <kc>INDOOR</kc></h4>
    E' possibile liberare il <i>truck</i> in due momenti:
    <ul>
        <li>Non appena il <i>transportTrolley</i> preleva il carico</li>
        <li>Non appena il <i>transportTrolley</i> deposita il carico nel container</li>
    </ul>
    Sulla base di quanto detto dal committente, il momento migliore per liberare il <i>truck</i> è subito dopo la fine dell'operazione di <i>pickup</i>,
    ovvero quando il <i>WasteService</i> riceve il messaggio:
    <pre>
<key2>Reply</key2> pickupdone : pickupdone(_)</pre>

    <h4>How to send it away</h4>
    Anche in questo caso le soluzioni possibili sono due:
    <ul>
        <li>Utilizzare il messaggio <kc>loadaccept</kc> per mandare via il <i>truck</i></li>
        <li>Utilizzare un nuovo messaggio</li>
    </ul>
    La prima soluzione consiste nel ritardare l'invio del messaggio <i>loadaccept</i> fino a quando il <i>WasteService</i> non riceve il messaggio
    <i>pickupdone</i>. <br>
    La seconda soluzione, invece, prevede di inviare immediatamente il messaggio <i>loadaccept</i> e inviare un nuovo messaggio, non appena 
    il <i>WasteService</i> riceve il <i>pickupdone</i>, per mandare via il <i>truck</i>. <br>
    Sebbene le due soluzioni siano molto simili, la prima ci permette di risparmiare l'invio di un messaggio sulla rete diminuendo 
    quindi il carico di rete (<kc>overhead</kc>). Si consiglia pertanto agli sviluppatori di utilizzare tale soluzione. <br>
    Per meglio comprenderne il funzionamento di seguito viene riportato un frammento di codice del <i>WasteService</i>:
    <pre>
<key2>State</key2> acceptRequest{
    <key2>request</key2> transporttrolley <key2>-m</key2> pickup : pickup
}<key2>Transition</key2> t0 <key2>whenReply</key2> pickupdone -> dropout
                                                    
<key2>State</key2> dropout{
    <key2>replyTo</key2> storeWaste <key2>with</key2> loadaccept : loadaccept(_)
    <key2>request</key2> transporttrolley <key2>-m</key2> dropout : dropout(MATERIAL)
}<key2>Transition</key2> t0 <key2>whenReply</key2> dropoutdone -> idle                                         
}</pre>
    
</div>

<div class="remark">
    <h3>Architettura Logica</h3>
    Sulla base di quanto emerso in fase di analisi del problema è possibile ridefinire l'architettura logica della <kc>Business Core</kc> e 
    quindi quella dell'intero sistema.<br> 
    La nuova architettura logica è riportata di seguito: <br><br>
    <img src="./resources/img/ArchLogicSprint1.png" alt="" style="width:60% ; height:60% ;">
</div>

<h2>Project</h2>
<div class="remark">
    <h3>WasteService Component</h3>
</div>
<div class="remark">
    <h3>TransportTrolley Component</h3>
</div>
<div class="remark">
    <h3>ContainerManager Component</h3>
</div>

	      	
<br/><br/> 	

<div style="background-color:rgba(60, 131, 186, 0.9); width:50%;text-align:center;color:white; margin-left: 25%; border-radius: 25px;" >
    <br>
    By students: <br>
    Name: Annamaria Simonitto, Enrico Valastro, Alessio Reitano   
    <br>
    Email: annamaria.simonitto@studio.unibo.it, enrico.valastro@studio.unibo.it, alessio.reitano@studio.unibo.it
    <br><br>
    <img src="../../Sprint0/userDocs/resouces/images/AnnamariaSimonitto.jpg" alt="" width="8%" height="8%">
    <img src="../../Sprint0/userDocs/resouces/images/EnricoValastro.jpeg" alt="" width="8.5%" height="8.5%">
    <img src="../../Sprint0/userDocs/resouces/images/AlessioReitano.jpeg" alt="" width="10%" height="10%">
</div> 
</body>
</html>