<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    body
    {
        margin-left:  30px;
        margin-right: 30px;
    };
    
    P
    {
        font-family: Tahoma;
        font-size: 10pt;
    };
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }
    
    a:hover {
        background-color: #cccccc;
    }
    
    
    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }
    
    h1, h2, h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }
    
    top {
        width: 100%;
    }
    
    
    #i {
        color: #ff1010;
    }
    tt{
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }
    em{
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style:solid;
        border-color: #abe876;
        color: #1632cc;
    }
    bc{
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }
    ks{
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD	;
        font-size: 90%;
    }
    kc{
        font-family: "Arial";
        font-weight: bold;
        color: #008000	;
        font-size: 90%;
    }
    pre{
        font-family:monospace;
        font-weight: 500;
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }
    key{
        font-family:monospace;
        font-weight: 500;	
        color: #304ceb;
    }
    key2{
        font-family:monospace;
        font-weight: 500;
        color: #ad0d0f;
    }
    
    key3{
        font-family:monospace;
        font-weight: 500;
        color: #01b948;
    }
    
    key4{
        font-family:monospace;
        font-weight: 500;
    
        color: #008232;
    }
    
    pro{
        font-weight: bold;
        color:blue;
    }
    cons{
        font-weight: bold;
        color: red;
    }
    
    m{
        font-family: "Helvetica";
        line-height: 100%;
         font-size: 75%;
    }
    div.body{
         
        font-size: 18px;
    }
    k{
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }
    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }
    
    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }
    
    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }
    h3.test{
        background-color: #42b966;
        font-size: 100%;
    }
    h4 {
        background-color: #6dd4f4b5;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    h4.test{
        background-color: #5ee887;
        font-size: 100%;
    }
    h5 {
        background-color: #91df4d;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    div.req{
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }
    div.remark{
        background-color: #E3F2FD;
        border: 1.5px solid #E3F2FD;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    div.remarkTest{
        background-color: #d4fbd7;
        border: 1.5px solid #d4fbd7;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    
    ol, ul, li {
      margin: 0;
      margin-left: 10px;
      padding: 0;
      padding-bottom: 5px;
    }
    
    table, th, td {
        border: 1px solid black;
    }
    
    img {
        border: 1.5px solid #d5f2ed
    
    }
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }
    
    div.wrapdesc{
        width: 90%;
        margin: auto;
    }
    
    div.imagedesc{
        width: 85%;
        margin: auto;
    }
    </style>
    
<head>
    <meta charset="UTF-8">
    <title>Sprint3</title>
</head>
    
<body>
    <div id="top">
        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
    </div>  

    <div class="body"> 
        <a href="../../Sprint0/userDocs/sprint0.html">Sprint 0</a>
        <a href="../../Sprint1/userDocs/sprint1.html">Sprint 1</a>
        <a href="../../Sprint2/userDocs/sprint2.html">Sprint 2</a>
        <a href="./sprint3.html">Sprint 3</a>
        
        <h2>Introduction</h2>
        <div class="remark">
            Progetto finale di ISS finalizzato allo sviluppo software di un impianto di smistamento dei rifiuti attraverso un robot che preleva il carico del camion e lo porta al container appropriato
        </div>

        <h2>Requirements</h2>
        <div class="remark">
            <a href="../../Sprint0/userDocs/resouces/html/TemaFinale22.html">TemaFinale22</a>
        </div>

        <h2>Work Plan</h2>
        <div class="remark">
            In questo Sprint ci occuperemo dello sviluppo di <kc> Sonar</kc> e <kc>Led </kc>collocati sul RaspberryPI. <br>
            Il <i> Sonar </i> verrà usato come un 'alarm device', infatti alla presenza di un ostacolo rilevato dal Sonar, il transportTrolley si fermerà. Il valore entro cui il Sonar rileva
            l'ostacolo sarà un valore prefissato <kc> DLIMIT</kc>. <br>
            Il <i> Led</i> verrà usato per indicare lo stato del transportTrolley :
            <ul>
                <li>LED off quando il transportTrolley è in HOME</li>
                <li>LED blinks quando il transportTrolley è in movimento(pickup,dropout,gotoHome). <br>
                    (se il robot si trova in HOME ma si sta girando (magari per riposizionarsi dopo aver gestito una depositaction),
        il Led deve comunque lampeggiare(detto dal committente)). </li>
                <li>
                    LED on quando il transportTrolley è fermo/stopped.
                </li>
            
            </ul>
        </div>

        <h2>Checkpoint Sprint2</h2>
        <div class="remark">
            <h3>Sprint2 result</h3>
            Al termine dello <a href="../../Sprint2/userDocs/sprint2.html">Sprint2</a>, l'architettura logica del sistema è la seguente: <br></br>
            <img src="../../Sprint2/userDocs/resources/img/ArchLogicSprint2Final.png" alt="" style="width: 60%; height: 60%">
            <br>
        </div>

        <h2>Problem analysis</h2>
    
        <div class="remark">
            <h3>Led</h3>
            Dall'analisi dei requisiti, si evince che il <kc>Led</kc> è un componente fisico, connesso ad un <kc>RaspberryPI</kc>, che deve <i>Accendersi</i>, <i>Spegnersi</i> o <i>Lampeggiare</i> in funzione 
            dello stato del componente <kc>TransportTrolley</kc>. <br>
            Si aprono, quindi, diverse problematiche. In particolare, sarà necessario comprendere:
            <ul>
                <li>Come fa il <i>Led</i> ad accendersi, spegnersi o lampeggiare. </li>
                <li>Come fa il <i>Led</i> a sapere quando è il momento di eseguire una delle tre azioni.</li>
                <li>Come è possibile rappresentare e mantenere lo stato del <i>Led</i>.</li>
            </ul>
            
            <h4>Azioni del Led</h4>
            Per accendere e spegnere il <i>Led</i> collegato al <kc>RaspberryPI</kc>, è possibile utilizzare il software fornito dal committente. <br>
            In particolare ci sono stati forniti due file <ks>Bash</ks>, <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.raspIntro2022/code/bash/led25GpioTurnOn.sh">led25GpioTurnOn.sh</a> e <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.raspIntro2022/code/bash/led25GpioTurnOff.sh">led25GpioTurnOff.sh</a>. <br>
            Oltre a questi due file, che permettono di operare sul <i>Led</i> a livello fisico, il committente ci ha fornito anche la libreria generata dal software del progetto 
            <a href="https://github.com/anatali/issLab2022/tree/main/it.unibo.radarSystem22.domain">it.unibo.radarSystem22.domain</a>, che permette di 
            definire dei componenti di base legati ai dispositivi di I/O (<i>Led</i>, <i>Sonar</i>). <br>
            Il componente <i>Led</i> è descritto dalla seguente interfaccia.

            <pre>
<key>public interface</key> ILed {
    <key>public void</key> turnOn();
    <key>public void</key> turnOff();
    <key>public boolean</key> getState();
}</pre>
            <div id="ledModel">
                Il software fornito dal committente permette l'utilizzio di dispositivi simulati (<ks>Mock-object</ks>) e dispositivi reali. <br>
            </div>
            
            Per fare ciò viene introdotta una classe astratta, comune alle due tipologie, che funge da <ks>Factory</ks> per quel tipo di dispositivo. <br>
            La classe astratta <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/models/LedModel.java">LedModel.java</a> 
            introduce il metodo <i>astratto</i> <kc>LedActivate</kc> a cui è demandato il compito di accendere/spegnere il <i>Led</i>.
            <pre>
<key>public abstract class</key> LedModel <key>implements</key> ILed{
    <key>private boolean</key> state = false;
    
    <key>public static</key> ILed create() {
        ...
    }
    <key>public static</key> ILed createLedMock(){ <key>return new</key> LedMock(); }
    <key>public static</key> ILed createLedConcrete(){ <key>return new</key> LedConcrete(); }
    
    <key>protected abstract void</key> ledActivate( <key>boolean</key> val);
    
    <key>protected void</key> setState( <key>boolean</key> val ) {
        state = val;
        ledActivate( state );
    }
    @Override
    <key>public void</key> turnOn(){ setState( true ); }
    @Override
    <key>public void</key> turnOff() { setState( false ); }
    @Override
    <key>public boolean</key> getState(){  return state;  }
}</pre>

            Tale classe astratta è estesa dalle classi <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/mock/LedMock.java">LedMock.java</a> e <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/concrete/LedConcrete.java">LedConcrete.java</a> che implementano rispettivamente i dispositivi simulati e reali. <br>
            Il comportamento del <kc>LedMock</kc> è già definito dal <kc>LedModel</kc>, in quanto questo tiene traccia dello statto del <i>Led</i> in una variabile. <br>
            <pre>
<key>public class</key> LedMock <key>extends</key> LedModel <key>implements</key> ILed{
    @Override
    <key>protected void</key> ledActivate( <key>boolean</key> val) {
        ColorsOut.outappl("LedMock state=" + getState(), ColorsOut.MAGENTA );
    }
}</pre>
            Per quanto riguarda il <kc>LedConcrete</kc>, esso realizza la logica di gestione di un Led reale avvalendosi dei file <ks>Bash</ks> forniti dal committente. <br>
            <pre>
<key>public class</key> LedConcrete <key>extends</key> LedModel <key>implements</key> ILed{
    <key>private</key> Runtime rt  = Runtime.getRuntime();
    @Override
    <key>protected void</key> ledActivate(<key>boolean</key> val) {
        <key>try</key> {
            <key>if</key>( val ) rt.exec( "sudo bash led25GpioTurnOn.sh" );
            <key>else</key>      rt.exec( "sudo bash led25GpioTurnOff.sh" );
        } <key>catch</key> (IOException e) { ... }
    }
}</pre>
            Considerando che il software fornito dal committente è perfettamente funzionante, consigliamo agli sviluppatori di utilizzare tale software per la gestione del <i>Led</i>. 
            Tuttavia, dal momento che il componente <i>Led</i> deve essere in grado di interagire con gli altri componenti del sistema, consigliamo agli sviluppatori di modellare il <i>Led</i> 
            come un <ks>attore QAk</ks> che incapsula le funzionalità del software fornito dal committente. In questo modo si può dotare il <i>Led</i> dell'abilità di comunicare a scambio di messaggi. <br>



            <h4>Interazione tra i componenti</h4>
            Come detto in analisi dei requisiti il <i>Led</i> deve accendersi , spegnersi o brillare in base alle posizioni del <kc>TransportTrolley</kc>. 
            Quindi è logico che il <i>Led</i>, essendo un attuatore del sistema, debba essere controllato da qualcuno (<i>TransportTrolley</i>). <br>
            Sarà il <i>TransportTrolley</i>, in base alla sua posizione in quel momento, a dire al <i>Led</i> di cambiare stato.
            <pre>
<key2>Dispatch</key2> blink 	         : blink(_)
<key2>Dispatch</key2> turnon 	 : turnon(_)
<key2>Dispatch</key2> turnoff 	 : turnoff(_)
            </pre>
            
            <h4>Stato del Led</h4>
            Dall'analisi dei requisiti è emerso che il committente vuole che sia mostrato lo stato del Led nella <kc>GUI</kc>. Per fare ciò è necessario gestire e mantanere lo stato del Led. 
            Inoltre, dall'analisi dei requisiti è emerso che lo stato del Led può essere rappresentato dal seguente enumerativo:
            <pre>
<key>enum class</key> CurrStateLed{ <i>ON</i>, <i>OFF</i>, <i>BLINKING</i>}</pre>
            Lo stato può essere mantenuto in due modi differenti:
            <ul>
                <li>Cablare lo stato del Led all'interno del componente Led.</li>
                <li>Mantenere lo stato del Led usando una <ks>data class Kotlin</ks>.</li>
            </ul>
            <h5>Stato cablato</h5>
            Questa soluzione prevede di mantenere lo stato all'interno del file QAk del Led. <br>
            <pre>
<key2>QActor</key2> led <key2>context</key2> ctxpi{
    [#
        var ledState : CurrStateLed
    #]
}</pre>
            Sebbene questa soluzione sia semplice, da al componente Led la responsabilità di mantenere lo stato del Led e di aggiornare la <i>GUI</i>. 
            Inoltre affinchè la <i>GUI</i> possa mostrare lo stato del Led, è necessario che la GUI apra una connnesione Coap con il Led. <br>
            <h5>Data class</h5>
            Questa soluzione prevede di mantenere lo stato del Led in una <ks>data class Kotlin</ks>, togliendo in questo modo la responsabilità al Led.
            <pre>
<key>enum class</key> CurrStateLed { <i>ON</i>, <i>OFF</i>, <i>BLINKING</i> }
<key>data class</key> SystemState (
        <key>private var</key> currLedState : CurrStateLed
) {
    <key>fun</key> getCurrLedState() : CurrStateLed 
    <key>fun</key> setCurrLedState(currLedState : CurrStateLed)
}</pre>
            Sebbene questa soluzione sia più complessa da implementare, è quella che consigliamo agli sviluppatori in quanto permette di disaccoppiare la gestione dello stato dalle funzionalità del Led.
            <h4>Gestione dello stato del Led</h4>
            Il sistema deve essere consapevole dello stato del <i>Led</i>, per fare questo si potrebbe procedere in diversi modi: <br> <br>

            <ul>
                <li>Un Primo modo potrebbe essere che il <i>Led</i> quando cambia stato(ON,OFF,BLINK) invia un messaggio di notifica al <kc>SystemStateManager</kc>. <br>
                Questa soluzione sebbena sia semplice e non causi particolari problemi rende il <i>Led</i> consapevole del sistema che ha attorno e quindi sarebbe poco riusabile.</li>
                <li>Si potrebbe utilizzare il protocollo <kc>MQTT</kc>, il quale prevede che il <i>Led</i> sia il publisher di un canale <i>MQTT</i>. Ciò implica che dall'altro lato
                    qualcuno debba leggere questo stato (<i>SystemStateManager</i>). <br>
                    Una problematica che potrebbe insorgere usando questa opzione è che il <i>SystemStateManager</i> (che prima era solo un "contenitore" di stati) adesso dovrebbe registrarsi su un 
                    canale <i>MQTT</i> da cui riceverà lo stato del <i>Led</i>. <br>
                </li>
                <li>Infine un ultimo modo potrebbere essere che: essendo il <i>Led</i> un attuatore verrà comandato da qualcuno(<i>TransportTrolley</i>) per accendersi, spegnersi o brillare. Quindi il <kc>TransportTrolleCore</kc>
                    è a conoscenza implicitamente dello stato del <i>Led</i>, poichè se comunica al <i>Led</i> il messaggio turnOn, sa che lui si troverà nello stato ON.
                    Potrebbe quindi essere il <i>TransportTrolleyCore</i> ad aggiornare lo stato del <i>Led</i>. Quindi quando, ad esempio, il <i>TransportTrolleyCore</i> dice 
                    al <i>Led</i> turnOff , subito dopo manda un messaggio al <i>SystemStateManager</i> dicendogli update led (OFF) e così via. <br>
                    Questa soluzione è la più semplice da implementare e non causa particolari problemi. Consigliamo agli sviluppatori di usare quest'ultima <br>
                </li>
        </div>

        <div class="remark">
            <h3>Sonar</h3>
            Il <kc>Sonar</kc> è un dispositivo di input, esso può essere modellato come un "processo" che una volta attivato genera informazioni sugli ostacoli che rileva. <br>
            L'informazione generata dal <i>Sonar</i> è, sostanzialmente, una <i>distanza</i>. Il concetto di distanza è formalizzatto 
            dall'interfaccia <kc>IDistance</kc>:
            <pre>
<key>public interface</key> IDistance {
    <key>public int</key> getVal(   );
    <key>public</key> String toString(   );
}</pre>

            Tale interfaccia è implementata dalla classe <kc>Distance</kc>, che rappresenta quindi il concetto di distanza. <br>
            <pre>
<key>public class</key> Distance <key>implements</key> IDistance{
    <key>private int</key> v;
        <key>public</key> Distance(<key>int</key> d) { v=d;       }
        @Override
        <key>public int</key> getVal() { <key>return</key> v; }
        @Override
        <key>public</key> String toString(){ <key>return</key> ""+v; }
}</pre>

            Una volta compreso che tipo di dato viene generato dal <i>Sonar</i>, è necessario comprendere come faccia il <i>Sonar</i> a generare 
            tali dati, come questi dati possano essere fruibili ai componenti del sistema e come essi saranno utilizzati per soddisfare i requisiti del committente. <br>

            <h4>Materiale fornito dal committente</h4>
            Al fine di gestire i dati generati dal <i>Sonar</i> fisico e possibile utilizzare il software fornito dal committente. <br>
            In particolare, ci è stato fornito un software scritto in linguaggio <ks>C</ks>, <a href="./resources/C/SonarAlone.c">SonarAlone.c</a>, che stampa su standard output la distanza attualmente rilevata dal sonar. <br>
            Oltre a questo, il committente ci ha fornito la libreria generata dal software contenuto nel progetto 
            <a href="https://github.com/anatali/issLab2022/tree/main/it.unibo.radarSystem22.domain">it.unibo.radarSystem22.domain</a> che permette di definire dei componenti di base legati ai dispositivi di I/O (Led, Sonar). <br>
            Il componente <i>Sonar</i> è descritto dalla seguente interfaccia:

            <pre>
<key>public interface</key> ISonar {
    <key>public void</key> activate();
    <key>public void</key> deactivate();
    <key>public IDistance</key> getDistance();
    <key>public boolean</key> isActive();
}</pre>

            Anche in questo caso, come per il <a href="#ledModel">Led</a> è possibile utilizzare dispositivi simulati e dispositivi reali. <br>
            Per fare ciò viene introdotta la classe astratta <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/models/SonarModel.java">SonarModel.java</a>. <br>
            Il codice relativo alla produzione dei dati, viene incapsulato nel metodo <ks>abstract</ks> <ks>sonarProduce</ks> che dovrà 
            essere definito in modo diverso dal <kc>SonarMock</kc> e dal <kc>SonarConcrete</kc>, così come il metodo di inizializzazione <ks>sonarSetUps</ks>:

            <pre>
<key>protected abstract void</key> sonarSetUp() ;
<key>protected abstract void</key> sonarProduce( );</pre>
            
            La classe astratta <kc>SonarModel</kc> fornisce anche i metodi per attivare e deattivare il sonar:

            <pre>
@Override
<key>public void</key> deactivate() { stopped = <key>true</key>; }</pre>

            <pre>
@Override
<key>public void</key> activate() {
  stopped = <key>false</key>;
  <key>new</key> Thread() {
    <key>public void</key> run() {
      <key>while</key>( ! stopped  ) { sonarProduce(); }
    }
  }.start();
}</pre>

            I dati prodotti dal <i>Sonar</i> possono essere consumati a livello applicativo, utilizzando il metodo <ks>getDistance</ks> offerto 
            dalla classe astratta <kc>SonarModel.java</kc>:

            <pre>
@Override
<key>public</key> IDistance getDistance() {
    <key>return</key> curVal; 
}</pre>

            Le classi <kc>SonarMock</kc> e <kc>SonarConcrete</kc> implementano i metodi <ks>sonarSetUp</ks> e <ks>sonarProduce</ks> di <kc>SonarModel.java</kc>. <br>
            In particolare, il <i>SonarMock</i> genera valori di distanza da "90" a "0" e se la variabile di configurazione <kc>testing</kc> è attiva genera un solo valore che legge dal file di configurazione:
             <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/mock/SonarMock.java">SonarMock.java</a>
            <br>
            La classe <i>SonarConcrete</i> realizza la logica di gestione del sonar fisico, avvalendosi del software <i>SonarAlone.c</i> fornito dal committente: <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/concrete/SonarConcrete.java">SonarConcrete.java</a>
            <br>
            Dal momento che il <i>Sonar</i> deve essere in grado di comunicare i dati generati al resto del sistema, esso dovrebbe essere 
            capace di lavora a scambio di messaggi. Per questo motivo il <i>Sonar</i> dovrebbe essere modellato e implementato come un attore QAk. <br>
            Sarà quindi necessario incapsulare all'interno di un attore QAk il componente <i>ISonar</i>. Inoltre, l'attore QAk del <i>Sonar</i>, così costruito 
            dovrà fare "polling" dei dati generati dal <i>ISonar</i>. <br>
            <br>
            Oltre a quanto detto fin'ora, il committente ci ha fornito anche un software che implementa un attore QAk per il sonar. Tale software, 
            consultabile in <a href="https://github.com/anatali/issLab2022/tree/main/unibo.sonarqak22">unibo.sonarqak22</a>, permette di creare una <ks>pipe</ks>
            come quella mostrata in figura: <br>
            <img src="./resources/img/pipe.png" alt="" style="width: 45%; height: 45%;">
            <br><br>
            I dati generati da <i>firstActorInPipe</i> (un sonarsimulator come sonarDataGen) sono memorizzati dal <i>datalogger</i>, filtrati dal <i>datacleaner</i> e gestiti dal <i>distancefilter</i>.
            In <i>unibo.sonarqak22</i> è possibile trovare anche il codice dei <ks>CodedQActor</ks> <kc>sonarsimulator</kc> e <kc>sonardatasource</kc> che sono rispettivamente implementati nelle classi 
            <a href="https://github.com/anatali/issLab2022/blob/main/unibo.sonarqak22/resources/sonarHCSR04Support2021.kt">sonarHCSR04Support2021.kt</a> e <a href="https://github.com/anatali/issLab2022/blob/main/unibo.sonarqak22/resources/sonarSimulator.kt">sonarSimulator.kt</a>
            <br><br>
            Per implementare il <i>Sonar</i> consigliamo agli sviluppatori di utilizzare il software <i>unibo.sonarqak22</i> in modo da abbattere i tempi di sviluppo. <br>

        </div>
        

        <div class="remark">
            <h3>Architettura Logica</h3>
            Sulla base di quanto emerso in fase di analisi del problema è possibile ridefinire l'architettura logica del sistema.<br> 
            <br><br>
            <img src="" alt="" style="width:60% ; height:60% ;">
        </div>
        <h2>Project</h2>
        <div class="remark">
            <h3>Led</h3>
            Come consigliato dagli analisti useremo il software fornito dal committente per la gestione del <i>Led</i>. <br>
            Dal momento però che il componente <i>Led</i> deve essere in grado di interagire con gli altri componenti del sistema, 
            gli analisti ci hanno consigliato di modellare il <i>Led</i> come un attore QAk che incapsula le funzionalità del software fornito dal committente. In questo modo si può dotare il <i>Led</i> dell'abilità di comunicare a scambio di messaggi. <br>
        <h4>Led Component</h4>
        Come detto in fase di analisi del problema sarà il <i>TransportTrolley</i> a dire al <i>Led</i> quando fare il cambiamento di stato. Questo avviene attraverso l'invio di messaggi al <i>Led</i>. <br>
            <pre>
<key2>State</key2> pickupMove{
        ...
     <key2>forward</key2> led <key2>-m</key2> blink : blink(_)
        ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> pickupExec{
    ...
 <key2>forward</key2> led <key2>-m</key2> turnon : turnon(_)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> dropoutMove{
    ...
 <key2>forward</key2> led <key2>-m</key2> blink : blink(_)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> dropoutExec{
    ...
 <key2>forward</key2> led <key2>-m</key2> turnon : turnon(_)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> backHome{
    ...
 <key2>forward</key2> led <key2>-m</key2> blink : blink(_)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> backHomeRes{
    <key2>forward</key2> led <key2>-m</key2> turnoff : turnoff(_)
    ...

}<key2>Goto</key2> idle
            </pre>
        
        Per quanto riguarda lo stato del <i>Led</i>, come consigliato dagli analisti, abbiamo deciso di mantenere lo stato del <i>Led</i> 
        in una <ks>data class Kotlin</ks>, permettendo così di disaccoppiare la gestione dello stato dalle funzionalità del <i>Led</i>. <br>

        Per quanto riguarda la gestione dello stato del Led, come consigliato dagli analisti, abbiamo sviluppato il progetto in modo tale che , quando
        il TransportTrolleCore dice al Led di (spegnersi, accendersi, brillare) , subito dopo manda un messaggio al SystemStateManager dicendogli update led (STATE). <br>
        In questo modo il sistema tiene traccia dello stato del Led, infatti successivamente, come detto nello Sprint2, sarà il SystemStateManager a comunicare con la <i>GUI</i>,
        dove vedremo lo stato del Led. <br>
        <pre>
<key2>State</key2> pickupMove{
        ...
     <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(BLINKING)
        ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> pickupExec{
    ...
 <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(ON)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> dropoutMove{
    ...
 <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(BLINKING)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> dropoutExec{
    ...
 <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(ON)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> backHome{
    ...
 <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(BLINKING)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> backHomeRes{
    <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(OFF)
    ...

}<key2>Goto</key2> idle
            </pre>

            Il codice completo è consultabile nel file <a href="./resources/qak/wasteService.qak">wasteService.qak</a>. <br>
       
            </div>
            <div class="remark">
                <h3>Sonar</h3>
                </div>
 
        <h2>Test Plan</h2>
        <div class="remarkTest"></div>

        <h2>Architettura finale del Sistema</h2>
        <div class="remark"></div>

        <div style="display: flex; flex-direction: row; justify-content: space-around;">
            <div><a href="../../Sprint2/userDocs/sprint2.html"> <-- Sprint2</a></div>
        </div>
        <br><br>
        <div style="background-color:rgba(60, 131, 186, 0.9); width:50%;text-align:center;color:white; margin-left: 25%; border-radius: 25px;" >
            <br>
            By students: <br>
            Name: Annamaria Simonitto, Enrico Valastro, Alessio Reitano   
            <br>
            Email: annamaria.simonitto@studio.unibo.it, enrico.valastro@studio.unibo.it, alessio.reitano@studio.unibo.it
            <br><br>
            <img src="../../Sprint0/userDocs/resouces/images/AnnamariaSimonitto.jpg" alt="" width="8%" height="8%">
            <img src="../../Sprint0/userDocs/resouces/images/EnricoValastro.jpeg" alt="" width="8.5%" height="8.5%">
            <img src="../../Sprint0/userDocs/resouces/images/AlessioReitano.jpeg" alt="" width="10%" height="10%">
        </div> 
    </div>
</body>
</html>