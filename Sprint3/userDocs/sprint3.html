<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    body
    {
        margin-left:  30px;
        margin-right: 30px;
    };
    
    P
    {
        font-family: Tahoma;
        font-size: 10pt;
    };
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }
    
    a:hover {
        background-color: #cccccc;
    }
    
    
    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }
    
    h1, h2, h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }
    
    top {
        width: 100%;
    }
    
    
    #i {
        color: #ff1010;
    }
    tt{
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }
    em{
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style:solid;
        border-color: #abe876;
        color: #1632cc;
    }
    bc{
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }
    ks{
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD	;
        font-size: 90%;
    }
    kc{
        font-family: "Arial";
        font-weight: bold;
        color: #008000	;
        font-size: 90%;
    }
    pre{
        font-family:monospace;
        font-weight: 500;
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }
    key{
        font-family:monospace;
        font-weight: 500;	
        color: #304ceb;
    }
    key2{
        font-family:monospace;
        font-weight: 500;
        color: #ad0d0f;
    }
    
    key3{
        font-family:monospace;
        font-weight: 500;
        color: #01b948;
    }
    
    key4{
        font-family:monospace;
        font-weight: 500;
    
        color: #008232;
    }
    
    pro{
        font-weight: bold;
        color:blue;
    }
    cons{
        font-weight: bold;
        color: red;
    }
    
    m{
        font-family: "Helvetica";
        line-height: 100%;
         font-size: 75%;
    }
    div.body{
         
        font-size: 18px;
    }
    k{
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }
    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }
    
    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }
    
    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }
    h3.test{
        background-color: #42b966;
        font-size: 100%;
    }
    h4 {
        background-color: #6dd4f4b5;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    h4.test{
        background-color: #5ee887;
        font-size: 100%;
    }
    h5 {
        background-color: #91df4d;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    div.req{
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }
    div.remark{
        background-color: #E3F2FD;
        border: 1.5px solid #E3F2FD;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    div.remarkTest{
        background-color: #d4fbd7;
        border: 1.5px solid #d4fbd7;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    
    ol, ul, li {
      margin: 0;
      margin-left: 10px;
      padding: 0;
      padding-bottom: 5px;
    }
    
    table, th, td {
        border: 1px solid black;
    }
    
    img {
        border: 1.5px solid #d5f2ed
    
    }
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }
    
    div.wrapdesc{
        width: 90%;
        margin: auto;
    }
    
    div.imagedesc{
        width: 85%;
        margin: auto;
    }
    </style>
    
<head>
    <meta charset="UTF-8">
    <title>Sprint3</title>
</head>
    
<body>
    <div id="top">
        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
    </div>  

    <div class="body"> 
        <a href="../../Sprint0/userDocs/sprint0.html">Sprint 0</a>
        <a href="../../Sprint1/userDocs/sprint1.html">Sprint 1</a>
        <a href="../../Sprint2/userDocs/sprint2.html">Sprint 2</a>
        <a href="./sprint3.html">Sprint 3</a>
        
        <h2>Introduction</h2>
        <div class="remark">
            Progetto finale di ISS finalizzato allo sviluppo software di un impianto di smistamento dei rifiuti attraverso un robot che preleva il carico del camion e lo porta al container appropriato
        </div>

        <h2>Requirements</h2>
        <div class="remark">
            <a href="../../Sprint0/userDocs/resouces/html/TemaFinale22.html">TemaFinale22</a>
        </div>

        <h2>Work Plan</h2>
        <div class="remark">
            In questo Sprint ci occuperemo dello sviluppo di <kc> Sonar</kc> e <kc>Led </kc>collocati sul RaspberryPI. <br>
            Il <i> Sonar </i> verrà usato come un 'alarm device', infatti alla presenza di un ostacolo rilevato dal Sonar, il transportTrolley si fermerà. Il valore entro cui il Sonar rileva
            l'ostacolo sarà un valore prefissato <kc> DLIMIT</kc>. <br>
            Il <i> Led</i> verrà usato per indicare lo stato del transportTrolley :
            <ul>
                <li>LED off quando il transportTrolley è in HOME</li>
                <li>LED blinks quando il transportTrolley è in movimento(pickup,dropout,gotoHome). <br>
                    (se il robot si trova in HOME ma si sta girando (magari per riposizionarsi dopo aver gestito una depositaction),
        il Led deve comunque lampeggiare(detto dal committente)). </li>
                <li>
                    LED on quando il transportTrolley è fermo/stopped.
                </li>
            
            </ul>
        </div>

        <h2>Checkpoint Sprint2</h2>
        <div class="remark">
            <h3>Sprint2 result</h3>
            Al termine dello <a href="../../Sprint2/userDocs/sprint2.html">Sprint2</a>, l'architettura logica del sistema è la seguente: <br></br>
            <img src="../../Sprint2/userDocs/resources/img/ArchLogicSprint2Final.png" alt="" style="width: 60%; height: 60%">
            <br>
        </div>

        <h2>Problem analysis</h2>
    
        <div class="remark">
            <h3>Led</h3>
            Dall'analisi dei requisiti, si evince che il <kc>Led</kc> è un componente fisico, connesso ad un <kc>RaspberryPI</kc>, che deve <i>Accendersi</i>, <i>Spegnersi</i> o <i>Lampeggiare</i> in funzione 
            dello stato del componente <kc>TransportTrolley</kc>. <br>
            Si aprono, quindi, diverse problematiche. In particolare, sarà necessario comprendere:
            <ul>
                <li>Come fa il <i>Led</i> ad accendersi, spegnersi o lampeggiare. </li>
                <li>Come fa il <i>Led</i> a sapere quando è il momento di eseguire una delle tre azioni.</li>
                <li>Come è possibile rappresentare, mantenere e gestire lo stato del <i>Led</i>.</li>
            </ul>
            
            <h4>Azioni del Led</h4>
            Per accendere e spegnere il <i>Led</i> collegato al <kc>RaspberryPI</kc>, è possibile utilizzare il software fornito dal committente. <br>
            In particolare ci sono stati forniti due file <ks>Bash</ks>, <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.raspIntro2022/code/bash/led25GpioTurnOn.sh">led25GpioTurnOn.sh</a> e <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.raspIntro2022/code/bash/led25GpioTurnOff.sh">led25GpioTurnOff.sh</a>. <br>
            Oltre a questi due file, che permettono di operare sul <i>Led</i> a livello fisico, il committente ci ha fornito anche la libreria generata dal software del progetto 
            <a href="https://github.com/anatali/issLab2022/tree/main/it.unibo.radarSystem22.domain">it.unibo.radarSystem22.domain</a>, che permette di 
            definire dei componenti di base legati ai dispositivi di I/O (<i>Led</i>, <i>Sonar</i>). <br>
            Il componente <i>Led</i> è descritto dalla seguente interfaccia.

            <pre>
<key>public interface</key> ILed {
    <key>public void</key> turnOn();
    <key>public void</key> turnOff();
    <key>public boolean</key> getState();
}</pre>
            <div id="ledModel">
                Il software fornito dal committente permette l'utilizzio di dispositivi simulati (<ks>Mock-object</ks>) e dispositivi reali. <br>
            </div>
            
            Per fare ciò viene introdotta una classe astratta, comune alle due tipologie, che funge da <ks>Factory</ks> per quel tipo di dispositivo. <br>
            La classe astratta <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/models/LedModel.java">LedModel.java</a> 
            introduce il metodo <i>astratto</i> <kc>LedActivate</kc> a cui è demandato il compito di accendere/spegnere il <i>Led</i>.
            <pre>
<key>public abstract class</key> LedModel <key>implements</key> ILed{
    <key>private boolean</key> state = false;
    
    <key>public static</key> ILed create() {
        ...
    }
    <key>public static</key> ILed createLedMock(){ <key>return new</key> LedMock(); }
    <key>public static</key> ILed createLedConcrete(){ <key>return new</key> LedConcrete(); }
    
    <key>protected abstract void</key> ledActivate( <key>boolean</key> val);
    
    <key>protected void</key> setState( <key>boolean</key> val ) {
        state = val;
        ledActivate( state );
    }
    @Override
    <key>public void</key> turnOn(){ setState( true ); }
    @Override
    <key>public void</key> turnOff() { setState( false ); }
    @Override
    <key>public boolean</key> getState(){  return state;  }
}</pre>

            Tale classe astratta è estesa dalle classi <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/mock/LedMock.java">LedMock.java</a> e <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/concrete/LedConcrete.java">LedConcrete.java</a> che implementano rispettivamente i dispositivi simulati e reali. <br>
            Il comportamento del <kc>LedMock</kc> è già definito dal <kc>LedModel</kc>, in quanto questo tiene traccia dello statto del <i>Led</i> in una variabile. <br>
            <pre>
<key>public class</key> LedMock <key>extends</key> LedModel <key>implements</key> ILed{
    @Override
    <key>protected void</key> ledActivate( <key>boolean</key> val) {
        ColorsOut.outappl("LedMock state=" + getState(), ColorsOut.MAGENTA );
    }
}</pre>
            Per quanto riguarda il <kc>LedConcrete</kc>, esso realizza la logica di gestione di un Led reale avvalendosi dei file <ks>Bash</ks> forniti dal committente. <br>
            <pre>
<key>public class</key> LedConcrete <key>extends</key> LedModel <key>implements</key> ILed{
    <key>private</key> Runtime rt  = Runtime.getRuntime();
    @Override
    <key>protected void</key> ledActivate(<key>boolean</key> val) {
        <key>try</key> {
            <key>if</key>( val ) rt.exec( "sudo bash led25GpioTurnOn.sh" );
            <key>else</key>      rt.exec( "sudo bash led25GpioTurnOff.sh" );
        } <key>catch</key> (IOException e) { ... }
    }
}</pre>
            Considerando che il software fornito dal committente è perfettamente funzionante, consigliamo agli sviluppatori di utilizzare tale software per la gestione del <i>Led</i>. 
            Tuttavia, dal momento che il componente <i>Led</i> deve essere in grado di interagire con gli altri componenti del sistema, consigliamo agli sviluppatori di modellare il <i>Led</i> 
            come un <ks>attore QAk</ks> che incapsula le funzionalità del software fornito dal committente. In questo modo si può dotare il <i>Led</i> dell'abilità di comunicare a scambio di messaggi. <br>



            <h4>Interazione tra i componenti</h4>
            Come detto in analisi dei requisiti il <i>Led</i> deve accendersi , spegnersi o lampeggiare in base alle posizioni del <kc>TransportTrolley</kc>. 
            Poiché il <i>Led</i> è progettato per essere un attuatore risulta evidente che esso debba essere controllato da qualche componente del sistema. <br>
            Dal momento che lo stato del <i>Led</i> è funzione dello stato del <i>TransportTrolley</i>, risulta logico pensare che sia proprio il <i>TransportTrolley</i> a controllare il <i>Led</i>. 
            In alternativa, si potrebbe pensare di dare la responsabilità di comandare il <i>Led</i> al <kc>SystemStateManager</kc>, dal momonte che questo componente 
            è a conoscenza dello stato del led. Tuttavia, tale soluzione denaturalizzerebbe il componente <i>SystemStateManager</i>, poichè esso è stato 
            pensato con il solo ed unico scopo di mantenere lo stato del sistema. <br>
            Per tale motivo, si consiglia agli sviluppatori di seguire la strada in cui il <i>TransportTrolley</i> controlla il <i>Led</i>, per fare ciò 
            definiamo i messaggi che il <i>TransportTrolley</i> invierà al <i>Led</i>: <br>
            <pre>
<key2>Dispatch</key2> blink   : blink(_)
<key2>Dispatch</key2> turnon  : turnon(_)
<key2>Dispatch</key2> turnoff : turnoff(_)</pre>
            
            <h4>Stato del Led</h4>
            Dall'analisi dei requisiti è emerso che il committente vuole che sia mostrato lo stato del Led nella <kc>GUI</kc>. Per fare ciò è necessario gestire e mantanere lo stato del Led. 
            Basandosi, sempre, sull'analisi dei requisiti è possibili affermare che lo stato del Led può essere rappresentato dal seguente enumerativo:
            <pre>
<key>enum class</key> CurrStateLed{ <i>ON</i>, <i>OFF</i>, <i>BLINKING</i>}</pre>
            Bisogna quindi comprendere come si possa mantenere lo stato, le soluzioni attuabili sono diverse:
            <ul>
                <li>Cablare lo stato del Led all'interno del componente Led.</li>
                <li>Mantenere lo stato del Led usando una <ks>data class Kotlin</ks>.</li>
            </ul>
            <h5>Stato cablato</h5>
            Questa soluzione prevede di mantenere lo stato all'interno del file QAk del Led. <br> 
            <pre>
<key2>QActor</key2> led <key2>context</key2> ctxpi{
    [#
        var ledState : CurrStateLed
    #]
}</pre>
            Sebbene questa soluzione sia semplice, da al componente la responsabilità di mantenere lo stato del Led e di comunicare a tutti 
            i componenti interessati allo stato del <i>Led</i> il cambiamenti di stato. <br>
            <h5>Data class</h5>
            Questa soluzione prevede di mantenere lo stato del Led in una <ks>data class Kotlin</ks>, togliendo in questo modo la responsabilità al Led.
            <pre>
<key>enum class</key> CurrStateLed { <i>ON</i>, <i>OFF</i>, <i>BLINKING</i> }
<key>data class</key> SystemState (
        <key>private var</key> currLedState : CurrStateLed
) {
    <key>fun</key> getCurrLedState() : CurrStateLed 
    <key>fun</key> setCurrLedState(currLedState : CurrStateLed)
}</pre>
            Sebbene questa soluzione sia più complessa da implementare, è quella che consigliamo agli sviluppatori in quanto permette di disaccoppiare la gestione dello stato dalle funzionalità del Led.
            <h4>Gestione dello stato del Led</h4>
            La gestione dello stato del Led è la problematica più delicata da affrontare. <br>

            <h5>Led State Manager</h5>
            Innanzi tutto, è necessario comprendere quale sia il componente incaricato della gestione dello stato del <i>Led</i>. 
            Anche in questo caso le soluzioni possibili sono molteplici, ma le più sensate sono le seguenti:
            <ul>
                <li>Il componente <i>SystemStateManager</i> è incaricato della gestione dello stato del <i>Led</i>.</li>
                <li>Il componente <i>Led</i> è incaricato della gestione dello stato del <i>Led</i>.</li>
            </ul>

            Per rimanere in linea con quanto fatto per lo stato del <i>TransportTrolley</i> e della <i>Service Area</i> consigliamo agli sviluppatori 
            di fare in modo che sia il <i>SystemStateManager</i> a mantenere lo stato del <i>Led</i>. <br>
            
            <h5>Comunicazione</h5>
            Bisogna capire come fare in modo che il <i>SystemStateManager</i> sia a conoscenza dello stato del <i>Led</i>. Si può agire in diversi modi: <br>
            <ul>
                <li>
                    <b>Primo approccio</b>: Questa soluzione prevede che sia il <i>Led</i> a comunicare, tramite un messaggio, ogni cambiamento di stato al <i>SystemStateManager</i>.
                    Questa soluzione, sebbene sia semplice e non causi particolari problemi, rende il <i>Led</i> consapevole del sistema che ha attorno e quindi poco riutilizzabile.
                </li>
                <li>
                    <b>Secondo approccio</b>: Si potrebbe utilizzare il protocollo <kc>MQTT</kc>, che permette di implementare uno scambio di messaggi con architettura 
                    <kc>publish-subscribe</kc>. La soluzione, prevede che il <i>Led</i> sia il publisher di un canale <i>MQTT</i>. e il <i>SystemStateManager</i> un subscriber che riceve 
                    i messaggi di cambiamento di stato.<br>
                </li>
                <li>
                    <b>Terzo approccio</b>: Questa soluzione prevede di sfruttare la <kc>CoAP osservabilità</kc> degli attori QAk. In particolare, si 
                    potrebbe pensare di rendere il <i>SystemStateManager</i> un osservatore del <i>Led</i>. Tuttavia, questa soluzione implica la necessità 
                    di instaurare un'ulteriore connessione <i>CoAP</i> nel sistema. <br>
                </li>
                <li>
                    <b>Quarto approccio</b>: Dal momento che il <i>TransportTrolley</i> comanda il <i>Led</i> affinche questo si accenda/spenga e lampeggi, è possibile 
                    affermare che il <i>TransportTrolley</i> sia implicitamente conscio dello stato del <i>Led</i>. Questa soluzione prevede, semplicemente, 
                    che sia il <i>TransportTrolley</i> a comunicare lo stato del <i>Led</i> al <i>SystemStateManager</i>. Per fare ciò potrebbe avvalersi del seguente messaggio:
                    <pre>
<key2>Dispatch</key2> updateled : updateled(STAT)</pre>
                </li>
            </ul>
            In conclusione, consigliamo agli sviluppatori di utilizzare il <b>quarto approccio</b> per la comunicazione dello stato del <i>Led</i> al <i>SystemStateManager</i>.
            In quanto questo permettere di mantenere il <i>Led</i> estraneo al sistema e quindi facilmente riutilizzabile, nonché di evitare ulteriori connessioni <i>CoAP</i> nel sistema e 
            la creazione di un canale <i>MQTT</i>.
        </div>

        <div class="remark">
            <h3>Sonar</h3>
            Il <kc>Sonar</kc> è un dispositivo di input, esso può essere modellato come un "processo" che una volta attivato genera informazioni sugli ostacoli che rileva. <br>
            L'informazione generata dal <i>Sonar</i> è, sostanzialmente, una <i>distanza</i>. Il concetto di distanza è formalizzatto 
            dall'interfaccia <kc>IDistance</kc>:
            <pre>
<key>public interface</key> IDistance {
    <key>public int</key> getVal(   );
    <key>public</key> String toString(   );
}</pre>

            Tale interfaccia è implementata dalla classe <kc>Distance</kc>, che rappresenta quindi il concetto di distanza. <br>
            <pre>
<key>public class</key> Distance <key>implements</key> IDistance{
    <key>private int</key> v;
        <key>public</key> Distance(<key>int</key> d) { v=d;       }
        @Override
        <key>public int</key> getVal() { <key>return</key> v; }
        @Override
        <key>public</key> String toString(){ <key>return</key> ""+v; }
}</pre>

            Una volta compreso che tipo di dato viene generato dal <i>Sonar</i>, è necessario comprendere come faccia il <i>Sonar</i> di livello applicativo a generare 
            tali dati, come questi dati possano essere fruibili ai componenti del sistema e come essi saranno utilizzati per soddisfare i requisiti del committente. <br>

            <h4>Materiale fornito dal committente</h4>
            Al fine di gestire i dati generati dal <i>Sonar</i> fisico e possibile utilizzare il software fornito dal committente. <br>
            In particolare, ci è stato fornito un software scritto in linguaggio <ks>C</ks>, <a href="./resources/C/SonarAlone.c">SonarAlone.c</a>, che stampa su standard output la distanza attualmente rilevata dal sonar. <br>
            Oltre a questo, il committente ci ha fornito la libreria generata dal software contenuto nel progetto 
            <a href="https://github.com/anatali/issLab2022/tree/main/it.unibo.radarSystem22.domain">it.unibo.radarSystem22.domain</a> che permette di definire dei componenti di base legati ai dispositivi di I/O (Led, Sonar). <br>
            Il componente <i>Sonar</i> è descritto dalla seguente interfaccia:

            <pre>
<key>public interface</key> ISonar {
    <key>public void</key> activate();
    <key>public void</key> deactivate();
    <key>public IDistance</key> getDistance();
    <key>public boolean</key> isActive();
}</pre>

            Anche in questo caso, come per il <a href="#ledModel">Led</a> è possibile utilizzare dispositivi simulati e dispositivi reali. <br>
            Per fare ciò viene introdotta la classe astratta <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/models/SonarModel.java">SonarModel.java</a>. <br>
            Il codice relativo alla produzione dei dati, viene incapsulato nel metodo <ks>abstract</ks> <ks>sonarProduce</ks> che dovrà 
            essere definito in modo diverso dal <kc>SonarMock</kc> e dal <kc>SonarConcrete</kc>, così come il metodo di inizializzazione <ks>sonarSetUps</ks>:

            <pre>
<key>protected abstract void</key> sonarSetUp() ;
<key>protected abstract void</key> sonarProduce( );</pre>
            
            La classe astratta <kc>SonarModel</kc> fornisce anche i metodi per attivare e deattivare il sonar:

            <pre>
@Override
<key>public void</key> deactivate() { stopped = <key>true</key>; }</pre>

            <pre>
@Override
<key>public void</key> activate() {
  stopped = <key>false</key>;
  <key>new</key> Thread() {
    <key>public void</key> run() {
      <key>while</key>( ! stopped  ) { sonarProduce(); }
    }
  }.start();
}</pre>

            I dati prodotti dal <i>Sonar</i> possono essere consumati a livello applicativo, utilizzando il metodo <ks>getDistance</ks> offerto 
            dalla classe astratta <kc>SonarModel.java</kc>:

            <pre>
@Override
<key>public</key> IDistance getDistance() {
    <key>return</key> curVal; 
}</pre>

            Le classi <kc>SonarMock</kc> e <kc>SonarConcrete</kc> implementano i metodi <ks>sonarSetUp</ks> e <ks>sonarProduce</ks> di <kc>SonarModel.java</kc>. <br>
            In particolare, il <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/mock/SonarMock.java">SonarMock.java</a> 
            genera valori di distanza da "90" a "0" e se la variabile di configurazione <kc>testing</kc> è attiva genera un solo valore che legge dal file di configurazione. 
            <br>
            <br>
            La classe <i>SonarConcrete</i> realizza la logica di gestione del sonar fisico, avvalendosi del software <i>SonarAlone.c</i> fornito dal committente: <a href="https://github.com/anatali/issLab2022/blob/main/it.unibo.radarSystem22.domain/src/it/unibo/radarSystem22/domain/concrete/SonarConcrete.java">SonarConcrete.java</a>
            <br><br>
            Dal momento che il <i>Sonar</i> deve essere in grado di comunicare i dati generati al resto del sistema, esso dovrebbe essere 
            capace di lavora a scambio di messaggi. Per questo motivo il <i>Sonar</i> dovrebbe essere modellato e implementato come un attore QAk. <br>
            Sarà quindi necessario incapsulare all'interno di un attore QAk il componente <i>ISonar</i>. Inoltre, l'attore QAk del <i>Sonar</i>, così costruito 
            dovrà fare "polling" dei dati generati dal <i>ISonar</i>. <br>
            <br>
            Oltre a quanto detto fin'ora, il committente ci ha fornito anche un software che implementa un attore QAk per il sonar. Tale software, 
            consultabile in <a href="https://github.com/anatali/issLab2022/tree/main/unibo.sonarqak22">unibo.sonarqak22</a>, permette di creare una <ks>pipe</ks>
            come quella mostrata in figura: <br>
            <img src="./resources/img/pipe.png" alt="" style="width: 45%; height: 45%;">
            <br><br>
            I dati generati da <i>firstActorInPipe</i> (un sonarsimulator come sonarDataGen) sono memorizzati dal <i>datalogger</i>, filtrati dal <i>datacleaner</i> e gestiti dal <i>distancefilter</i>.
            In <i>unibo.sonarqak22</i> è possibile trovare anche il codice dei <ks>CodedQActor</ks> <kc>sonarsimulator</kc> e <kc>sonardatasource</kc> che sono rispettivamente implementati nelle classi 
            <a href="https://github.com/anatali/issLab2022/blob/main/unibo.sonarqak22/resources/sonarHCSR04Support2021.kt">sonarHCSR04Support2021.kt</a> e <a href="https://github.com/anatali/issLab2022/blob/main/unibo.sonarqak22/resources/sonarSimulator.kt">sonarSimulator.kt</a>
            <br><br>
            
            Sebbene il software fornito dal committente in <i>unibo.sonarqak22</i> sia perfettamente funzionante, il <kc>CodedQActor</kc> 
            <i>sonarHCSR04Support2021</i> utilizza il software <i>sonarAlone.c</i> per elaborare i dati generati dal sonar fisico. Questo 
            rende il <i>sonarqak22</i> dipendente dal specifico <i>sonar</i> fisico (HCSR04) e quindi non riutilizzabile con altri tipi di sonar.
            A tal proposito, riteniamo che sia opportuno fare in modo che il software di più alto livello, il <i>sonarqak22</i>, sia il piu possibile 
            indipendente dal livello fisico, in modo da poter essere riutilizzato anche con tipologie differenti di sonar. <br>
            Per questo motivo, pensiamo che sia meglio lasciare la dipendenza dal <i>sonarAlone.c</i> e quindi dallo specifico sonar fisico, ad un <kc>layer</kc> 
            di livello piu basso. <br>
            Per tanto, consigliamo agli sviluppatori di progettare e sviluppare ex-novo un sonar QAk, servendosi, magari, della 
            libreria <i>radarSystem22.domain</i> e lasciando a quest'ultima la dipendenza dal livello fisico.

            <h4>Lettura dei dati prodotti dal sonar</h4>
            Una volta compreso come faccia il sonar di livello applicativo a produrre dati, bisogna comprendere come si possa fare per 
            rendere tali dati fruibili al resto del sistema. <br>
            Questo aspetto dipende da come si sceglie di implementare il sonar a livello applicativo, in particolare:
            
            <h5>Sonarqak22 fornito dal committente</h5>
            In questo caso i dati generati dal <i>SonarAlone.c</i> sono letti direttamente dal <kc>CodedQActor</kc> <i>sonarHCSR04Support2021</i> e 
            immessi nel sistema tramite <kc>Eventi</kc>. In particolare il <i>sonarHCSR04Support2021</i> emette un evento "d'ambiente"(<kc>emitLocalStreamEvent</kc>) 
            che viene raccolto dal secondo attore nella pipe il <i>dataCleaner</i> che a sua volta propaga l'evento e così via fino a quando il dato 
            non arriva al sonar di livello più alto il <i>sonarqak22</i> che immette i dati nel sistema tramite un evento.

            <h5>Sonarqak22varesi</h5>
            Questo sonar è progettato per essere il più astratto possibile, di conseguenza non raccoglie in maniera diretta i dati prodotti dal <i>SonarAlone.c</i>. 
            Questo sonar si serve della libreria <i>radarSystem22.domain</i>, incapsulando le funzionalità di un oggetto di tipo 
            <kc>ISonar</kc>. La classe <kc>SonarConcrete.java</kc>, che implementa <i>ISonar</i>, utilizza il <i>SonarAlone.c</i> per produrre i dati. 
            Tali dati vengo memorizzati nella variabile d'istanza <kc>IDistance curVal</kc>, tale variabile è accessibile tramite il metodo 
            <kc>getDistance</kc> di <kc>SonarModel</kc> e quindi il valore memorizzato al suo interno è accessibile tramite il metodo 
            <kc>getVal</kc> offerto dalla classe <kc>Distance</kc>. Una volta ottenuto il valore esso può essere immesso nel sistema tramite un evento.
            <br><br>
            In entrambi i casi, dunque, i dati prodotti dal sonar sono immessi nel sistema tramite un evento, che può essere così definito:
            <pre>
<key2>Event</key2> sonardata : distance( V )</pre>
            
            
            <h4>Filtraggio delle distanze rilevate dal sonar</h4>
            Dopo aver capito come i dati prodotti dal sonar vengono immessi nel sistema, è necessario come tali dati possano essere sfruttati 
            per soddisfare i requisiti. <br> In particolare, i dati prodotti dal sonar devono essere confrontati con un valore fisso (<kc>DLIMIT</kc>) 
            e se il valore rilevato dal sonar è inferiore a tale soglia il robot deve essere stoppato. Quando il valore torna ad essere maggiore della soglia 
            il robot deve riprendere il movimento su cui era stato stoppato. <br>
            Risulta quindi evidente come tali dati debbano essere utilizzati, tuttavia nasce a questo punto il problema di definire quale componentene debba 
            essere incaricato di effettuare tale confronto. <br>
            <ul>
                <li>
                    <b>Primo approccio</b>: il sonarqak è incaricato di effettuare il confronto tra volore rilevato e soglia.
                </li>
                <li>
                    <b>Secondo approccio</b>: il sonarqak è incaricato di produrre i dati, ma il confronto tra valore rilevato e soglia è effettuato da un altro componente.
                </li>
            </ul>
            Il primo approccio è sicuramente da evitare, il sonarqak risultante sarebbe intriso di logica di business specifica per questo particolare dominio applicativo, risultando quindi poco riutilizzabile.
            <br>
            Il secondo approccio, invece, è quello consigliato. In particolare, si potrebbe progettare un nuovo componente, il <kc>sonarfilter</kc> 
            che raccoglie l'evento emesso dal <i>sonarqak</i> ed esegue il confronto con la soglia. Dal momento che il <i>sonarfilter</i> è un componente 
            che deve essere in grado di ricevere informazioni tramite <i>Eventi</i> e comunicare con il resto del sistema a scambio di messaggi, è opportuno 
            che esso sia progettato e implementato come un <i>attore QAk</i>. <br>  <br>
            Questo nuovo componente potrebbe essere collato su uno qualsiasi dei nodi del sistema, tuttavia poiche contiene logica di business, consigliamo 
            agli sviluppatori di porlo sullo stesso nodo computazionale del <kc>wasteService</kc>.

            <h4>Gestione di Stop & Resume</h4>
            Dopo aver stabilito che il confronto tra valore rilevato e soglia deve essere effettuato da un componente diverso dal sonar, è necessario 
            capire come il <i>sonarfilter</i> possa <i>stoppare</i> e far <i>ripartire</i> il <kc>transportTrolley</kc>. 
            
            <h5>Analisi sulle azioni "stoppabili"</h5>
            Dall'analisi dei requisiti e dalle analisi del problema condotte negli sprinti precedenti, risulta chiaro che il 
            <i>TransportTrolley</i> compie sostanzialmente 4 tipi di azioni:
            <ul>
                <li>
                    <b>Movimento in avanti</b>: Sono le azioni necessarie a muovere il robot nella stanza. Con "movimento in avanti" facciamo 
                    riferimento all'insieme di azioni base (<kc>step</kc>) che muovono il robot in avanti lungo una direzione.
                </li>
                <li>
                    <b>Rotazione</b>: Sono le azioni necessarie a far ruotare il robot su se stesso.
                </li>
                <li>
                    <b>Pickup</b>: L'azione eseguita dal robot per caricare il rifiuti trasportati dal truck.
                </li>
                <li>
                    <b>Dropout</b>: L'azione che il robot esegue per depositare il carico di rifiuti nel container.
                </li>
            </ul>
            Le azioni di <i>rotazione</i> e i passi base (<i>step</i>) vengo eseguite dal <kc>DDR robot</kc> in maniera atomica e per tanto esse non sono stoppabili. 
            Tuttavia, il robot potrebbe essere stoppato al termine di una di queste operazioni, prima dell'esecuzione della prossima mossa. <br>
            Per quanto riguarda le operazione <i>pickup</i> e <i>dropout</i> anche esse vengono eseguite in maniera atomica per tanto non sono stoppabili. <br> <br>
            
            <h5>Chi riceve lo stop & resume</h5>
            Dal momento che le uniche azioni stoppabili sono quelle di "movimento", sarà necessario interrompere l'esecuzione del <kc>pathexec</kc>, ovvero il componente che 
            gestisce e somministra al <kc>basicrobot</kc> tutte le mosse base, sarà quindi lui il componente che riceverà il messaggio di <i>stop</i>, 
            tuttavia, sarà necessario aggiornare lo stato del <kc>TransportTrolley</kc> ogni volta che viene stoppato. <br> <br>

            Per quanto riguardo il messaggio di <i>resume</i> esso potrebbe essere raccolto dal <i>pathexec</i> o da qualche altro 
            compoenente, come ad esempio il <kc>TransportTrolleyMover</kc>, che sarà quindi responsabile di far ripartire il robot. 

            <h5>Interazione tra i componenti</h5>
            Dal momento che il nostro obbiettivo è quello di stoppare il robot solo durante determinate azioni, sarebbe opportuno che il componente 
            <i>pathexec</i> non si ritrovasse in coda un messaggio di <i>stop</i> al momento sbagliato, inoltre il <i>pathexec</i> è già 
            predisposto per raccogliere un evento (<kc>alarm</kc>). Consigliamo, quindi, agli sviluppatori di trattare il messaggio di <i>stop</i> 
            come un evento:
            <pre>
<key2>Event</key2> alarm : alarm(X)</pre>
            
            Inoltre, in questo modo l'evento potrebbe essere raccolto anche da altri componenti del sistema e utilizzato per aggiornare lo stato del <i>TransportTrolley</i>.
            <br><br>
            Per quanto riguarda il messaggio di <i>resume</i> esso potrebbe non essere inviato al <i>pathexec</i> ma al <kc>TransportTrolleyMover</kc>, 
            che una volta processato il messaggio farebbe ripartire il <i>pathexec</i>. Dal momento che il messaggio di <i>resume</i> deve essere 
            processato solo se è avvenuto uno stop del robot e in caso contrario scartato, consigliamo di trattare questo messaggio come un evento, 
            inoltre poichè il messaggio è destinato a componenti interni al contesto in cui viene sollevato si potrebbe optare per l'utilizzo di un 
            evento locale in modo da evitare il sovraccarico della rete:
            <pre>
<key2>Event</key2> local_resume : local_resume(X)</pre>
            Inoltre, in questo modo l'evento potrebbe essere raccolto anche da altri componenti del sistema e utilizzato per aggiornare lo stato del <i>TransportTrolley</i>.
            </div>
        

        <div class="remark">
            <h3>Architettura Logica</h3>
            Sulla base di quanto emerso in fase di analisi del problema è possibile ridefinire l'architettura logica del sistema come segue: 
            <br><br>
            <img src="./resources/img/ArchLogicSprint3_initial.png" alt="" style="width:60% ; height:60% ;">
            <br><br>
            <a href="./resources/qak/wasteService.qak">wasteService.qak</a><br>
            <a href="./resources/qak/rasp.qak">rasp.qak</a><br>
            <a href="./resources/qak/basicrobot.qak">basicrobot.qak</a>
        </div>
        <h2>Project</h2>
        <div class="remark">
            <h3>Led</h3>
            Come consigliato dagli analisti useremo il software fornito dal committente per la gestione del <i>Led</i>. <br>
            Dal momento però che il componente <i>Led</i> deve essere in grado di interagire con gli altri componenti del sistema, 
            gli analisti ci hanno consigliato di modellare il <i>Led</i> come un attore QAk che incapsula le funzionalità del software fornito dal committente. In questo modo si può dotare il <i>Led</i> dell'abilità di comunicare a scambio di messaggi. <br>
        <h4>Led Component</h4>
        Come detto in fase di analisi del problema sarà il <i>TransportTrolley</i> a dire al <i>Led</i> quando fare il cambiamento di stato. Questo avviene attraverso l'invio di messaggi al <i>Led</i>. <br>
            <pre>
<key2>State</key2> pickupMove{
        ...
     <key2>forward</key2> led <key2>-m</key2> blink : blink(_)
        ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> pickupExec{
    ...
 <key2>forward</key2> led <key2>-m</key2> turnon : turnon(_)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> dropoutMove{
    ...
 <key2>forward</key2> led <key2>-m</key2> blink : blink(_)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> dropoutExec{
    ...
 <key2>forward</key2> led <key2>-m</key2> turnon : turnon(_)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> backHome{
    ...
 <key2>forward</key2> led <key2>-m</key2> blink : blink(_)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> backHomeRes{
    <key2>forward</key2> led <key2>-m</key2> turnoff : turnoff(_)
    ...

}<key2>Goto</key2> idle
            </pre>
        
        Per quanto riguarda lo stato del <i>Led</i>, come consigliato dagli analisti, abbiamo deciso di mantenere lo stato del <i>Led</i> 
        in una <ks>data class Kotlin</ks>, permettendo così di disaccoppiare la gestione dello stato dalle funzionalità del <i>Led</i>. <br>

        Per quanto riguarda la gestione dello stato del Led, come consigliato dagli analisti, abbiamo sviluppato il progetto in modo tale che , quando
        il TransportTrolleCore dice al Led di (spegnersi, accendersi, brillare) , subito dopo manda un messaggio al SystemStateManager dicendogli update led (STATE). <br>
        In questo modo il sistema tiene traccia dello stato del Led, infatti successivamente, come detto nello Sprint2, sarà il SystemStateManager a comunicare con la <i>GUI</i>,
        dove vedremo lo stato del Led. <br>
        <pre>
<key2>State</key2> pickupMove{
        ...
     <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(BLINKING)
        ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> pickupExec{
    ...
 <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(ON)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> dropoutMove{
    ...
 <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(BLINKING)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> dropoutExec{
    ...
 <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(ON)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> backHome{
    ...
 <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(BLINKING)
    ...
}<key2>Transition</key2> t0 whenReply ...

<key2>State</key2> backHomeRes{
    <key2>forward</key2> systemstatemanager <key2>-m</key2> updateled : updateled(OFF)
    ...

}<key2>Goto</key2> idle
            </pre>

            Il codice completo è consultabile nel file <a href="./resources/qak/wasteService.qak">wasteService.qak</a>. <br>
       
            </div>
            <div class="remark">
                <h3>Sonar</h3>
                </div>
 
        <h2>Test Plan</h2>
        <div class="remarkTest"></div>

        <h2>Architettura finale del Sistema</h2>
        <div class="remark"></div>

        <div class="remark">
            <h4>Distribuzione del sistema</h4>
            Il nostro sistema si sviluppa in più nodi che comunicano tra loro e che sono cosi distribuiti: <br>
            <ul>
                <li>Docker container contenente il contesto ctxwasteservice</li>
                <li>Docker container contenente il contesto ctxbasicrobot</li>
                <li>RaspberryPI contenente il contesto ctxrasp</li>
                <li>Dispositivo contenente il contesto ctxserver in cui si trova la GUI</li>
                <li>Smartdevice</li>
            </ul>
            <h3>Deployment</h3>
            Nella cartella Deployment contenuta nel nostro repository GitHub troviamo le directory <i>unibo.basicrobot22</i>, <i>unibo.wasteService</i> e <i>it.unibo.virtualrobot2020</i>. <br>
            Per le prime due è stato necessario aprire l'intero progetto in IntelliJ e fare il build del progetto, in modo da avere a nostra disposizione il file con estensione <i>.tar</i> utile a creare l'immagine del nostro sistema. <br>
            Le immagini del sistema sono state create con il software <a href="https://www.docker.com/">Docker</a>. <br>
            E' stato necessario aggiungere nella cartella <i>unibo.basicrobot22</i> il file <a href="./resources/dockerfile/Dockerfile_robot">Dockerfile</a> contenente le seguenti istruzioni.<br>
            <pre>
FROM openjdk:11.0.14
EXPOSE 8020

ADD ./build/distributions/unibo.basicrobot22-2.0.tar /
WORKDIR /unibo.basicrobot22-2.0/bin
COPY ./*.pl ./
COPY ./*.json ./

CMD ["bash", "unibo.basicrobot22"]</pre> 

Una volta creato il file è stato eseguito il comando "<kc>docker build -t name:tag .</kc>" per creare l'immagine del sistema a partire dal <i>Dockerfile</i> appena creato. <br><br>
Nello specifico è stato eseguito il seguente comando: <kc>docker build -t basicrobot22:2.0 .</kc>
            Per creare l'immagine del sistema <i>unibo.wasteService</i> si è proceduto nello stesso modo. E' stato creato il file <a href="./resources/dockerfile/Dockerfile_wasteservice">Dockerfile</a> contenente le seguenti istruzioni.<br>
           <pre>
FROM openjdk:11.0.14
EXPOSE 8055

ADD ./build/distributions/unibo.wasteservice-1.0.tar /
WORKDIR /unibo.wasteservice-1.0/bin
COPY ./*.pl ./
COPY ./*.json ./

CMD ["bash", "unibo.wasteservice"]</pre> 
           Quindi è stato eseguito il comando <kc>docker build -t wasteservice:1.0 .</kc> per la creazione dell'immagine del sistema. <br><br>

           Ogni istruzione contenuta nel <i>Dockerfile</i> crea un layer:
<ul>
    <li><ks>FROM</ks> crea un layer a partire dall'immagine docker <i>openjdk:11.0.14</i>.</li>
    <li><ks>EXPOSE</ks> informa Docker che il contenitore è in ascolto sulle porte di rete specificate in fase di esecuzione.</li>
    <li><ks>ADD</ks> aggiunge al Docker container una cartella locale</li>
    <li><ks>WORKDIR</ks> definisce la directory di lavoro per le istruzioni successive nel Dockerfile</li>
    <li><ks>COPY</ks> aggiunge tutti i file cone estensione pl e json alla directory di lavoro </li>
    <li><ks>CMD</ks> specifica il comando da eseguire all'interno del container.</li>
</ul>

Lo stesso è stato fatto per la cartella <i>it.unibo.virtualrobot2020</i>. <br>
Tale software ci è stato fornito dal committente e dunque all'interno della cartella troviamo già il file<a href="./resources/dockerfile/Dockerfile_wenv">Dockerfile</a>.
Quindi in questo caso abbiamo dovuto solo creare l'immagine tramite il comando visto precedentemente. <br>
<pre>
docker build -t wenv:1.0 .
</pre>

Infine sono stati creati due file con estensione .yaml per l'esecuzione di applicazioni multi-container. <br>
Il file <i>basicrobot22.yaml</i> contiene le seguenti istruzioni: <br>
<pre>
version: '3.3'
services:
  wenv:
    image: docker.io/alerei94/wenv:1.0
    ports:
      - 8090:8090 
      - 8091:8091/tcp
      - 8091:8091/udp
  robot:
    image: docker.io/alerei94/basicrobot22:2.0
    ports:
      - 8020:8020/tcp
      - 8020:8020/udp
    depends_on:
      - wenv</pre>
Mentre il file <i>wasteservice.yaml</i> è cosi strutturato:
<pre>
version: '3.3'
services:
  wasteservice:
    image: docker.io/alerei94/wasteservice:1.0
    ports:
      - 8055:8055/tcp
      - 8055:8055/udp</pre>

Il codice dei file .yaml è fornito di seguito:
<ul>
    <li><a href="./resources/yaml/basicrobot22.yaml">basicrobot22.yaml</a></li>
    <li><a href="./resources/yaml/wasteservice.yaml">wasteservice.yaml</a></li>
</ul>
    
Per il deployment del contesto <i>ctxrasp</i> che verrà eseguito su RaspberryPI è stato necessario eseguire il comando <i>./gradlew distZip</i> per creare il file di distribuzione a partire dal file <i>build.gralde</i> <br>
Il file <a href="./resources/build/build.gradle"><i>build.gradle</i></a> in particolare contiene le seguenti istruzioni:
<pre>
distributions {      
    main{
        contents{
            from "./DomainSystemConfig.json"
            from "./rasp.pl"                
            from "./sysRules.pl"
            from "./led25GpioTurnOn.sh"
            from "./led25GpioTurnOff.sh"
            from "./sonarAlone.c "
        }
    }
}</pre>
in modo da rendere disponibili tutti i file necessari per l'esecuzione del sistema. <br>

Quindi tramite <kc>FileZilla</kc> abbiamo copiato il file <i>unibo.rasp-1.0.zip</i> contenuto all'interno della cartella del progetto <i>/build/distributions/</i> sul RaspberryPI e da terminale abbiamo eseguito il comando <kc>unzip unibo.rasp-1.0.zip</kc> per estrarre il file. <br>
Dopo di che tramite <i>FileZilla</i> abbiamo spostato i file contenuti nella cartella <i>/unibo.rasp-1.0</i> nella cartella <i>/unibo.rasp-1.0/bin </i>sul RaspberryPI. <br>
</div>
        
        <div class="remark">
            <h3>How to start the system</h3>
            <ul>
                <li>
                    <b>Avviare lo <kc>smartdevice</kc></b><br>
                    Da terminale navigare fino al path <i>WasteService-Project/Sprint1/unibo.smartdevice</i> e lanciare il comando <i>python3 smartdevice.py</i>
                    <pre>
cd WasteService-Project/Sprint1/unibo.smartdevice
python3 smartdevice.py</pre>
                </li>

                <li>
                    <b>Avviare la <kc>WasteServiceStatusGUI</kc></b><br>
                    Da terminale navigare fino al path <i>WasteService-Project/Sprint2/webgui</i> e lanciare il comando <i>./gradlew run</i>
                    <pre>
cd WasteService-Project/Sprint2/webgui
./gradlew run</pre>
                    Aprire il browser e digitare l'indirizzo <i>http://localhost:8085</i>
                </li>
                <li>
                    <b>Avviare il <kc>wasteService</kc></b> <br>
                    Da terminale navigare fino al path <i>WasteService-Project/Deployment/</i> e lanciare il comando <i>docker-compose -f wasteservice.yaml up </i>
                    <pre>
cd WasteService-Project/Deployment/
docker-compose -f wasteservice.yaml up</pre>
                </li>
                <li>
                    <b>Avviare il <kc>basicrobot22</kc> e il <kc>virtualRobot2020</kc></b> <br>
                    Da terminale navigare fino al path <i>WasteService-Project/Deployment/</i> e lanciare il comando <i>docker-compose -f basicrobot22.yaml up </i>
                    <pre>
cd WasteService-Project/Deployment/
docker-compose -f basicrobot22.yaml up</pre>
                Aprire il browser e digitare l'indirizzo <i>http://localhost:8090</i>
                </li>
                <li>
                    <b>Avviare il <kc>rasp</kc></b> <br>
                    Da terminale tramite ssh collegarsi all'indirizzo del raspberry e navigare fino al path <i>unibo.rasp-1.0/bin</i> e lanciare i seguenti comandi:
                    <ul>
                        <li><i>g++ SonarAlone.c -l wiringPi -o SonarAlone</i></li>
                        <li><i>./unibo.rasp</i></li>
                    </ul>
            <pre>
ssh pi@raspberrypi.local
cd unibo.rasp-1.0/bin
g++ SonarAlone.c -l wiringPi -o SonarAlone
./unibo.rasp</pre>
                </li>
            </ul>
        </div>

       

        <div style="display: flex; flex-direction: row; justify-content: space-around;">
            <div><a href="../../Sprint2/userDocs/sprint2.html"> <-- Sprint2</a></div>
        </div>
        <br><br>
        <div style="background-color:rgba(60, 131, 186, 0.9); width:50%;text-align:center;color:white; margin-left: 25%; border-radius: 25px;" >
            <br>
            By students: <br>
            Name: Annamaria Simonitto, Enrico Valastro, Alessio Reitano   
            <br>
            Email: annamaria.simonitto@studio.unibo.it, enrico.valastro@studio.unibo.it, alessio.reitano@studio.unibo.it
            <br><br>
            <img src="../../Sprint0/userDocs/resouces/images/AnnamariaSimonitto.jpg" alt="" width="8%" height="8%">
            <img src="../../Sprint0/userDocs/resouces/images/EnricoValastro.jpeg" alt="" width="8.5%" height="8.5%">
            <img src="../../Sprint0/userDocs/resouces/images/AlessioReitano.jpeg" alt="" width="10%" height="10%">
        </div> 
    </div>
</body>
</html>