<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    body
    {
        margin-left:  30px;
        margin-right: 30px;
    };
    
    P
    {
        font-family: Tahoma;
        font-size: 10pt;
    };
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }
    
    a:hover {
        background-color: #cccccc;
    }
    
    
    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }
    
    h1, h2, h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }
    
    top {
        width: 100%;
    }
    
    
    #i {
        color: #ff1010;
    }
    tt{
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }
    em{
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style:solid;
        border-color: #abe876;
        color: #1632cc;
    }
    bc{
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }
    ks{
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD	;
        font-size: 90%;
    }
    kc{
        font-family: "Arial";
        font-weight: bold;
        color: #008000	;
        font-size: 90%;
    }
    pre{
        font-family:monospace;
        font-weight: 500;
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }
    key{
        font-family:monospace;
        font-weight: 500;	
        color: #304ceb;
    }
    key2{
        font-family:monospace;
        font-weight: 500;
        color: #ad0d0f;
    }
    
    key3{
        font-family:monospace;
        font-weight: 500;
        color: #01b948;
    }
    
    key4{
        font-family:monospace;
        font-weight: 500;
    
        color: #008232;
    }
    
    pro{
        font-weight: bold;
        color:blue;
    }
    cons{
        font-weight: bold;
        color: red;
    }
    
    m{
        font-family: "Helvetica";
        line-height: 100%;
         font-size: 75%;
    }
    div.body{
         
        font-size: 18px;
    }
    k{
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }
    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }
    
    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }
    
    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }
    h3.test{
        background-color: #42b966;
        font-size: 100%;
    }
    h4 {
        background-color: #6dd4f4b5;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    h4.test{
        background-color: #5ee887;
        font-size: 100%;
    }
    h5 {
        background-color: #91df4d;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    div.req{
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }
    div.remark{
        background-color: #E3F2FD;
        border: 1.5px solid #E3F2FD;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    div.remarkTest{
        background-color: #d4fbd7;
        border: 1.5px solid #d4fbd7;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    
    ol, ul, li {
      margin: 0;
      margin-left: 10px;
      padding: 0;
      padding-bottom: 5px;
    }
    
    table, th, td {
        border: 1px solid black;
    }
    
    img {
        border: 1.5px solid #d5f2ed
    
    }
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }
    
    div.wrapdesc{
        width: 90%;
        margin: auto;
    }
    
    div.imagedesc{
        width: 85%;
        margin: auto;
    }
    </style>
    
<head>
    <meta charset="UTF-8">
    <title>Sprint2</title>
</head>
    
<body>
    <div id="top">
        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
    </div>  

    <div class="body"> 
        <a href="../../Sprint0/userDocs/sprint0.html">Sprint 0</a>
        <a href="../../Sprint1/userDocs/sprint1.html">Sprint 1</a>
        <a href="./sprint2.html">Sprint 2</a>
        <a href="../../Sprint3/userDocs/sprint3.html">Sprint 3</a>
        <h2>Introduction</h2>
        <div class="remark">
            Progetto finale di ISS finalizzato allo sviluppo software di un impianto di smistamento dei rifiuti attraverso un robot che preleva il carico del camion e lo porta al container appropriato
        </div>

        <h2>Requirements</h2>
        <div class="remark">
            <a href="../../Sprint0/userDocs/resouces/html/TemaFinale22.html">TemaFinale22</a>
        </div>

        <h2>Work Plan</h2>
        <div class="remark">
            In questo Sprint ci occuperemo della <kc>WasteServiceStatusGUI</kc>. Questa permetterà al Service-manager di: 
            <ul>
                <li>vedere lo stato corrente del transportTrolley e la sua posizione nella stanza</li>
                <li>vedere il peso corrente dei due container</li>
                <li>vedere lo stato corrente del Led</li>
            </ul>
            Nello Sprint analizzeremo le principali problematiche relative alla GUI e le risolveremo.
         
        </div>

        <h2>Problem analysis</h2>
        
        <div class="remark">
            <h3>Sprint1 result</h3>
            Al termine dello <a href="../../Sprint1/userDocs/sprint1.html">Sprint1</a>, l'architettura logica è la seguente: <br></br>
            <img src="../../Sprint1/userDocs/resources/img/ArchLogicSprint1Review.png" alt="" width="60%" height="60%">
            <br>
        </div>

        <div class="remark">
            <div id="gui"><h3>Problem: Kind of GUI</h3></div>
            Per sviluppare la <kc>GUI</kc> è possibile servirsi di: <br>
            <ul>
                <li>App Android</li>
                <li>Web App</li>
                <li>App iOS</li>
            </ul>
            Per quanto riguarda l'App Android e iOS, il <kc>Service-manager</kc> dovrebbero essere fornito di un dispositivo compatibile con essa, ciò risulta poco inclusivo e riutilizzabile. <br>
            Per quanto riguarda la Web App invece, è possibile utilizzare un browser web da qualsiasi dispositivo per accedere alla GUI, risultando quindi più versatile.<br>
            Dopo aver analizzato le varie opzioni, suggeriamo al team di sviluppo, la strada della Web App, servendosi del framework <ks>SpringBoot</ks>, di cui il team ha una buona conoscenza. <br>
        </div>

        <div class="remark">
            <div id="dataSource"><h3>Problem: Show Data</h3></div>
            Dai requisiti, emerge che il componente <kc>WasteServiceStatusGUI</kc> deve essere in grado di mostrare ad un utente umano, il <kc>Service-manager</kc>, 
            una serie di informazioni riguardanti lo stato del sistema e dei sui componenti. <br>
            <h4>Data Source</h4>
            Bisogna quindi comprendere quali siano le fonti di tali informazioni. In particolare, la <i>GUI</i> deve fornire informazioni su:
            <ul>
                <li>
                    <b>Stato del <kc>transportTrolley</kc> e la sua posizione nella stanza</b>
                </li>
                <li>
                    <b>Peso corrente dei due container</b>
                </li>
                <li>
                    <b>Stato corrente del Led</b>
                </li>
            </ul>
            <h5>Stato e posizione del transportTrolley</h5>
            Dall'analisi dei requisiti è emerso che lo stato e la posizione del <kc>transportTrolley</kc>, possono essere rappresentati tramite i seguenti enumerativi:

            <pre>
<key>enum</key> <key>class</key> CurrStateTrolley { <i>IDLE</i>, <i>STOPPED</i>, <i>MOVING</i>, <i>PICKINGUP</i>, <i>DROPPINGOUT</i> }</pre>

            <pre>
<key>enum</key> <key>class</key> TTPosition { <i>HOME</i>, <i>INDOOR</i>, <i>PLASTICBOX</i>, <i>GLASSBOX</i>, <i>ONTHEROAD</i> }</pre>

            Inoltre, in seguito all'analisi condotta nello Sprint1, è stato deciso di mantenere questi dati utilizzando la <ks>data class Kotlin</ks> <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>. 
            I dati vengo amministrati da un componente, che è stato creato <i>ad hoc</i> per gestire e mantenere lo stato del sistema, il <kc>SystemStateManager</kc>.
            Tale componente è implementato come un attore QAk, pertanto esso è definito come una risorsa CoAP osservabile, il che lo rende una possibile fonte per i dati di interesse della GUI.

            <h5>Peso corrente dei due container</h5>
            Dall'analisi dei requisiti è emerso che il peso corrente dei due container, può essere rappresentato tramite una <ks>MutableMap</ks>:
            <pre>
<key>private val</key> boxCurrentWeight : MutableMap < Material, Double ></pre>
            
            Inoltre, come emerso dallo Sprint1, lo stato dei container è mantenuto nella <ks>data class Kotlin</ks> <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>. 
            Anche in questo caso, i dati relativi al peso corrente dei container vengono amministrati dal <i>SystemStateManager</i>.
            
            <h5>Stato del Led</h5>
            Per quanto rigurda lo stato del led, dall'analisi dei requisiti è emerso che può essere rappresentato tramite un enumerativo:

            <pre>
<key>enum</key> <key>class</key> CurrStateLed { <i>ON</i>, <i>OFF</i>, <i>BLINKING</i> }</pre>
            
            Tuttavia, la sua gestione, resta una problematica ancora aperta che verrà trattata nello Sprint3. Ciò nonostante, supponiamo che lo stato del led sarà gestito allo 
            stesso modo degli altri dati, ossia tramite il <i>SystemStateManager</i>. Per tale motivo, suggeriamo agli sviluppatori di apportare le modifiche necessarie, al <i>SystemStateManager</i> 
            e alla <i>data class</i> <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>, affinchè essi siano predisposti alla gestione dello stato del led.
            
            <br><br>
            Alla luce di questa analisi è possibile affermare che la <i>fonte di dati</i> per la GUI, è rappresentata dal componente <i>SystemStateManager</i>.
            <h4>Fetch vs Push</h4>
            Una volta compreso che il <kc>SystemStateManager</kc> è la fonte di dati per la GUI, bisogna comprendere come questi dati vengano recuperati dalla GUI. <br>
            Sono possibili due modalità di recupero dei dati:
            <h5>Fetch</h5>
            Questa soluzione prevede che sia la GUI a richiedere i dati al <kc>SystemStateManager</kc>, ciò comporta che la <i>GUI</i> debba aprire un canale di comunicazione con il <kc>SystemStateManager</kc> 
            e richiedere i dati e stare in ascolto di risposte. <br> Inoltre, affinchè non venga perso nessun dato, è necessario che questa operazione venga ripetuta ad intervalli regolari, generando un elevato <i>overhead</i> di rete.<br> 
            Per tale motivo, sconsigliamo agli sviluppatori di adottare questo approccio.
            <h5>Push</h5>
            Tale soluzione prevede che la <kc>GUI</kc> venga progettata come un componente passivo, che riceve dati e li mostra all'utente. Per fare ciò è necessario, che qualche componente 
            invii in maniera spontanea, tutti gli aggioramenti di stato alla <i>GUI</i>. <br> 
            L'adozione di questa soluzione è particolarmente consigliata, in quanto permette di sfruttare la caratteristica degli attori QAk di essere realizzati come delle risorse <i>CoAP</i> osservabili. 
            Procedendo in questo modo, sarà sufficente che la <i>GUI</i> apra una conessione <i>CoAP</i> con il <i>server CoAP</i> del <kc>SystemStateManager</kc> e si registri come osservatore della risorsa.
            Successivamente l'attore QAk, potrà utilizzare la primitiva <ks>updateResources</ks> per inviare al server <i>CoAP</i> l'aggiornamento di stato, questo successivamente notificherà gli osservatori circa il cambiamento di stato.

        </div>
        
        <div class="remark">
            <div id="lateStart"><h3>Problem: Late start of the GUI</h3></div>
            Dal momento che l'avvio del <kc>WasteService</kc> è svincolato dall'avvio della <kc>GUI</kc>, potrebbe verificarsi lo scenario in cui 
            la <i>GUI</i> parta dopo il <i>WasteService</i>. <br>
            Bisogna comprendere come, in tale circostanza, debba essere gestito l'aggiornamento dei dati mostrati dalla <i>GUI</i>.
            Infatti se la <i>GUI</i> dovesse essere avviata tempo dopo il <i>WasteService</i>, potrebbero essersi verificati dei cambiamti di stato che la <i>GUI</i> non mostra.<br>
            Si pone il problema di come gestire l'aggiornamento dei dati mostrati dalla <i>GUI</i> in caso di <i>late start</i>. <br>
            <ul>
                <li>Fare fetch all'avvio della GUI</li>
                <li>Aspettare che una richiesta scateni un <ks>updateResources</ks></li>
            </ul>
            <h4>Waiting for updateResources</h4>
            Aspettare che arriva un'altra richiesta al WasteService è la soluzione più semplice da implementare, ma non è la migliore. <br>
            Infatti protrebbe verificarsi il caso in cui al WasteService non arrivino richieste anche per istanti di tempo lunghi, pertanto la GUI non si aggiornerà fino a quel momento, mostrando dei dati errati. <br>
            <h4>Fetch</h4>
            Per fare ciò, si potrebbe inviare al <kc>SystemStateManager</kc>, usando una connessione TCP, un messaggio per richiedere l'invio dei dati. <br>
            Bisogna capire che tipo di messaggio inviare, un <kc>Dispatch</kc> o una <kc>Request</kc>. Utilizzando una <i>Request</i> la GUI dovrebbe rimanere in attesa della risposta, e gestire il messaggio ricevuto.
            Utilizzando un <i>Dispatch</i>, si potrebbero evitare tali problematiche, in quanto, alla ricezione del <i>Dispatch</i>, il <kc>SystemStateManager</kc> scatenerà un <ks>updateResources</ks> che verrà raccolto e gestito in maniera analoga 
            agli aggiornamenti di stato.
            <pre>
<key2>Dispatch</key2> getdata : getdata(_)</pre>
            Alla luce di ciò, consigliamo agli sviluppatori di progettare la <i>GUI</i> in modo che faccia <i>Fetch</i> dei dati all'avvio.
        </div>
        
        <div class="remark">
            <h3>Architettura Logica</h3>
            Sulla base di quanto emerso in fase di analisi del problema è possibile ridefinire l'architettura logica del sistema.<br> 
            <br><br>
            <img src="./resources/img/ArchLogicSprint2Initial.png" alt="" style="width:60% ; height:60% ;">
        </div>
    
        <h2>Project</h2>
        <div class="remark">
            <h3>GUI</h3>
            <h4>Operazioni Preliminari</h4>
            Come suggerito dagli analisti, si è deciso di progettare la <kc>GUI</kc> come una Web App, sfruttando a pieno le potenzialità del framework <kc>SpringBoot</kc>. Si è optato per questa soluzione perchè risulta essere quella più versatile che permette di accedere alla <i>GUI</i> da qualsiasi dispositivo. 
            <br>
            Per iniziare è bastato collegarsi al sito <a href="https://start.spring.io">Spring.io</a> il quale ci ha permesso di creare il progetto, scegliendone innanzitutto il tipo (Gradle o Maven), la versione di Java da utilizzare e le dipendenze necessarie da "aggiungere" al progetto come mostrato in figura. Premuto il tasto <ks>GENERATE</ks> si ottiene un file <ks>.zip</ks> che contiene l'intero progetto. <br>
            <br>
            <img src="./resources/img/Spring_Initializr.png" width="50%" height="30%">
            <br>
            Dopo aver scaricato il file <i>.zip</i> è stato necessario decomprimerlo e importarlo nel nostro IDE come progetto <ks>Gradle</ks>, dove abbiamo potuto notare la struttura che il framework <i>SpringBoot</i> ha creato per noi. <br>
            Dopo di che andiamo ad aggiungere al file <kc>build.gradle</kc> le ulteriori dipendenze che ci serviranno per il progetto, oltre a quelle già generate al momento della creazione del progetto. <br>
            <br>
            <img src="./resources/img/build.gralde.png" width="50%" height="30%"> <br>
            <br>
            Il file <i>build.gralde</i> dell'applicazione è consultabile al seguente link <a href="./resources/gradle/build.gradle">build.gradle</a>.
            <br>
            Il passo successivo è stato quello di definire all'interno del file <kc>application.properties</kc> la porta sulla quale gira la nostra applicazione, il nome dell'applicazione e il banner che verrà mostrato all'avvio. <br>
            <br>
            <img src="./resources/img/application_properties.png" width="50%" height="30%"> <br>
            <h4>Operazioni Preliminari</h4>
        </div>

        <h2>Test Plan</h2>
        <div class="remarkTest"></div>
	    
        <div style="display: flex; flex-direction: row; justify-content: space-around;">
            <div><a href="../../Sprint1/userDocs/sprint1.html"> <-- Sprint1</a></div>
            <div><a href="../../Sprint3/userDocs/sprint3.html"> Sprint3 --></a></div>
        </div>
        <br><br>
        <div style="background-color:rgba(60, 131, 186, 0.9); width:50%;text-align:center;color:white; margin-left: 25%; border-radius: 25px;" >
            <br>
            By students: <br>
            Name: Annamaria Simonitto, Enrico Valastro, Alessio Reitano   
            <br>
            Email: annamaria.simonitto@studio.unibo.it, enrico.valastro@studio.unibo.it, alessio.reitano@studio.unibo.it
            <br><br>
            <img src="../../Sprint0/userDocs/resouces/images/AnnamariaSimonitto.jpg" alt="" width="8%" height="8%">
            <img src="../../Sprint0/userDocs/resouces/images/EnricoValastro.jpeg" alt="" width="8.5%" height="8.5%">
            <img src="../../Sprint0/userDocs/resouces/images/AlessioReitano.jpeg" alt="" width="10%" height="10%">
        </div> 

    </div>
</body>
</html> 