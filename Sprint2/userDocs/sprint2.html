<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    body
    {
        margin-left:  30px;
        margin-right: 30px;
    };
    
    P
    {
        font-family: Tahoma;
        font-size: 10pt;
    };
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }
    
    a:hover {
        background-color: #cccccc;
    }
    
    
    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }
    
    h1, h2, h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }
    
    top {
        width: 100%;
    }
    
    
    #i {
        color: #ff1010;
    }
    tt{
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }
    em{
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style:solid;
        border-color: #abe876;
        color: #1632cc;
    }
    bc{
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }
    ks{
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD	;
        font-size: 90%;
    }
    kc{
        font-family: "Arial";
        font-weight: bold;
        color: #008000	;
        font-size: 90%;
    }
    pre{
        font-family:monospace;
        font-weight: 500;
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }
    key{
        font-family:monospace;
        font-weight: 500;	
        color: #304ceb;
    }
    key2{
        font-family:monospace;
        font-weight: 500;
        color: #ad0d0f;
    }
    
    key3{
        font-family:monospace;
        font-weight: 500;
        color: #01b948;
    }
    
    key4{
        font-family:monospace;
        font-weight: 500;
    
        color: #008232;
    }
    
    pro{
        font-weight: bold;
        color:blue;
    }
    cons{
        font-weight: bold;
        color: red;
    }
    
    m{
        font-family: "Helvetica";
        line-height: 100%;
         font-size: 75%;
    }
    div.body{
         
        font-size: 18px;
    }
    k{
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }
    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }
    
    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }
    
    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }
    h3.test{
        background-color: #42b966;
        font-size: 100%;
    }
    h4 {
        background-color: #6dd4f4b5;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    h4.test{
        background-color: #5ee887;
        font-size: 100%;
    }
    h5 {
        background-color: #91df4d;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    div.req{
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }
    div.remark{
        background-color: #E3F2FD;
        border: 1.5px solid #E3F2FD;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    div.remarkTest{
        background-color: #d4fbd7;
        border: 1.5px solid #d4fbd7;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    
    ol, ul, li {
      margin: 0;
      margin-left: 10px;
      padding: 0;
      padding-bottom: 5px;
    }
    
    table, th, td {
        border: 1px solid black;
    }
    
    img {
        border: 1.5px solid #d5f2ed
    
    }
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }
    
    div.wrapdesc{
        width: 90%;
        margin: auto;
    }
    
    div.imagedesc{
        width: 85%;
        margin: auto;
    }
    </style>
    
<head>
    <meta charset="UTF-8">
    <title>Sprint2</title>
</head>
    
<body>
    <div id="top">
        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
    </div>  

    <div class="body"> 
        <a href="../../Sprint0/userDocs/sprint0.html">Sprint 0</a>
        <a href="../../Sprint1/userDocs/sprint1.html">Sprint 1</a>
        <a href="./sprint2.html">Sprint 2</a>
        <a href="../../Sprint3/userDocs/sprint3.html">Sprint 3</a>
        <h2>Introduction</h2>
        <div class="remark">
            Progetto finale di ISS finalizzato allo sviluppo software di un impianto di smistamento dei rifiuti attraverso un robot che preleva il carico del camion e lo porta al container appropriato
        </div>

        <h2>Requirements</h2>
        <div class="remark">
            <a href="../../Sprint0/userDocs/resouces/html/TemaFinale22.html">TemaFinale22</a>
        </div>

        <h2>Work Plan</h2>
        <div class="remark">
            In questo Sprint ci occuperemo dell'analisi e dello sviluppo della <kc>WasteServiceStatusGUI</kc>. <br>
            In particolare tratteremo le problematiche relative a: 
            <ul>
                <li>
                    <a href="#gui"><b>Type of the GUI</b></a>
                    <ul>
                        <li>Web App</li>
                        <li>Mobile App</li>
                    </ul>
                </li>
                <li>
                    <a href="#dataSource"><b>Data</b></a>
                    <ul>
                        <li>Comprendere quale sia la fonte dei dati di interresse per la GUI</li>
                        <li>Comprendere come questi dati possano arrivare alla GUI</li>
                    </ul>
                </li>
                <li>
                    <a href="lateStart"><b>Late start of the GUI</b></a>
                    <ul>
                        <li>Come deve comportarsi il sistema nel caso in cui la GUI venga avviata dopo il <kc>WasteService</kc></li>
                    </ul>
                </li>
            </ul>
            Il team si occuperà di portare avanti le varie fasi dello sprint in parallelo.
            
         
        </div>

        
        <h2>Checkpoint Sprint1</h2>
        <div class="remark">
            <h3>Sprint1 result</h3>
            L'analisi condotta nello <a href="../../Sprint1/userDocs/sprint1.html">Sprint1</a> e la successiva fase di progetto e sviluppo, hanno dato vita ad un sistema che 
            presenta la seguente architettura logica: <br></br>
            <img src="../../Sprint1/userDocs/resources/img/ArchLogicSprint1Review.png" alt="" width="60%" height="60%">
            <br>
            L'obbiettivo di questo Sprint, è quello di zoomare sul componente <kc>WasteServiceStatusGUI</kc>, affrontare e superare le problematiche connessa alla sua implementaizione e fornire un prototipo funzionante del componente, che 
            verrà integrato con il sistema sviluppato nello Sprint1.

        </div>
        <h2>Problem analysis</h2>
        <div class="remark">
            <div id="gui"><h3>Problem: Kind of GUI</h3></div>
            Per sviluppare la <kc>GUI</kc> è possibile servirsi di: <br>
            <ul>
                <li>App Android</li>
                <li>Web App</li>
                <li>App iOS</li>
            </ul>
            Per quanto riguarda l'App Android e iOS, il <kc>Service-manager</kc> dovrebbero essere fornito di un dispositivo compatibile con essa, ciò risulta poco inclusivo e riutilizzabile. <br>
            Per quanto riguarda la Web App invece, è possibile utilizzare un browser web da qualsiasi dispositivo per accedere alla GUI, risultando quindi più versatile.<br>
            Dopo aver analizzato le varie opzioni, suggeriamo al team di sviluppo, la strada della Web App, servendosi del framework <ks>SpringBoot</ks>, di cui il team ha una buona conoscenza. <br>
        </div>

        <div class="remark">
            <div id="dataSource"><h3>Problem: Show Data</h3></div>
            Dai requisiti, emerge che il componente <kc>WasteServiceStatusGUI</kc> deve essere in grado di mostrare ad un utente umano, il <kc>Service-manager</kc>, 
            una serie di informazioni riguardanti lo stato del sistema e dei sui componenti. <br>
            <h4>Data Source</h4>
            Bisogna quindi comprendere quali siano le fonti di tali informazioni. In particolare, la <i>GUI</i> deve fornire informazioni su:
            <ul>
                <li>
                    <b>Stato del <kc>transportTrolley</kc> e la sua posizione nella stanza</b>
                </li>
                <li>
                    <b>Peso corrente dei due container</b>
                </li>
                <li>
                    <b>Stato corrente del Led</b>
                </li>
            </ul>
            <h5>Stato e posizione del transportTrolley</h5>
            Dall'analisi dei requisiti è emerso che lo stato e la posizione del <kc>transportTrolley</kc>, possono essere rappresentati tramite i seguenti enumerativi:

            <pre>
<key>enum</key> <key>class</key> CurrStateTrolley { <i>IDLE</i>, <i>STOPPED</i>, <i>MOVING</i>, <i>PICKINGUP</i>, <i>DROPPINGOUT</i> }</pre>

            <pre>
<key>enum</key> <key>class</key> TTPosition { <i>HOME</i>, <i>INDOOR</i>, <i>PLASTICBOX</i>, <i>GLASSBOX</i>, <i>ONTHEROAD</i> }</pre>

            Inoltre, in seguito all'analisi condotta nello Sprint1, è stato deciso di mantenere questi dati utilizzando la <ks>data class Kotlin</ks> <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>. 
            I dati vengo amministrati da un componente, che è stato creato <i>ad hoc</i> per gestire e mantenere lo stato del sistema, il <kc>SystemStateManager</kc>.
            Tale componente è implementato come un attore QAk, pertanto esso è definito come una risorsa CoAP osservabile, il che lo rende una possibile fonte per i dati di interesse della GUI.

            <h5>Peso corrente dei due container</h5>
            Dall'analisi dei requisiti è emerso che il peso corrente dei due container, può essere rappresentato tramite una <ks>MutableMap</ks>:
            <pre>
<key>private val</key> boxCurrentWeight : MutableMap < Material, Double ></pre>
            
            Inoltre, come emerso dallo Sprint1, lo stato dei container è mantenuto nella <ks>data class Kotlin</ks> <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>. 
            Anche in questo caso, i dati relativi al peso corrente dei container vengono amministrati dal <i>SystemStateManager</i>.
            
            <h5>Stato del Led</h5>
            Per quanto rigurda lo stato del led, dall'analisi dei requisiti è emerso che può essere rappresentato tramite un enumerativo:

            <pre>
<key>enum</key> <key>class</key> CurrStateLed { <i>ON</i>, <i>OFF</i>, <i>BLINKING</i> }</pre>
            
            Tuttavia, la sua gestione, resta una problematica ancora aperta che verrà trattata nello Sprint3. Ciò nonostante, supponiamo che lo stato del led sarà gestito allo 
            stesso modo degli altri dati, ossia tramite il <i>SystemStateManager</i>. Per tale motivo, suggeriamo agli sviluppatori di apportare le modifiche necessarie, al <i>SystemStateManager</i> 
            e alla <i>data class</i> <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>, affinchè essi siano predisposti alla gestione dello stato del led.
            
            <br><br>
            Alla luce di questa analisi è possibile affermare che la <i>fonte di dati</i> per la GUI, è rapresentata dal componente <i>SystemStateManager</i>.
            <h4>Polling vs Push</h4>
            Una volta compreso che il <kc>SystemStateManager</kc> è la fonte di dati per la GUI, bisogna comprendere come questi dati vengano recuperati dalla GUI. <br>
            Sono possibili due modalità di recupero dei dati:
            <h5>Polling</h5>
            Questa soluzione prevede che sia la GUI a richiedere i dati al <kc>SystemStateManager</kc>, ciò comporta che la <i>GUI</i> debba aprire un canale di comunicazione con il <kc>SystemStateManager</kc>, 
            richiedere i dati e stare in ascolto di risposte. <br> Inoltre, affinchè non venga perso nessun dato, è necessario che questa operazione venga ripetuta ad intervalli regolari, generando un elevato <i>overhead</i> di rete.<br> 
            Per tale motivo, sconsigliamo agli sviluppatori di adottare questo approccio.
            <h5>Push</h5>
            Tale soluzione prevede che la <kc>GUI</kc> venga progettata come un componente passivo, che riceve dati e li mostra all'utente. Per fare ciò è necessario, che qualche componente 
            invii in maniera spontanea, tutti gli aggioramenti di stato alla <i>GUI</i>. <br> 
            L'adozione di questa soluzione è particolarmente consigliata, in quanto permette di sfruttare la caratteristica degli attori QAk di essere realizzati come delle risorse <i>CoAP</i> osservabili. 
            Procedendo in questo modo, sarà sufficente che la <i>GUI</i> apra una conessione <i>CoAP</i> con il <i>server CoAP</i> del <kc>SystemStateManager</kc> e si registri come osservatore della risorsa.
            Successivamente l'attore QAk, potrà utilizzare la primitiva <ks>updateResource</ks> per inviare al server <i>CoAP</i> l'aggiornamento di stato, questo successivamente notificherà gli osservatori circa il cambiamento di stato.

        </div>
        
        <div class="remark">
            <div id="lateStart"><h3>Problem: Late start of the GUI</h3></div>
            Dal momento che l'avvio del <kc>WasteService</kc> è svincolato dall'avvio della <kc>GUI</kc>, potrebbe verificarsi lo scenario in cui 
            la <i>GUI</i> parta dopo il <i>WasteService</i>. <br>
            Bisogna comprendere come, in tale circostanza, debba essere gestito l'aggiornamento dei dati mostrati dalla <i>GUI</i>.
            Infatti se la <i>GUI</i> dovesse essere avviata tempo dopo il <i>WasteService</i>, potrebbero essersi verificati dei cambiamti di stato che la <i>GUI</i> non mostra.<br>
            Si pone il problema di come gestire l'aggiornamento dei dati mostrati dalla <i>GUI</i> in caso di <i>late start</i>. <br>
            <ul>
                <li>Fare fetch all'avvio della GUI</li>
                <li>Aspettare che una richiesta scateni un <ks>updateResource</ks></li>
            </ul>
            <h4>Waiting for updateResources</h4>
            Aspettare che arriva un'altra richiesta al WasteService è la soluzione più semplice da implementare, ma non è la migliore. <br>
            Infatti protrebbe verificarsi il caso in cui al WasteService non arrivino richieste anche per istanti di tempo lunghi, pertanto la GUI non si aggiornerà fino a quel momento, mostrando dei dati errati. <br>
            <h4>Fetch</h4>
            Per fare ciò, si potrebbe inviare al <kc>SystemStateManager</kc>, usando una connessione TCP, un messaggio per richiedere l'invio dei dati. <br>
            Bisogna capire che tipo di messaggio inviare, un <kc>Dispatch</kc> o una <kc>Request</kc>. Utilizzando una <i>Request</i> la GUI dovrebbe rimanere in attesa della risposta, e gestire il messaggio ricevuto.
            Utilizzando un <i>Dispatch</i>, si potrebbero evitare tali problematiche, in quanto, alla ricezione del <i>Dispatch</i>, il <kc>SystemStateManager</kc> scatenerà un <ks>updateResource</ks> che verrà raccolto e gestito in maniera analoga 
            agli aggiornamenti di stato.
            <pre>
<key2>Dispatch</key2> getdata : getdata(_)</pre>
            Alla luce di ciò, consigliamo agli sviluppatori di progettare la <i>GUI</i> in modo che faccia <i>Fetch</i> dei dati all'avvio.
        </div>
        
        <div class="remark">
            <h3>Architettura Logica</h3>
            Sulla base di quanto emerso in fase di analisi del problema è possibile ridefinire l'architettura logica del sistema.<br> 
            <br><br>
            <div style="display: flex; flex-direction: row; justify-content: space-between;">
                <img src="./resources/img/ArchLogicSprint2v2.png" alt="" style="width:60% ; height:60% ;">
                <div style="display: flex; flex-direction:column;">
                <a href="./resources/qak/wasteService.qak">wasteService.qak</a>
                <a href="./resources/java/UtilsController.java">UtilsController.java</a>
                <a href="./resources/python/smartdevice.py">smartdevice.py</a>
                </div>
            </div>
            
        </div>

        <h2>Test Plan</h2>
        <div class="remarkTest">
            Per testare il corretto funzionamento del sistema è sufficente verificare che la <i>WasteServiceStatusGUI</i> riceva i dati corretti sulla connessione CoAP. <br>
            Per questo motivo sarà sufficiente istanziare la seguente classe di test : <br><br>
            <b>Test SystemStateManager</b>: creare un osservatore CoAP del <i>SystemStateManager</i> e verificare che somministrando un 
            messaggio <kc>storewaste</kc> al sistema, l'osservatore riceva gli aggioramenti di stato corretti.
        </div>
    
        <h2>Project</h2>
        <div class="remark">
            <h3>SystemStateManager</h3>
            Come suggerito dagli analisti, abbiamo deciso di estendere le funzionalita del <kc>SystemStateManager</kc> affinchè esso sia in grado di ricevere e gestire 
            gli aggiornamenti di stato da parte del <kc>Led</kc>. Per fare questo è stato necessarrio introdurre un meccanismo che permetta al <i>Led</i> di inviare gli aggiornamenti di stato 
            al <i>SystemStateManager</i>. In accordo a quanto fatto per il <kc>TransportTrolley</kc> e per il <kc>WasteService</kc> abbiamo deciso, di implementare tale meccanismo 
            come un <ks>Dispatch</ks> che il <i>Led</i> invia al <i>SystemStateManager</i>. <br>
            <pre>
<key2>Dispatch</key2> updateled : updateled(STATE)</pre>
            
            Inoltre, è stato necessario modificare anche la <ks>data class</ks> <kc>SystemState</kc> affinchè essa sia predisposta a contenere lo stato del <i>Led</i>.
            <pre>
<key>enum class</key> CurrStateLed { <i>ON</i>, <i>OFF</i>, <i>BLINKING</i> }
<key>data class</key> SystemState (
    <key>private var</key> currLedState : CurrStateLed = CurrStateLed.OFF
    ...
){
    ...
    <key>fun</key> setCurrLedState(ledState : CurrStateLed)
    <key>fun</key> getCurrLedState() : CurrStateLed
}</pre>

            Inoltre, per risolvere la problematica "<i>Late start of the GUI</i>" abbiamo predisposto il <i>SystemStateManager</i> all'ascolto di un messaggio del tipo:
<pre>
<key2>Dispatch</key2> getdata : getdata(_)</pre>

            Alla ricezione di questo messaggio il <i>SystemStateManager</i> esegue un <ks>updateResource</ks> inviando i dati al server CoAP. <br>
            Questo meccanismo verrà sfruttato dalla <i>GUI</i> per eseguire il <ks>Fetch</ks> dei dati all'avvio. <br>
            Infine, per predisporre il sistema a possibili sviluppi futuri e rendere il codice riutilizzabile, è stato deciso di dotare il <i>SystemStateManager</i> della capacità di riceve richieste circa lo stato del sistema e di inviare risposte. Per fare ciò sono stati introdotti i seguenti messaggi:
<pre>
<key2>Request</key2> getledstate : getledstate(_)
<key2>Request</key2> gettrolleyposition : gettrolleyposition(_)
<key2>Request</key2> gettrolleystate : gettrolleystate(_)
<key2>Request</key2> getcontainerstate : getcontainerstate(_)
<key2>Reply</key2>   givedata : givedata(DATA)</pre>

            Ai seguenti link è possibile consultare il codice del <i>SystemStateManager</i> e della <i>SystemState</i>: <br>
            <a href="./resources/qak/SystemStateManager.qak">SystemStateManager.qak</a><br>
            <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>


            <h3>GUI</h3>
            <h4>Operazioni Preliminari</h4>
            Come suggerito dagli analisti, abbiamo deciso di progettare la <kc>GUI</kc> come una Web App, sfruttando a pieno le potenzialità del framework <kc>SpringBoot</kc>. E' stata adottata questa soluzione perchè risulta essere quella più versatile e che permette di accedere alla <i>GUI</i> da qualsiasi dispositivo. 
            <br>
            Per iniziare è bastato collegarsi al sito <a href="https://start.spring.io">Spring.io</a>, il quale ci ha permesso di creare il progetto, scegliendone innanzitutto il tipo (Gradle o Maven), la versione Java da utilizzare e le dipendenze necessarie da "aggiungere" al progetto come mostrato in figura. Premuto il tasto <ks>GENERATE</ks> si ottiene un file <ks>.zip</ks> che contiene l'intero progetto. <br>
            <br>
            <img src="./resources/img/Spring_Initializr.png" width="50%" height="30%">
            <br>
            Dopo aver scaricato il file <i>.zip</i> è stato necessario decomprimerlo ed importarlo nel nostro IDE come progetto <ks>Gradle</ks>, dove abbiamo potuto notare la struttura che il framework <i>SpringBoot</i> ha creato per noi. <br>
            Dopo di che abbiamo aggiunto al file <kc>build.gradle</kc> le ulteriori dipendenze che serviranno per il progetto, oltre a quelle già generate al momento della creazione dello stesso. <br>
            <br>
            <img src="./resources/img/build.gralde.png" width="50%" height="30%"> <br>
            <br>
            Il file <i>build.gradle</i> dell'applicazione è consultabile al seguente link <a href="./resources/gradle/build.gradle">build.gradle</a>.
            <br>
            Il passo successivo è stato quello di definire all'interno del file <kc>application.properties</kc> la porta sulla quale gira la nostra applicazione, il nome dell'applicazione ed il banner che verrà mostrato all'avvio. <br>
            <br>
            <img src="./resources/img/application_properties.png" width="50%" height="30%"> <br>
            <h4>Realizzazione dell'applicazione</h4>

            <h5>Parte sviluppata in Java</h5>
            <kc>SpringBoot</kc> si basa sul pattern <i>Model-View-Controller</i> (MVC) che permette di separare la logica dell'applicazione dalla sua presentazione. <br> 
            Quando è stato creato il progetto, in maniera del tutto automatica è stata generata la classe <kc>Application</kc> che rappresenta il main della nostra applicazione. <br>

            <pre>
<key2>@SpringBootApplication</key2>
<key>public</key> <key>class</key> Application {
    <key>public</key> <key>static</key> <key>void</key> main(String[] args) {
        SpringApplication.run(WebguiApplication.class, args);
    }
}</pre>
        La classe <kc>Application</kc> è annotata con <kc>@SpringBootApplication</kc> che è un'annotazione che consente di abilitare la configurazione automatica di SpringBoot. <br>
        In generale, l'applicazione funziona anche senza aver definito un Controller, poichè al momento dell'avvio della classe <kc>main</kc>, SpringBoot va a "cercare" un file <kc>index.html</kc> all'interno della cartella <kc>resources/static</kc> e lo mostra all'utente. <br>
        Poichè nel nostro caso faremo utilizzo di un Controller, il cui codice verrà descritto più avanti, abbiamo creato all'interno della cartella <kc>resources/static</kc> un file <a href="./resources/html/webGUI.html"><kc>webGUI.html</kc></a> che contiene un form, 
        il quale permette di instaurare una connessione <i>CoAP</i> all'indirizzo ed alla porta del contesto in cui si trova il <kc>SystemStateManager</kc>.
        Dopo di che il progetto è stato realizzato consultando il software <a href="https://github.com/anatali/issLab2022/tree/main/webRobot22">webRobot22</a> fornitoci dal committente in cui troviamo un'interfaccia Java costruita nel seguente modo.
        
        <pre>
<key>public</key> <key>interface</key> IWsHandler {
    <key>void</key> sendToAll (<key>String</key> message);
}</pre>
        
        All'interno dello stesso software vi è anche una classe di supporto in cui è possibile trovare il codice per creare una connessione <i>CoAP</i> e una connessione <i>TCP</i>. 
        <pre>
<key>public</key> <key>class</key> UtilsGUI {
    <key>private</key> <key>static</key> Interaction2021 conn;
    <key>private</key> <key>static</key> Interaction2021 connTcp;      

    <key>public</key> <key>static</key> CoapConnection connectWithUtilsUsingCoap(<key>String</key> addr)() {
        <key>String</key> ctx = "ctxwasteservice";
        <key>String</key> qak = "systemstatemanager";
        <key>String</key> path = ctx+"/"+qak;
        <key>conn</key> = new CoapConnection(addr, path);
        <key>return</key> conn;
    }
}</pre>

        In questo modo si ottiente un oggetto di tipo <kc>CoapConnection</kc> e dunque una connessione verso l'indirizzo e il path che è la combinazione del nome del contesto e del nome dell'attore a cui noi facciamo riferimento e che si trova in quel determinato contesto, il <kc>SystemStateManager</kc>. <br>
        <pre>
<key>public</key> <key>static</key> void connectWithUtilsUsingTcp(<key>String</key> addr)() {
    <key>String</key> x[] = addr.trim().split(":");
    <key>connTCP</key> = TcpClientSupport.connect(x[0], Integer.parseInt(x[1]), 10);
}</pre>
        Tale metodo, invece, viene utilizzato in particolar modo per risolvere un problema posto in fase di analisi. Infatti nel caso in cui la GUI si collega dopo tanto tempo, 
        si ha il bisogno comunque di mostrare lo stato attuale del sistema. Per questo tramite la connessione <i>TCP</i> viene inviato un <kc>Dispatch</kc> al <kc>SystemStateManager</kc>, facendo quello che ci viene richiesto dagli analisti, ovvero fetch dei dati. 
        <div id="sendMsg">
            <pre>
<key>public</key> <key>void</key> sendMsg(){
    <key>String</key> msg = "msg(getdata, dispatch, webgui, systemstatemanager, getdata(_), 1)";
    <key>connTCP</key>.forward(msg);
}</pre>
        </div>
        
        La classe <kc>UtilsGUI</kc> è consultabile al seguente link <a href="./resources/java/UtilsGUI.java">UtilsGUI.java</a>.<br><br>
        Affinchè l'applicazione Spring inoltri le richieste di un client al server, è necessario registrare un gestore utilizzando una classe di configurazione che implementa l'interfaccia <kc>WebSocketConfigurer</kc>      
        <pre>
<key2>@Configuration</key2>
<key2>@EnableWebSocket</key2>
<key>public</key> <key>class</key> WebSocketConfiguration <key>implements</key> WebSocketConfigurer {
    <key>public</key> <key>static</key> <key>final</key> WebSocketHandler wshandler = <key>new</key> WebSocketHandler();
    <key2>@Override</key2>
    <key>public</key> <key>void</key> registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(wshandler, "/ws").setAllowedOrigins("*");
    }
}</pre>
L'annotazione <kc>@EnableWebSocket</kc> abilita l'uso delle plain WebSocket. <br> 
Nel nostro caso ci avvaliamo della classe <kc>WebSocketHandler</kc> per reinviare sulla WebSocket il messaggio ricevuto. Per propagare un messaggio a tutti i client connessi attraverso la WebSocket, basta tenere traccia delle sessioni.
    <pre>
<key>public</key> <key>class</key> WebSocketHandler <key>extends</key> AbstractWebSocketHandler <key>implements</key> IWsHandler {
    <key>private</key> <key>final</key> List&lt;<key>WebSocketSession</key>&gt; sessions = <key>new</key> <key>CopyOnWriteArrayList</key>&lt;&gt;();
    <key2>@Override</key2>
    <key>protected</key> <key>void</key> handleTextMessage(WebSocketSession session, TextMessage message) <key>throws</key> Exception { 
        sendToAll(message);
    }
    <key2>@Override</key2>
    <key>public</key> <key>void</key> afterConnectionEstablished(WebSocketSession session) <key>throws</key> Exception {
        sessions.add(session);
    }
    <key2>@Override</key2>
    <key>public</key> <key>void</key> afterConnectionClosed(WebSocketSession session, CloseStatus status) <key>throws</key> Exception {
        sessions.remove(session);
    }
}</pre>

    Il codice della classe <kc>WebSocketHandler</kc> è consultabile al seguente link <a href="./resources/java/WebSocketHandler.java">WebSocketHandler.java</a>.<br><br>

    La classe <kc>UtilsCoapObserver</kc> è una classe di supporto che viene utilizzata per gestire le notifiche <i>CoAP</i> che arrivano dal <kc>SystemStateManager</kc>. Essa implementa la classe <kc>CoapHandler</kc> e ha i metodi <kc>onLoad</kc> e <kc>onError</kc> che vengono richiamati quando si ha un cambiamento di stato o si verifica un errore.
    <pre>
<key>public</key> <key>class</key> UtilsCoapObserver <key>implements</key> CoapHandler {
    
    <key2>@Override</key2>
    <key>public</key> <key>void</key> onLoad(CoapResponse response){}
        <key>WebSocketConfiguration</key>.wshandler.sendToAll(""+response.getResponseText());
    }
}</pre>

Il codice della classe <kc>UtilsCoapObserver</kc> è consultabile al seguente link <a href="./resources/java/UtilsCoapObserver.java">UtilsCoapObserver.java</a>.<br><br>

Precedentemente abbiamo detto che nel progetto è stato fatto uso di un <i>Controller</i>, il quale è definito nella classe <kc>UtilsController</kc> annotata con <kc>@Controller</kc> e che viene eseguita dall'applicazione Spring. 
Al controller viene trasferito un oggetto di tipo Model gestito mediante la Java template engine <kc>Theamleaf</kc>. <br>   
Attraverso l'annotazione <kc>@Value</kc> assegniamo a delle variabili i valori definiti nel file <kc>application.properties</kc>.
<pre>
<key2>@Value("${webgui.addr}")</key2>
<key>String</key> addr;

<key2>@Value("$container.glassmax")</key2>
<key>String</key> glassmax;

...
</pre>
Quando ci colleghiamo all'indirizzo <ks>http://localhost:8085</ks> viene richiamato il metodo <kc>entry</kc>, annotato con <kc>@GetMapping</kc>, che restituisce la pagina HTML <kc>webGUI.html</kc> 
e passa come parametro il modello <kc>viewmodel</kc> alla quale vengono aggiunte le variabili definite in precedenza, tramite il metodo <kc>setConfigParams</kc>.

<pre>
<key2>@GetMapping</key2>
<key>public</key> <key>String</key> entry(Model viewmodel) {
    <key>return</key> buildThePage(viewmodel);
}</pre>

<pre>
<key>public</key> <key>String</key> buildThePage(Model viewmodel) {
    setConfigParams(viewmodel);
    <key>return</key> "webGUI";
}</pre>

<pre>
<key>public</key> <key>void</key> setConfigParams(Model viewmodel) {
    viewmodel.addAttribute("addr", addr);
    viewmodel.addAttribute("glassmax", glassmax);
    ...
}</pre>

Quando all'interno della pagina <kc>webGUI.html</kc> clicchiamo sul tasto <ks>Connect</ks>, il form in cui è contenuto attiva all'interno della classe <i>UtilsController</i> il metodo 
<kc>update</kc> annotato con <kc>@PostMapping</kc> che prende in input i parametri passati dal form. Nello specifico viene preso in input l'indirizzo IP del contesto e il numero di porta in cui si trova il <i>SystemStateManager</i>.
All'interno di questo metodo creiamo verso quell'indirizzo una connessione <i>Tcp</i> e una connessione <i>CoAP</i>. Viene dunque registrato un <i>Observer</i> sulla connessione <i>CoAP</i> che permette di ricevere le notifiche di stato del <i>SystemStateManager</i>, in quanto è una risorsa CoAP osservabile.
Infine richiamiamo il metodo <a href="#sendMsg"><kc>sendMsg()</kc></a> per inviare sulla connessione Tcp un messaggio di tipo <kc>Dispatch</kc> al <i>SystemStateManager</i>, come definito qualche parametro fa.
<pre>
<key2>@PostMapping</key2>
<key>public</key> <key>String</key> update(Model viewmodel, <key2>@RequestParam</key2> <key>String</key> ipaddr) {
    addr = ipaddr;
    viewmodel.addAttribute("addr", addr);
    <key>UtilsGUI</key>.connectWithUtilsUsingTcp(ipaddr);
    <key>UtilsGUI</key>.connectWithUtilsUsingCoap(ipaddr).observeResource(<key>new</key> UtilsCoapObserver());
    <key>UtilsGUI</key>.sendMsg();
    <key>return</key> buildTheUpdatePage(viewmodel);
}</pre>
Tale metodo restituisce la pagina <kc>update.html</kc> aggiornata con i nuovi parametri.
<br>
Il codice della classe <kc>UtilsController</kc> è consultabile al seguente link <a href="./resources/java/UtilsController.java">UtilsController.java</a>.<br>
    <h5>Parte sviluppata in javascript</h5>
    All'interno del file <kc>update.html</kc> è presente il codice javascript che permette di gestire la pagina web. Il file <kc>wsminimal.js</kc> 
    si occupa di creare una socket attraverso la funzione <i>connect()</i> all'indirizzo <ks>ws://localhost:8085/socket</ks> assicurandosi che vi sia aperta un unica connessione. 
    Assegniamo a <kc>socket.onmessage</kc> una funzione che prende in input un evento di tipo <kc>MessageEvent</kc> in modo da recuperare il messaggio inviatoci dall'attore <kc>SystemStateManager</kc>.
    
    Quindi creiamo un oggetto JSON a partire dal messaggio e salviamo in una variabile per ogni coppia chiave-valore il valore contenuto nel messaggio.

    Quindi attraverso la funzione <kc>setMessageToWindow</kc>, contenuta nel file <kc>ioutils.js</kc>, assegniamo il valore di una determinata "chiave" al <i>div</i> corrispondente ottenuto tramite l'ID.

    <pre>
<key>function</key> connect(){
    ...

    <key>socket</key> = <key>new</key> WebSocket(addr);

    <key>socket</key>.<key>onmessage</key> = <key>function</key>(event){
        msg = <key>event</key>.data;

        <key>let</key> container = <key>JSON</key>.parse(msg);

        <key>let</key> gMax = container['boxMaxWeight']['GLASS'];
        <key>let</key> pMax = container['boxMaxWeight']['PLASTIC'];

        ...

        setMessageToWindow(glassmax, gMax.toString());
        setMessageToWindow(plasticmax, pMax.toString());

        ...
    }
}</pre>
In questo modo ogni volta che il <i>SystemStateManager</i> invia un messaggio di stato, la pagina web viene aggiornata con i nuovi valori, mostrando il peso attuale dei container, lo stato e la posizione del <i>transportTrolley</i>. <br>
Per mostrare la mappa della stanza è stato sviluppato un ulteriore file javascript <kc>generate.js</kc> che si occupa di creare la mappa in maniera dinamica a partire dalle coordinate dei punti d'interesse che si trovano all'interno del file <a href="./resources/json/wasteServiceSystemConfig.json"><kc>WasteServiceSystemConfig.json</kc></a> e che otteniamo, in maniera sincrona, tramite <ks>jQuery</ks> come mostrato dal codice seguente.
<pre>
<key>$.</key><key>ajax</key>({
    <key>dataType</key>: "json",
    <key>url</key>: "./WasteServiceSystemConfig.json",
    <key>data</key>: null,
    <key>async</key>: false,
    <key>success</key>: function(data) {
        <key>$</key>.<key>each</key>(data, function (k, v) {
            dataFromJson[k] = v
        })
    }
});</pre> 
Ogni qual volta si ha un cambiamento di stato, in particolar modo quando la posizione del transportTrolley cambia, la mappa della stanza viene aggiornata indicando con un colore diverso la 
cella corrispondente in cui si trova. 
<br><br>
In questo Sprint, inoltre, ci siamo occupati di predisporre la GUI per la visualizzazione delle notifiche da parte del Led. Dai requisiti forniti dal commitente risulta chiaro che il Led deve essere spento quando il <i>transportTrolley</i> 
si trova nella posizione di <b><i>HOME</i></b> e nello stato di <b><i>IDLE</i></b>. Deve essere acceso quando lo stato del trolley è <b><i>STOPPED</i></b>, <b><i>PICKINGUP</i></b> o <b><i>DROPPINGOUT</i></b> e deve lampeggiare quando lo stato è <b><i>MOVING</i></b> e la posizione è <b><i>ONTHEROAD</i></b>.
Per fare ciò abbiamo inserito all'interno del file <kc>update.html</kc> due "div" ciascuno con un ID diverso, al cui interno troviamo un ulteriore "div" che contiene lo stile di un cerchio grigio con cui rappresentiamo il led spento.
All'interno del file <kc>wsminimal.js</kc> a seconda dei casi descritti precedentemente abbiamo aggiunto il seguente codice:
<pre>
<key>let</key> flag = 1

<key>if</key>(position.toString() == "HOME" && trolley.toString() == "IDLE"){
    <key>led2</key>.<key>classList</key>.add("d-none")
    <key>led1</key>.<key>classList</key>.remove("d-none")
    <key>circle</key>.<key>style</key>.background = "grey"
}

<key>if</key>(trolley.toString() == "STOPPED" || trolley.toString() == "PICKINGUP" || trolley.toString() == "DROPPINGOUT"){
    <key>led2</key>.<key>classList</key>.add("d-none")
    <key>led1</key>.<key>classList</key>.remove("d-none")
    <key>circle</key>.<key>style</key>.background = "green"
}

<key>if</key>(trolley.toString() == "MOVING" && position.toString() == "ONTHEROAD"){
    <key>led1</key>.<key>classList</key>.add("d-none")
    <key>led2</key>.<key>classList</key>.remove("d-none")
    <key>setInterval</key>(<key>function</key> () {         //funzione che permette di far lampeggiare il led
        <key>if</key>((flag%2)==0){
            <key>circle</key>.<key>style</key>.background = "green"
        }
        <key>else</key>{
            <key>circle</key>.<key>style</key>.background = "grey"
        }
        <key>flag</key>++
    },300)
}</pre>
Ai seguenti link è possibile consultare il codice javascript sviluppato per la pagina web <kc>update.html</kc><br>
<a href="./resources/js/ioutils.js">ioutils.js</a>.<br>
<a href="./resources/js/wsminimal.js">wsminimal.js</a>.<br>
<a href="./resources/js/generate.js">generate.js</a>.<br>
        <br>
Il codice del file <kc>update.html</kc> è disponibile al seguente link: <a href="./resources/html/update.html">update.html</a>.<br>
</div>

        <h2>Testing</h2>
        <div class="remarkTest">
            Per verificare il corretto funzionamento del sistema, è stata instanziata la classe di test: <a href="./resources/kotlin/TestSystemStateManager.kt">TestSystemStateManager.kt</a>.
            Dal momento che la <kc>WasteServiceStatusGUI</kc> è progettata come un componente passivo che riceve dati su una connessione <ks>CoAP</ks>, per verificare il corretto funzionamento 
            del sistema sarà sufficente verificare che la <kc>WasteServiceStatusGUI</kc> riceva i giusti aggiornamenti di stato da parte dello <kc>SystemStateManager</kc>. <br>
            A tale scopo, il test plan prevede di inviare una serie di richieste di deposito al <kc>WasteService</kc> e di verificare che il <i>SystemStateManager</i> invii sulla connessione <i>CoAP</i> 
            gli aggiornamenti di stato corretti. <br>
            <pre>
<key>fun</key> testLoadAcceptUpdate(){
    <key>var</key> storeWaste = <key3>"msg(storewaste, request, testunit, wasteservice, storewaste(GLASS, 50),1)"</key3>
    conn.request(storeWaste)
    <key>var</key> newState = obs.getNext()
    assertTrue(...)
    assertTrue(...)
}</pre>
        </div>

        <h2>Checkpoint Sprint2</h2>
        <div class="remark">
            A seguito dell'analisi del problema e delle successive fasi di progetto e sviluppo l'architettura logica è stata così ridefinita: <br>
            <div style="display: flex; flex-direction: row; justify-content: space-between;">
                <img src="./resources/img/ArchLogicSprint2Final.png" alt="" style="width:60% ; height:60% ;">
                <div style="display: flex; flex-direction:column;">
                <a href="./resources/qak/wasteService.qak">wasteService.qak</a>
                <a href="./resources/java/UtilsController.java">UtilsController.java</a>
                <a href="./resources/python/smartdevice.py">smartdevice.py</a>
                </div>
            </div>
        </div>
        
        <div class="remark">
            <h3>How to start the system</h3>
            <ul>
                <li>
                    <b>Avviare il <kc>VirtualRobot</kc></b> <br> 
                    Da terminale navigare fino al path <i>WasteService-Project/WEnv/it.unibo.virtualRobot2020/node/WEnv/server/src</i>, lanciare il comando <i>node WebpageServer.js</i>, aprire un browser e collegarsi al seguente indirizzo: <i>http://localhost:8090</i>
                    <pre>
cd WasteService-Project/WEnv/it.unibo.virtualRobot2020/node/WEnv/server/src
node WebpageServer.js</pre>
                    </pre>
                </li>
        
                <li>
                    <b>Avviare il <kc>basicrobot22</kc></b> <br>
                    Da terminale navigare fino al path <i>WasteService-Project/Sprint1/unibo.basicrobot22</i> e lanciare il comando <i>./gradlew run </i>
                    <pre>
cd WasteService-Project/Sprint1/unibo.basicrobot22
./gradlew run</pre>
                </li>
        
                <li>
                    <b>Avviare il <kc>wasteService</kc></b> <br>
                    Da terminale navigare fino al path <i>WasteService-Project/Sprint2/unibo.wasteService</i> e lanciare il comando <i>./gradlew run </i>
                    <pre>
cd WasteService-Project/Sprint2/unibo.wasteService
./gradlew run</pre>
                </li>
        
                <li>
                    <b>Avviare lo <kc>smartdevice</kc></b><br>
                    Da terminale navigare fino al path <i>WasteService-Project/Sprint1/unibo.smartdevice</i> e lanciare il comando <i>python3 smartdevice.py</i>
                    <pre>
cd WasteService-Project/Sprint1/unibo.smartdevice
python3 smartdevice.py</pre>
                </li>

                <li>
                    <b>Avviare la <kc>WasteServiceStatusGUI</kc></b><br>
                    Da terminale navigare fino al path <i>WasteService-Project/Sprint2/webgui</i> e lanciare il comando <i>./gradlew run</i>
                    <pre>
cd WasteService-Project/Sprint2/webgui
./gradlew run</pre>
                    Aprire il browser e digitare l'indirizzo <i>http://localhost:8085</i>
                </li>
            </ul>
        </div>
	    
        <div style="display: flex; flex-direction: row; justify-content: space-around;">
            <div><a href="../../Sprint1/userDocs/sprint1.html"> <-- Sprint1</a></div>
            <div><a href="../../Sprint3/userDocs/sprint3.html"> Sprint3 --></a></div>
        </div>
        <br><br>
        <div style="background-color:rgba(60, 131, 186, 0.9); width:50%;text-align:center;color:white; margin-left: 25%; border-radius: 25px;" >
            <br>
            By students: <br>
            Name: Annamaria Simonitto, Enrico Valastro, Alessio Reitano   
            <br>
            Email: annamaria.simonitto@studio.unibo.it, enrico.valastro@studio.unibo.it, alessio.reitano@studio.unibo.it
            <br><br>
            <img src="../../Sprint0/userDocs/resouces/images/AnnamariaSimonitto.jpg" alt="" width="8%" height="8%">
            <img src="../../Sprint0/userDocs/resouces/images/EnricoValastro.jpeg" alt="" width="8.5%" height="8.5%">
            <img src="../../Sprint0/userDocs/resouces/images/AlessioReitano.jpeg" alt="" width="10%" height="10%">
        </div> 

    </div>
</body>
</html> 