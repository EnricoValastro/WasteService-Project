<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    body
    {
        margin-left:  30px;
        margin-right: 30px;
    };
    
    P
    {
        font-family: Tahoma;
        font-size: 10pt;
    };
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }
    
    a:hover {
        background-color: #cccccc;
    }
    
    
    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }
    
    h1, h2, h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }
    
    top {
        width: 100%;
    }
    
    
    #i {
        color: #ff1010;
    }
    tt{
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }
    em{
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style:solid;
        border-color: #abe876;
        color: #1632cc;
    }
    bc{
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }
    ks{
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD	;
        font-size: 90%;
    }
    kc{
        font-family: "Arial";
        font-weight: bold;
        color: #008000	;
        font-size: 90%;
    }
    pre{
        font-family:monospace;
        font-weight: 500;
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }
    key{
        font-family:monospace;
        font-weight: 500;	
        color: #304ceb;
    }
    key2{
        font-family:monospace;
        font-weight: 500;
        color: #ad0d0f;
    }
    
    key3{
        font-family:monospace;
        font-weight: 500;
        color: #01b948;
    }
    
    key4{
        font-family:monospace;
        font-weight: 500;
    
        color: #008232;
    }
    
    pro{
        font-weight: bold;
        color:blue;
    }
    cons{
        font-weight: bold;
        color: red;
    }
    
    m{
        font-family: "Helvetica";
        line-height: 100%;
         font-size: 75%;
    }
    div.body{
         
        font-size: 18px;
    }
    k{
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }
    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }
    
    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }
    
    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }
    h3.test{
        background-color: #42b966;
        font-size: 100%;
    }
    h4 {
        background-color: #6dd4f4b5;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    h4.test{
        background-color: #5ee887;
        font-size: 100%;
    }
    h5 {
        background-color: #91df4d;
        font-size: 100%;
        width: 100%;
        border-radius: 5px;
        padding: 2px;
    }
    div.req{
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }
    div.remark{
        background-color: #E3F2FD;
        border: 1.5px solid #E3F2FD;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    div.remarkTest{
        background-color: #d4fbd7;
        border: 1.5px solid #d4fbd7;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    
    ol, ul, li {
      margin: 0;
      margin-left: 10px;
      padding: 0;
      padding-bottom: 5px;
    }
    
    table, th, td {
        border: 1px solid black;
    }
    
    img {
        border: 1.5px solid #d5f2ed
    
    }
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }
    
    div.wrapdesc{
        width: 90%;
        margin: auto;
    }
    
    div.imagedesc{
        width: 85%;
        margin: auto;
    }
    </style>
    
<head>
    <meta charset="UTF-8">
    <title>Sprint2</title>
</head>
    
<body>
    <div id="top">
        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font> </h1>
    </div>  

    <div class="body"> 
        <a href="../../Sprint0/userDocs/sprint0.html">Sprint 0</a>
        <a href="../../Sprint1/userDocs/sprint1.html">Sprint 1</a>
        <a href="./sprint2.html">Sprint 2</a>
        <a href="../../Sprint3/userDocs/sprint3.html">Sprint 3</a>
        <h2>Introduction</h2>
        <div class="remark">
            Progetto finale di ISS finalizzato allo sviluppo software di un impianto di smistamento dei rifiuti attraverso un robot che preleva il carico del camion e lo porta al container appropriato
        </div>

        <h2>Requirements</h2>
        <div class="remark">
            <a href="../../Sprint0/userDocs/resouces/html/TemaFinale22.html">TemaFinale22</a>
        </div>

        <h2>Work Plan</h2>
        <div class="remark">
            In questo Sprint ci occuperemo della <kc>WasteServiceStatusGUI</kc>. Questa permetterà al Service-manager di: 
            <ul>
                <li>vedere lo stato corrente del transportTrolley e la sua posizione nella stanza</li>
                <li>vedere il peso corrente dei due container</li>
                <li>vedere lo stato corrente del Led</li>
            </ul>
            Nello Sprint analizzeremo le principali problematiche relative alla GUI e le risolveremo.
         
        </div>

        
        <h2>Checkpoint Sprint1</h2>
        <div class="remark">
            <h3>Sprint1 result</h3>
            L'analisi condotta nello <a href="../../Sprint1/userDocs/sprint1.html">Sprint1</a> e la successiva fase di progetto e sviluppo, hanno dato vita ad un sistema che 
            presenta la seguente architettura logica: <br></br>
            <img src="../../Sprint1/userDocs/resources/img/ArchLogicSprint1Review.png" alt="" width="60%" height="60%">
            <br>
            L'obbiettivo di questo Sprint, è quello di zoomare sul componente <kc>WasteServiceStatusGUI</kc>, affrontare e superare le problematiche connessa alla sua implementaizione e fornire un prototipo funzionante del componente, che 
            verrà integrato con il sistema sviluppato nello Sprint1.

        </div>
        <h2>Problem analysis</h2>
        <div class="remark">
            <div id="gui"><h3>Problem: Kind of GUI</h3></div>
            Per sviluppare la <kc>GUI</kc> è possibile servirsi di: <br>
            <ul>
                <li>App Android</li>
                <li>Web App</li>
                <li>App iOS</li>
            </ul>
            Per quanto riguarda l'App Android e iOS, il <kc>Service-manager</kc> dovrebbero essere fornito di un dispositivo compatibile con essa, ciò risulta poco inclusivo e riutilizzabile. <br>
            Per quanto riguarda la Web App invece, è possibile utilizzare un browser web da qualsiasi dispositivo per accedere alla GUI, risultando quindi più versatile.<br>
            Dopo aver analizzato le varie opzioni, suggeriamo al team di sviluppo, la strada della Web App, servendosi del framework <ks>SpringBoot</ks>, di cui il team ha una buona conoscenza. <br>
        </div>

        <div class="remark">
            <div id="dataSource"><h3>Problem: Show Data</h3></div>
            Dai requisiti, emerge che il componente <kc>WasteServiceStatusGUI</kc> deve essere in grado di mostrare ad un utente umano, il <kc>Service-manager</kc>, 
            una serie di informazioni riguardanti lo stato del sistema e dei sui componenti. <br>
            <h4>Data Source</h4>
            Bisogna quindi comprendere quali siano le fonti di tali informazioni. In particolare, la <i>GUI</i> deve fornire informazioni su:
            <ul>
                <li>
                    <b>Stato del <kc>transportTrolley</kc> e la sua posizione nella stanza</b>
                </li>
                <li>
                    <b>Peso corrente dei due container</b>
                </li>
                <li>
                    <b>Stato corrente del Led</b>
                </li>
            </ul>
            <h5>Stato e posizione del transportTrolley</h5>
            Dall'analisi dei requisiti è emerso che lo stato e la posizione del <kc>transportTrolley</kc>, possono essere rappresentati tramite i seguenti enumerativi:

            <pre>
<key>enum</key> <key>class</key> CurrStateTrolley { <i>IDLE</i>, <i>STOPPED</i>, <i>MOVING</i>, <i>PICKINGUP</i>, <i>DROPPINGOUT</i> }</pre>

            <pre>
<key>enum</key> <key>class</key> TTPosition { <i>HOME</i>, <i>INDOOR</i>, <i>PLASTICBOX</i>, <i>GLASSBOX</i>, <i>ONTHEROAD</i> }</pre>

            Inoltre, in seguito all'analisi condotta nello Sprint1, è stato deciso di mantenere questi dati utilizzando la <ks>data class Kotlin</ks> <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>. 
            I dati vengo amministrati da un componente, che è stato creato <i>ad hoc</i> per gestire e mantenere lo stato del sistema, il <kc>SystemStateManager</kc>.
            Tale componente è implementato come un attore QAk, pertanto esso è definito come una risorsa CoAP osservabile, il che lo rende una possibile fonte per i dati di interesse della GUI.

            <h5>Peso corrente dei due container</h5>
            Dall'analisi dei requisiti è emerso che il peso corrente dei due container, può essere rappresentato tramite una <ks>MutableMap</ks>:
            <pre>
<key>private val</key> boxCurrentWeight : MutableMap < Material, Double ></pre>
            
            Inoltre, come emerso dallo Sprint1, lo stato dei container è mantenuto nella <ks>data class Kotlin</ks> <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>. 
            Anche in questo caso, i dati relativi al peso corrente dei container vengono amministrati dal <i>SystemStateManager</i>.
            
            <h5>Stato del Led</h5>
            Per quanto rigurda lo stato del led, dall'analisi dei requisiti è emerso che può essere rappresentato tramite un enumerativo:

            <pre>
<key>enum</key> <key>class</key> CurrStateLed { <i>ON</i>, <i>OFF</i>, <i>BLINKING</i> }</pre>
            
            Tuttavia, la sua gestione, resta una problematica ancora aperta che verrà trattata nello Sprint3. Ciò nonostante, supponiamo che lo stato del led sarà gestito allo 
            stesso modo degli altri dati, ossia tramite il <i>SystemStateManager</i>. Per tale motivo, suggeriamo agli sviluppatori di apportare le modifiche necessarie, al <i>SystemStateManager</i> 
            e alla <i>data class</i> <a href="./resources/kotlin/SystemState.kt">SystemState.kt</a>, affinchè essi siano predisposti alla gestione dello stato del led.
            
            <br><br>
            Alla luce di questa analisi è possibile affermare che la <i>fonte di dati</i> per la GUI, è rapresentata dal componente <i>SystemStateManager</i>.
            <h4>Polling vs Push</h4>
            Una volta compreso che il <kc>SystemStateManager</kc> è la fonte di dati per la GUI, bisogna comprendere come questi dati vengano recuperati dalla GUI. <br>
            Sono possibili due modalità di recupero dei dati:
            <h5>Polling</h5>
            Questa soluzione prevede che sia la GUI a richiedere i dati al <kc>SystemStateManager</kc>, ciò comporta che la <i>GUI</i> debba aprire un canale di comunicazione con il <kc>SystemStateManager</kc>, 
            richiedere i dati e stare in ascolto di risposte. <br> Inoltre, affinchè non venga perso nessun dato, è necessario che questa operazione venga ripetuta ad intervalli regolari, generando un elevato <i>overhead</i> di rete.<br> 
            Per tale motivo, sconsigliamo agli sviluppatori di adottare questo approccio.
            <h5>Push</h5>
            Tale soluzione prevede che la <kc>GUI</kc> venga progettata come un componente passivo, che riceve dati e li mostra all'utente. Per fare ciò è necessario, che qualche componente 
            invii in maniera spontanea, tutti gli aggioramenti di stato alla <i>GUI</i>. <br> 
            L'adozione di questa soluzione è particolarmente consigliata, in quanto permette di sfruttare la caratteristica degli attori QAk di essere realizzati come delle risorse <i>CoAP</i> osservabili. 
            Procedendo in questo modo, sarà sufficente che la <i>GUI</i> apra una conessione <i>CoAP</i> con il <i>server CoAP</i> del <kc>SystemStateManager</kc> e si registri come osservatore della risorsa.
            Successivamente l'attore QAk, potrà utilizzare la primitiva <ks>updateResources</ks> per inviare al server <i>CoAP</i> l'aggiornamento di stato, questo successivamente notificherà gli osservatori circa il cambiamento di stato.

        </div>
        
        <div class="remark">
            <div id="lateStart"><h3>Problem: Late start of the GUI</h3></div>
            Dal momento che l'avvio del <kc>WasteService</kc> è svincolato dall'avvio della <kc>GUI</kc>, potrebbe verificarsi lo scenario in cui 
            la <i>GUI</i> parta dopo il <i>WasteService</i>. <br>
            Bisogna comprendere come, in tale circostanza, debba essere gestito l'aggiornamento dei dati mostrati dalla <i>GUI</i>.
            Infatti se la <i>GUI</i> dovesse essere avviata tempo dopo il <i>WasteService</i>, potrebbero essersi verificati dei cambiamti di stato che la <i>GUI</i> non mostra.<br>
            Si pone il problema di come gestire l'aggiornamento dei dati mostrati dalla <i>GUI</i> in caso di <i>late start</i>. <br>
            <ul>
                <li>Fare fetch all'avvio della GUI</li>
                <li>Aspettare che una richiesta scateni un <ks>updateResources</ks></li>
            </ul>
            <h4>Waiting for updateResources</h4>
            Aspettare che arriva un'altra richiesta al WasteService è la soluzione più semplice da implementare, ma non è la migliore. <br>
            Infatti protrebbe verificarsi il caso in cui al WasteService non arrivino richieste anche per istanti di tempo lunghi, pertanto la GUI non si aggiornerà fino a quel momento, mostrando dei dati errati. <br>
            <h4>Fetch</h4>
            Per fare ciò, si potrebbe inviare al <kc>SystemStateManager</kc>, usando una connessione TCP, un messaggio per richiedere l'invio dei dati. <br>
            Bisogna capire che tipo di messaggio inviare, un <kc>Dispatch</kc> o una <kc>Request</kc>. Utilizzando una <i>Request</i> la GUI dovrebbe rimanere in attesa della risposta, e gestire il messaggio ricevuto.
            Utilizzando un <i>Dispatch</i>, si potrebbero evitare tali problematiche, in quanto, alla ricezione del <i>Dispatch</i>, il <kc>SystemStateManager</kc> scatenerà un <ks>updateResources</ks> che verrà raccolto e gestito in maniera analoga 
            agli aggiornamenti di stato.
            <pre>
<key2>Dispatch</key2> getdata : getdata(_)</pre>
            Alla luce di ciò, consigliamo agli sviluppatori di progettare la <i>GUI</i> in modo che faccia <i>Fetch</i> dei dati all'avvio.
        </div>
        
        <div class="remark">
            <h3>Architettura Logica</h3>
            Sulla base di quanto emerso in fase di analisi del problema è possibile ridefinire l'architettura logica del sistema.<br> 
            <br><br>
            <div style="display: flex; flex-direction: row; justify-content: space-between;">
                <img src="./resources/img/ArchLogicSprint2v2.png" alt="" style="width:60% ; height:60% ;">
                <div style="display: flex; flex-direction:column;">
                <a href="./resources/qak/wasteService.qak">wasteService.qak</a>
                <a href="./resources/java/UtilsController.java">UtilsController.java</a>
                <a href="./resources/python/smartdevice.py">smartdevice.py</a>
                </div>
            </div>
            
        </div>
    
        <h2>Project</h2>
        <div class="remark">
            <h3>GUI</h3>
            <h4>Operazioni Preliminari</h4>
            Come suggerito dagli analisti, si è deciso di progettare la <kc>GUI</kc> come una Web App, sfruttando a pieno le potenzialità del framework <kc>SpringBoot</kc>. Si è optato per questa soluzione perchè risulta essere quella più versatile che permette di accedere alla <i>GUI</i> da qualsiasi dispositivo. 
            <br>
            Per iniziare è bastato collegarsi al sito <a href="https://start.spring.io">Spring.io</a>, il quale ci ha permesso di creare il progetto, scegliendone innanzitutto il tipo (Gradle o Maven), la versione Java da utilizzare e le dipendenze necessarie da "aggiungere" al progetto come mostrato in figura. Premuto il tasto <ks>GENERATE</ks> si ottiene un file <ks>.zip</ks> che contiene l'intero progetto. <br>
            <br>
            <img src="./resources/img/Spring_Initializr.png" width="50%" height="30%">
            <br>
            Dopo aver scaricato il file <i>.zip</i> è stato necessario decomprimerlo e importarlo nel nostro IDE come progetto <ks>Gradle</ks>, dove abbiamo potuto notare la struttura che il framework <i>SpringBoot</i> ha creato per noi. <br>
            Dopo di che andiamo ad aggiungere al file <kc>build.gradle</kc> le ulteriori dipendenze che ci serviranno per il progetto, oltre a quelle già generate al momento della creazione del progetto. <br>
            <br>
            <img src="./resources/img/build.gralde.png" width="50%" height="30%"> <br>
            <br>
            Il file <i>build.gralde</i> dell'applicazione è consultabile al seguente link <a href="./resources/gradle/build.gradle">build.gradle</a>.
            <br>
            Il passo successivo è stato quello di definire all'interno del file <kc>application.properties</kc> la porta sulla quale gira la nostra applicazione, il nome dell'applicazione e il banner che verrà mostrato all'avvio. <br>
            <br>
            <img src="./resources/img/application_properties.png" width="50%" height="30%"> <br>
            <h4>Realizzazione dell'applicazione</h4>
            SpringBoot si basa sul pattern <i>Model-View-Controller</i> (MVC) che permette di separare la logica dell'applicazione dalla sua presentazione. <br> 
            Quando è stato creato il progetto, in maniera del tutto automatica è stata generata la classe <kc>Application</kc> che rappresenta il main della nostra applicazione. <br>

            <pre>
<key2>@SpringBootApplication</key2>
<key>public</key> <key>class</key> Application {
    <key>public</key> <key>static</key> <key>void</key> main(String[] args) {
        SpringApplication.run(Application.<key>class</key>, args);
    }
}</pre>
        La classe <kc>Application</kc> è annotata con <kc>@SpringBootApplication</kc> che è un'annotazione che consente di abilitare la configurazione automatica di SpringBoot. <br>
        In generale, l'applicazione funziona anche senza aver definito un Controller, poichè al momento dell'avvio della classe main, SpringBoot va a "cercare" un file <kc>index.html</kc> all'interno della cartella <kc>resources/static</kc> e lo mostra all'utente. <br>
        Poichè nel nostro caso faremo utilizzo di un Controller, il cui codice verrà descritto più avanti, abbiamo creato all'interno della cartella <kc>resources/static</kc> un file <a href="./resources/html/webGUI.html">webGUI.html</a> che contiene un form, 
        il quale permette di instaurare una connessione Coap all'indirizzo e alla porta del contesto in cui si trova il <kc>SystemStateManager</kc>.
        Dopo di che il progetto è stato realizzato consultando il software <a href="https://github.com/anatali/issLab2022/tree/main/webRobot22">webRobot22</a> fornitoci dal committente in cui troviamo un'interfaccia Java costruita nel seguente modo.
        
        <pre>
<key>public</key> <key>interface</key> IWsHandler {
    <key>void</key> sendToAll (<key>String</key> message);
}</pre>
        
        All'interno del software fornitoci vi è anche una classe di supporto in cui è possibile trovare il codice per creare una connessione <i>Coap</i> e una connessione <i>TCP</i>. 
        <pre>
<key>public</key> <key>class</key> UtilsGUI {
    <key>private</key> <key>static</key> Interaction2021 conn;
    <key>private</key> <key>static</key> Interaction2021 connTcp;      

    <key>public</key> <key>static</key> CoapConnection connectWithUtilsUsingCoap(<key>String</key> addr)() {
        <key>String</key> ctx = "ctxwasteservice";
        <key>String</key> qak = "systemstatemanager";
        <key>String</key> path = ctx+"/"+qak;
        <key>conn</key> = new CoapConnection(addr, path);
        <key>return</key> conn;
    }
}</pre>

        In questo modeo si ottiente un oggetto di tipo <kc>CoapConnection</kc> e dunque una connessione verso l'indirizzo e il path che è la combinazione del nome del contesto e del nome dell'attore che si trova in quel determinato contesto e a cui noi facciamo riferimento, il <kc>SystemStateManager</kc>. <br>
        <pre>
<key>public</key> <key>static</key> void connectWithUtilsUsingTcp(<key>String</key> addr)() {
    <key>String</key> x[] = addr.trim().split(":");
    <key>connTCP</key> = TcpClientSupport.connect(x[0], Integer.parseInt(x[1]), 10);
}</pre>
        Tale metodo viene utilizzato in particolar modo per risolvere un problema posto in fase di analisi. Infatti nel caso in cui la GUI si collega dopo tanto tempo, 
        si ha il bisogno comunque di mostrare lo stato attuale del sistema. Per questo tramite la connessione <i>TCP</i> viene inviato un <kc>Dispatch</kc> al <kc>SystemStateManager</kc>, facendo quello che ci viene richiesto dagli analisti, ovvero fetch dei dati. 
        <pre>
<key>public</key> <key>void</key> sendMsg(){
    <key>String</key> msg = "msg(getdata, dispatch, webgui, systemstatemanager, getdata(_), 1)";
    <key>connTCP</key>.forward(msg);
}</pre>
        La classe <kc>UtilsGUI</kc> è consultabile al seguente link <a href="./resources/java/UtilsGUI.java">UtilsGUI.java</a>.<br><br>
        Affinchè l'applicazione Spring inoltri le richieste di un client al server, è necessario registrare un gestore utilizzando una classe di configurazione che implementa l'interfaccia <kc>WebSocketConfigurer</kc>      
        <pre>
<key2>@Configuration</key2>
<key2>@EnableWebSocket</key2>
<key>public</key> <key>class</key> WebSocketConfiguration <key>implements</key> WebSocketConfigurer {
    <key>public</key> <key>static</key> <key>final</key> WebSocketHandler wshandler = <key>new</key> WebSocketHandler();
    <key2>@Override</key2>
    <key>public</key> <key>void</key> registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(wshandler, "/ws").setAllowedOrigins("*");
    }
}</pre>
L'annotazione <kc>@EnableWebSocket</kc> abilita l'uso delle plain WebSocket. <br> 
Nel nostro caso ci avvaliamo della classe <kc>WebSocketHandler</kc> per reinviare sulla WebSocket il messaggio ricevuto. Per propagare un messaggio a tutti i client connessi attraverso la WebSocket, basta tenere traccia delle sessioni.
    <pre>
<key>public</key> <key>class</key> WebSocketHandler <key>extends</key> AbstractWebSocketHandler <key>implements</key> IWsHandler {
    <key>private</key> <key>final</key> List&lt;<key>WebSocketSession</key>&gt; sessions = <key>new</key> <key>CopyOnWriteArrayList</key>&lt;&gt;();
    <key2>@Override</key2>
    <key>protected</key> <key>void</key> handleTextMessage(WebSocketSession session, TextMessage message) <key>throws</key> Exception { 
        sendToAll(message);
    }
    <key2>@Override</key2>
    <key>public</key> <key>void</key> afterConnectionEstablished(WebSocketSession session) <key>throws</key> Exception {
        sessions.add(session);
    }
    <key2>@Override</key2>
    <key>public</key> <key>void</key> afterConnectionClosed(WebSocketSession session, CloseStatus status) <key>throws</key> Exception {
        sessions.remove(session);
    }
}</pre>

    Il codice della classe <kc>WebSocketHandler</kc> è consultabile al seguente link <a href="./resources/java/WebSocketHandler.java">WebSocketHandler.java</a>.<br><br>

    La classe <kc>UtilsCoapObserver</kc> è una classe di supporto che viene utilizzata per gestire le notifiche <i>Coap</i> che arrivano dal <kc>SystemStateManager</kc>. Essa implementa la classe <kc>CoapHandler</kc> e ha i metodi <kc>onLoad</kc> e <kc>onError</kc> che vengono richiamati quando si ha un cambiamento di stato o si verifica un errore.
    <pre>
<key>public</key> <key>class</key> UtilsCoapObserver <key>implements</key> CoapHandler {
    
    <key2>@Override</key2>
    <key>public</key> <key>void</key> onLoad(CoapResponse response){}
        <key>WebSocketConfiguration</key>.wshandler.sendToAll(""+response.getResponseText());
    }
}</pre>

Il codice della classe <kc>UtilsCoapObserver</kc> è consultabile al seguente link <a href="./resources/java/UtilsCoapObserver.java">UtilsCoapObserver.java</a>.<br><br>

Precedentemente abbiamo detto che nel progetto è stato fatto uso di un <i>Controller</i>, il quale è definito nella classe <kc>UtilsController</kc> che viene dunque annotata con <kc>@Controller</kc> e che viene eseguita dall'applicazione Spring. 

        </div>

        <h2>Test Plan</h2>
        <div class="remarkTest">
            Per verificare il corretto funzionamento del sistema, è stata instanziata la classe di test: <a href="./resources/kotlin/TestSystemStateManager.kt">TestSystemStateManager.kt</a>.
            Dal momento che la <kc>WasteServiceStatusGUI</kc> è progettata come un componente passivo che riceve dati su una connessione <ks>CoAP</ks>, per verificare il corretto funzionamento 
            del sistema sarà sufficente verificare che la <kc>WasteServiceStatusGUI</kc> riceva i giusti aggiornamenti di stato da parte dello <kc>SystemStateManager</kc>. <br>
            A tale scopo, il test plan prevede di inviare una serie di richieste di deposito al <kc>WasteService</kc> e di verificare che il <i>SystemStateManager</i> invii sulla connessione <i>CoAP</i> 
            gli aggiornamenti di stato corretti. <br>
            <pre>
<key>fun</key> testLoadAcceptUpdate(){
    <key>var</key> storeWaste = <key3>"msg(storewaste, request, testunit, wasteservice, storewaste(GLASS, 50),1)"</key3>
    conn.request(storeWaste)
    <key>var</key> newState = obs.getNext()
    assertTrue(...)
    assertTrue(...)
}</pre>
        </div>

        <h2>Checkpoint Sprint2</h2>
        <div class="remark">
            A seguito dell'analisi del problema e delle successive fasi di progetto e sviluppo l'architettura logica è stata così ridefinita: <br>
            <img src="./resources/img/ArchLogicSprint2Final.png" alt="" style="width: 60%; height: 60%">
        </div>
	    
        <div style="display: flex; flex-direction: row; justify-content: space-around;">
            <div><a href="../../Sprint1/userDocs/sprint1.html"> <-- Sprint1</a></div>
            <div><a href="../../Sprint3/userDocs/sprint3.html"> Sprint3 --></a></div>
        </div>
        <br><br>
        <div style="background-color:rgba(60, 131, 186, 0.9); width:50%;text-align:center;color:white; margin-left: 25%; border-radius: 25px;" >
            <br>
            By students: <br>
            Name: Annamaria Simonitto, Enrico Valastro, Alessio Reitano   
            <br>
            Email: annamaria.simonitto@studio.unibo.it, enrico.valastro@studio.unibo.it, alessio.reitano@studio.unibo.it
            <br><br>
            <img src="../../Sprint0/userDocs/resouces/images/AnnamariaSimonitto.jpg" alt="" width="8%" height="8%">
            <img src="../../Sprint0/userDocs/resouces/images/EnricoValastro.jpeg" alt="" width="8.5%" height="8.5%">
            <img src="../../Sprint0/userDocs/resouces/images/AlessioReitano.jpeg" alt="" width="10%" height="10%">
        </div> 

    </div>
</body>
</html> 